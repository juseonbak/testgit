============================
avg_band.f90
============================
get_apriori_covar.f90
7a8
> 
61,67c62,67
<  IF ( which_aperr == 1 )  call get_mpstd(astd(1:nref))
<  IF ( which_aperr == 12 ) call get_mlprof(astd(1:nref), 2)
<  IF ( which_aperr == 13 ) call get_tjprof(astd(1:nref), 2)  
< 
<  IF ( which_aperr >= 2 .and. which_aperr <= 4 )  call get_tbprof (astd(1:nref),2)
< 
<  IF ( which_aperr == 6) then  ! Fourtuine 
---
>   IF ( which_aperr == 1 )  call get_mpstd(astd(1:nref))
>   IF ( which_aperr == 12 ) call get_mlprof(astd(1:nref), 2) 
>   
>   IF ( which_aperr >= 2 .and. which_aperr <= 4 )  call get_tbstd (astd(1:nref))
>   
>   IF ( which_aperr == 6) then  ! Fourtuine 
70c70
<              30., 50., 70., 100., 150., 200., 300., 500., 700., 1000.0/)  
---
>           30., 50., 70., 100., 150., 200., 300., 500., 700., 1000.0/)  
72,73c72,73
<  ENDIF 
< 
---
>   ENDIF
>   
77c77
<    
---
>   
79,85c79,85
<     IF (ps(nz) > p0) then !sfc
<         tmp = ( ps(nz) - p0)/(pres(nref)-pres(nref-1))
<         astd(nref) = astd(nref)*(1+tmp)
<         pres(nref) = ps(nz)
<     ENDIF
<     IF ( ps(0) < pres(0) ) pres(0) = ps(0) !top
< 
---
>   IF (ps(nz) > p0) then !sfc
>      tmp = ( ps(nz) - p0)/(pres(nref)-pres(nref-1))
>      astd(nref) = astd(nref)*(1+tmp)
>      pres(nref) = ps(nz)
>   ENDIF
>   IF ( ps(0) < pres(0) ) pres(0) = ps(0) !top
>   
87,98c87,98
<     cumastd(0) = 0.0
<     DO i = 1, nref
<        cumastd(i) = cumastd(i-1) + astd(i) 
<     ENDDO   
< 
<     preslg = LOG(pres); pslg = LOG(ps)
<     CALL BSPLINE(preslg(0:nref), cumastd(0:nref),nref+1, pslg(0:nz),&
<          nstd(0:nz), nz+1, errstat)
<     IF (errstat < 0) THEN
<        WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat; STOP
<     ENDIF
< 
---
>   cumastd(0) = 0.0
>   DO i = 1, nref
>      cumastd(i) = cumastd(i-1) + astd(i) 
>   ENDDO
>   
>   preslg = LOG(pres); pslg = LOG(ps)
>   CALL BSPLINE(preslg(0:nref), cumastd(0:nref),nref+1, pslg(0:nz),&
>        nstd(0:nz), nz+1, errstat)
>   IF (errstat < 0) THEN
>      WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat; STOP
>   ENDIF
>   
103c103
<  
---
>   
118c118
<   
---
>      
132c132
<   
---
>      
142c142
< 
---
>   
144c144
<   IF (loose_aperr) THEN !jbak
---
>   IF (loose_aperr) THEN
146c146
< !        IF (nstd(i) / ozprof(i) < min_serr) THEN
---
>         IF (nstd(i) / ozprof(i) < min_serr) THEN
148c148
< !        ENDIF
---
>         ENDIF
152c152
< !        IF (nstd(i) / ozprof(i) < min_terr) THEN
---
>         IF (nstd(i) / ozprof(i) < min_terr) THEN
154,155c154,155
< !        ENDIF
<      ENDDO     
---
>         ENDIF
>      ENDDO
159c159
< 
---
>   
168,170c168,169
<       
<         sao3(i, j) = SQRT(sao3(i,i) * sao3(j, j)) * EXP(- ABS((zmid(i)-zmid(j)) / corrlen)**2 )
<        
---
>         sao3(i, j) = SQRT(sao3(i,i) * sao3(j, j)) * &
>              EXP(- ABS((zmid(i)-zmid(j)) / corrlen)**2 )
174,175c173
< 
<     
---
>    
179,182d176
< 
< 
< 
< 
217d210
< 
219,220c212,213
< ! ** load std profiles ** !
< !  IF (which_aperr == 1) print *,'Sao3 set to be LLM'
---
>   ! ** load std profiles ** !
>   !  IF (which_aperr == 1) print *,'Sao3 set to be LLM'
222,229c215,221
<         apfname = TRIM(ADJUSTL(atmdbdir)) // 'mpclima/llmclima_std.dat'
<         OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
<         READ (atmos_unit, '(A)') ;  READ(atmos_unit, '(A)') 
<         DO i = 1, nmon   
<            READ(atmos_unit, '(A)') ;  READ(atmos_unit, '(A)')  ! read month label
<            DO k = nlay, 1, -1
<               READ(atmos_unit, *) idum, (stds(i, j, k), j=1, nlat) ! ppmv
<            ENDDO
---
>      apfname = TRIM(ADJUSTL(atmdbdir)) // 'mpclima/llmclima_std.dat'
>      OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
>      READ (atmos_unit, '(A)') ;  READ(atmos_unit, '(A)') 
>      DO i = 1, nmon   
>         READ(atmos_unit, '(A)') ;  READ(atmos_unit, '(A)')  ! read month label
>         DO k = nlay, 1, -1
>            READ(atmos_unit, *) idum, (stds(i, j, k), j=1, nlat) ! ppmv
231,235c223,228
<         CLOSE(atmos_unit)
<         first = .FALSE.
<  ENDIF
<          
< ! ** interpolation for lat, mon** ! 
---
>      ENDDO
>      CLOSE(atmos_unit)
>      first = .FALSE.
>   ENDIF
>   
>   ! ** interpolation for lat, mon** ! 
250,251c243
< 
< 
---
>   
253c245
<         nband = 1; latin(1) = 1; latfrac(1) = 1.0
---
>      nband = 1; latin(1) = 1; latfrac(1) = 1.0
255c247
<         nband = 1; latin(1) = nlat; latfrac(1) = 1.0
---
>      nband = 1; latin(1) = nlat; latfrac(1) = 1.0
257,259c249,251
<         nband = 2     ; frac = (the_lat + 85.0) / 10.0 + 1
<         latin(1) = INT(frac); latin(2) = latin(1) + 1
<         latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
---
>      nband = 2     ; frac = (the_lat + 85.0) / 10.0 + 1
>      latin(1) = INT(frac); latin(2) = latin(1) + 1
>      latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
261c253
< 
---
>   
264,266c256,258
<         DO j = 1, nm
<            std0 =  std0 + stds(monin(j), latin(i), :) * monfrac(j) * latfrac(i)
<         ENDDO
---
>      DO j = 1, nm
>         std0 =  std0 + stds(monin(j), latin(i), :) * monfrac(j) * latfrac(i)
>      ENDDO
268,269c260,261
<      
< ! ** convert ppm into DU ** ! 
---
>   
>   ! ** convert ppm into DU ** ! 
275c267
< 
---
>   
277c269
< 
---
>   
279a272,360
> ! ===============================================================
> ! Obtain TB hybrid variance
> ! drive variance by varialbe shifht or non shifht depending on
> !      the number of sources with trpz below 14 km and latitude
> ! And then merging with LLM variance
> ! ** variable shift region    between tropz - 5 km and tropz + 5 km
> ! ** non shift region         below tropz tropz-5 km
> ! ** merging with LLM region  between tropz+5km and tropz+10 km
> ! ** LLM                      above tropz + 10 km 
> ! 2011.6.15 Jbak
> ! ===============================================================
> SUBROUTINE get_tbstd(std)
>   
>   USE OMSAO_precision_module 
>   USE ozprof_data_module,     ONLY: atmos_unit,trpz, which_aperr
>   USE OMSAO_variables_module, ONLY: atmdbdir, the_month, the_day, the_lat
>   IMPLICIT NONE
>   
>   
>   ! ======================
>   ! Input/Output variables
>   ! ======================
>   INTEGER, PARAMETER                             :: nref = 60
>   REAL (KIND=dp), DIMENSION(nref), INTENT(OUT)   :: std
>   
>   ! ======================
>   ! Local variables
>   ! ======================
>   INTEGER            :: i , which_offset
>   REAL (KIND=dp), DIMENSION(nref):: std1, std2,llm,refz,tmp
>   REAL (KIND=dp) :: meg, weight, trpz1, trpz2, del
>   trpz1 = 13
>   trpz2 = 15
>   del   = 10 
>   meg   =  5
>   del = meg + 5
>   
>   refz(1:nref) = (/(i*1.0, i= 59, 0,-1 )/)
>   
>   ! ** load clima profiles ** !
>   CALL get_mpstd(llm)
>   
>   IF (which_aperr == 4) then
>      call get_ab(tmp,std, 1)
>   ELSE IF (which_aperr == 3) then 
>      call get_tb (tmp, std1,1)  
>      call get_tb (tmp, std2,2) 
>      ! call get_ab (tmp,std2,2)   
>   ENDIF
>   
>   ! Vertical mixing.
>   DO i = 1, nref
>      weight = 1-(abs( refz(i) - trpz )-meg)/(del-meg)
>      if ( abs(refz(i) - trpz) > del ) then 
>         weight = 0
>      else if ( abs(refz(i) - trpz) <= meg ) then
>         weight = 1
>      endif
>      
>      IF ( refz(i) >= trpz ) then ! above the tropopause
>         IF ( which_aperr == 4 ) then 
>            std(i) = std(i)*weight +LLM(i)*(1-weight)
>         elseif ( which_aperr == 3 ) then 
>            std1(i) = std1(i)*weight +LLM(i)*(1-weight)
>            std2(i) = std2(i)*weight +LLM(i)*(1-weight)
>         ENDIF
>      endif
>      IF ( which_aperr == 3 .and. refz(i) < 5) then ! below the tropopause 
>         !      weight = ( 5.-refz(i))/5.
>         !      std1(i) = std1(i)*weight +LLM(i)*(1-weight)
>         !      std2(i) = std2(i)*weight +LLM(i)*(1-weight)
>      endif
>   ENDDO
>   
>   IF ( which_aperr == 3 ) then  
>      weight = (trpz2-trpz)/(trpz2-trpz1)
>      if (trpz <= trpz1) then  !100 % TB extratropical
>         weight = 1
>      else if (trpz > trpz2) then !100 % TB tropical 	 
>         weight = 0
>      endif
>      STD(:) = std1(:)*weight + std2(:)*(1-weight)      
>   ENDIF
>    
>   IF (any(std(:) < 0)) THEN
>      PRINT * , 'error at get_tbprof' ; STOP
>   ENDIF
>   
>   RETURN
280a362
> END SUBROUTINE get_tbstd
294d375
< 
301c382
< 
---
>   
312c393
< 
---
>   
323,329c404,415
< 
< ! ** load std profiles ** !
< IF (which_aperr == 5) print *,'Sao3 set to be IUP with toz',toz  
< 
< IF (first) THEN
<     apfname = TRIM(ADJUSTL(atmdbdir)) // 'iupclima/iupclima_o3du_sd.dat'
<     OPEN (UNIT = atmos_unit, file=  apfname, status = 'unknown')
---
>   
>   ! ** load std profiles ** !
>   IF (which_aperr == 5) print *,'Sao3 set to be IUP with toz',toz  
>   
>   IF (first) THEN
>      apfname = TRIM(ADJUSTL(atmdbdir)) // 'iupclima/iupclima_o3du_sd.dat'
>      OPEN (UNIT = atmos_unit, file=  apfname, status = 'unknown')
>      
>      ! read loop        
>      DO i = 1, 6 
>         READ (atmos_unit, '(A)')
>      ENDDO
331,334c417
<     ! read loop        
<     DO i = 1, 6 ; READ (atmos_unit, '(A)') ;ENDDO
< 
<     DO im = 1, nmon
---
>      DO im = 1, nmon
338c421
< 
---
>            
340,350c423,433
<            READ(atmos_unit, *) fdum, (temp2(iprof),iprof = 1, maxprof ) ! du  
<    
<             nprof = 1         
<             DO k = 1, maxprof             
<                    IF (temp1(k) /= 0.0 ) then                   
<                    stds(im,ib,nprof, il) = temp2(k) 
<                    tozindex(im, ib, nprof) = temp1(k)                       
<                    nprof = nprof + 1
<                    ENDIF
<             ENDDO
<                    nprofs (im,ib) = nprof-1      
---
>               READ(atmos_unit, *) fdum, (temp2(iprof),iprof = 1, maxprof ) ! du  
>               
>               nprof = 1         
>               DO k = 1, maxprof             
>                  IF (temp1(k) /= 0.0 ) then                   
>                     stds(im,ib,nprof, il) = temp2(k) 
>                     tozindex(im, ib, nprof) = temp1(k)                       
>                     nprof = nprof + 1
>                  ENDIF
>               ENDDO
>               nprofs (im,ib) = nprof-1      
353,360c436,443
<      ENDDO       
< 
<     CLOSE (atmos_unit)  
<    first = .FALSE.
< ENDIF 
< 
< ! ** interpolation for lat, mon** ! 
< 
---
>      ENDDO
>      
>      CLOSE (atmos_unit)  
>      first = .FALSE.
>   ENDIF
>   
>   ! ** interpolation for lat, mon** ! 
>   
362,370c445,453
<      IF (the_lat <= -75.0) THEN
<         nband = 1; latin(1) = 1; latfrac(1) = 1.0
<      ELSE IF (the_lat >= 75.0) THEN
<         nband = 1; latin(1) = nlat; latfrac(1) = 1.0
<      ELSE
<         nband = 2     ; frac = (the_lat + 75.0) / 30.0 + 1
<         latin(1) = INT(frac); latin(2) = latin(1) + 1
<         latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
<      ENDIF
---
>   IF (the_lat <= -75.0) THEN
>      nband = 1; latin(1) = 1; latfrac(1) = 1.0
>   ELSE IF (the_lat >= 75.0) THEN
>      nband = 1; latin(1) = nlat; latfrac(1) = 1.0
>   ELSE
>      nband = 2     ; frac = (the_lat + 75.0) / 30.0 + 1
>      latin(1) = INT(frac); latin(2) = latin(1) + 1
>      latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>   ENDIF
372,376c455,458
<      
<    season = 1  
<    IF (the_month > 5 .and. the_month < 12 ) season = 2 
<       
< 
---
>   
>   season = 1  
>   IF (the_month > 5 .and. the_month < 12 ) season = 2 
>   
378,407c460,462
<       iupstd =0.
< 
<      DO ib = 1, nband
< 
<            nprof = nprofs(season, latin(ib))
<            minoz = tozindex(season, latin(ib), 1)
<            maxoz = tozindex(season, latin(ib), nprof) 
< 
<                       
<            IF (toz < minoz) THEN
<               WRITE(*,*), 'Warning: no a priori profile available!!!'
<                iupstd  = iupstd + stds(season, latin(ib), 1, :)  * latfrac(ib)
<            ELSE IF (toz > maxoz) THEN
<               WRITE(*,*), 'Warning: no a priori profile available!!!'
<                iupstd = iupstd + stds(season, latin(ib), nprof, :)  * latfrac(ib)
<            ELSE
< 
<                profin = INT ((toz - minoz ) / 30.0)+1
< 
<               IF (profin == 0) THEN 
<                  profin = 1
<               ELSE IF (profin == nprof) THEN
<                  profin = profin -1
<               ENDIF
<               
<               frac = 1.0 - (toz - (minoz + (profin-1) * 30.0)) / 30.0
< 
<               iupstd = iupstd + latfrac(ib) * (frac * stds(season, latin(ib), profin, :) &
<                    + (1.0 - frac) * stds(season, latin(ib), profin+1, :))
<            ENDIF
---
>   iupstd =0.
>   
>   DO ib = 1, nband
409,410c464,491
<      ENDDO
<                
---
>      nprof = nprofs(season, latin(ib))
>      minoz = tozindex(season, latin(ib), 1)
>      maxoz = tozindex(season, latin(ib), nprof) 
>           
>      IF (toz < minoz) THEN
>         WRITE(*,*), 'Warning: no a priori profile available!!!'
>         iupstd  = iupstd + stds(season, latin(ib), 1, :)  * latfrac(ib)
>      ELSE IF (toz > maxoz) THEN
>         WRITE(*,*), 'Warning: no a priori profile available!!!'
>         iupstd = iupstd + stds(season, latin(ib), nprof, :)  * latfrac(ib)
>      ELSE
>         
>         profin = INT ((toz - minoz ) / 30.0)+1
>         
>         IF (profin == 0) THEN 
>            profin = 1
>         ELSE IF (profin == nprof) THEN
>            profin = profin -1
>         ENDIF
>         
>         frac = 1.0 - (toz - (minoz + (profin-1) * 30.0)) / 30.0
>         
>         iupstd = iupstd + latfrac(ib) * (frac * stds(season, latin(ib), profin, :) &
>              + (1.0 - frac) * stds(season, latin(ib), profin+1, :))
>      ENDIF
>      
>   ENDDO
>   
413c494
< 
---
>   
418c499
<       weight(i) = 1.0
---
>         weight(i) = 1.0
420c501
<       weight(i) = 0.0
---
>         weight(i) = 0.0
422,425c503,506
<       weight(i) = (meg+5-refz(i))/5.
<      ENDIF 
<       std(i) = iupstd(i)*weight(i) + llmstd(i)*(1-weight(i)) 
<       ! print * , refz(i), weight(i), std(i)
---
>         weight(i) = (meg+5-refz(i))/5.
>      ENDIF
>      std(i) = iupstd(i)*weight(i) + llmstd(i)*(1-weight(i)) 
>      ! print * , refz(i), weight(i), std(i)
427c508
< 
---
>   
430,432c511
< 
< 
< 
---
>    
464d542
< 
466c544
< ! ** load std profiles ** !
---
>   ! ** load std profiles ** !
468,480c546,558
<   print * , 'fk error'
<         apfname = TRIM(ADJUSTL(atmdbdir)) // 'fkclima/fortuin_o3_sdev.dat'
<         
<         OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
<         DO i = 1, nm 
<            READ(atmos_unit, '(A)')  ! read month label
<            READ(atmos_unit, *) ((stds(i, j, k), j=1, nlat), k=nlay, 1, -1) ! ppmv
<         ENDDO
<         CLOSE(atmos_unit)
<         first = .FALSE.
<  ENDIF
< 
< ! ** interpolation for lat, mon** ! 
---
>      print * , 'fk error'
>      apfname = TRIM(ADJUSTL(atmdbdir)) // 'fkclima/fortuin_o3_sdev.dat'
>      
>      OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
>      DO i = 1, nm 
>         READ(atmos_unit, '(A)')  ! read month label
>         READ(atmos_unit, *) ((stds(i, j, k), j=1, nlat), k=nlay, 1, -1) ! ppmv
>      ENDDO
>      CLOSE(atmos_unit)
>      first = .FALSE.
>   ENDIF
>   
>   ! ** interpolation for lat, mon** ! 
495,496c573,574
< 
< 
---
>   
>   
506c584
< 
---
>   
510c588
<            std0 =  std0 + stds(monin(j), latin(i), :) * monfrac(j) * latfrac(i)
---
>         std0 =  std0 + stds(monin(j), latin(i), :) * monfrac(j) * latfrac(i)
513,514c591
< 
< 
---
>   
524a602,853
> SUBROUTINE get_apriori_covar_old(month, day, lat, lon, ps, zs, ts, nz, ntp, ozprof, sao3)
>   
>   USE OMSAO_precision_module 
>   USE ozprof_data_module,     ONLY: use_logstate, which_clima, atmos_unit, &
>        min_serr, min_terr, loose_aperr, which_aperr
>   USE OMSAO_variables_module, ONLY: atmdbdir, the_year
>   IMPLICIT NONE
>   
>   ! ======================
>   ! Input/Output variables
>   ! ======================
>   INTEGER, INTENT(IN)                            :: month, day, nz, ntp
>   REAL (KIND=dp), INTENT(IN)                     :: lat, lon
>   REAL (KIND=dp), DIMENSION(0:nz),   INTENT(INOUT) :: zs, ps, ts
>   REAL (KIND=dp), DIMENSION(nz, nz), INTENT(OUT) :: sao3
>   REAL (KIND=dp), DIMENSION(nz),      INTENT(IN) :: ozprof
>   
>   ! ======================
>   ! Local variables
>   ! ======================
>   INTEGER, PARAMETER :: mlat=18, nm=12, mlay=62
>   ! 1. McPeters Clima 2. Fortuin Clima  3. McPeters + GEOS-CHEM  4. McPeters + ZM MLS
>   INTEGER            :: errstat
>   REAL (KIND=dp), PARAMETER       :: corrlen=6.0     ! changed from 6 km to 8 km (more uniform in a priori influence)
> 
>   REAL (KIND=dp), DIMENSION(mlay)       :: preslg
>   REAL (KIND=dp), SAVE, DIMENSION(mlay) :: pres
>   INTEGER, SAVE                         :: nlay, nlat, nmon
> 
>   CHARACTER (LEN=130)           :: apfname
>   CHARACTER (LEN=2)             :: monc
>   REAL (KIND=dp), SAVE, DIMENSION(nm, mlat, mlay) :: stds 
>   REAL (KIND=dp), DIMENSION(mlay)           :: astd, cumastd
>   REAL (KIND=dp), DIMENSION(nz)             :: zmid
>   REAL (KIND=dp), DIMENSION(0:nz)           :: pslg, nstd, nstd1, ps1, zs1
>   INTEGER                       :: i, j, k,  idum, nband, mnorstd, tmpntp
>   INTEGER, DIMENSION(2)         :: latin, monin
>   REAL (KIND=dp)                :: frac
>   REAL (KIND=dp), DIMENSION(2)  :: latfrac, monfrac
>   LOGICAL, SAVE                 :: first = .TRUE.
> 
>   ! ==============================
>   ! Name of this module/subroutine
>   ! ==============================
>   CHARACTER (LEN=17), PARAMETER :: modulename = 'get_apriori_covar'  
>  
>   !IF (whichap == 1 .OR. whichap == 2) THEN
>   !   IF (whichap == 1) THEN
>   !      apfname = TRIM(ADJUSTL(atmdbdir)) // 'v8clima/tomsv7_apcovar.dat'
>   !   ELSE 
>   !      WRITE(monc, '(I2.2)') month
>   !      apfname = TRIM(ADJUSTL(atmdbdir)) // 'hocovar/hoh99_mean_covar_' // monc // '.dat'
>   !   ENDIF 
>   !
>   !   IF (nz == 11) THEN   !use TOMS V7 apriori covariance 
>   !      OPEN (UNIT = atmos_unit, file=apfname, status = 'old')
>   !      IF (whichap == 2) READ(atmos_unit, '(A)')  
>   !      READ(atmos_unit, *) ((sao3(i, j), j=1, nz), i=1, nz)
>   !      CLOSE (atmos_unit) 
>   !      
>   !      DO i = 1,  nz
>   !         IF (sao3(i, i) <= 1.d0) sao3(i, i) = 1.0
>   !      ENDDO       
>   !      RETURN
>   !   ELSE
>   !      whichap = 3
>   !   ENDIF
>   !ENDIF
> 
>   IF (day <= 15) THEN
>      monin(1) = month - 1
>      IF (monin(1) == 0) monin(1) = 12
>      monin(2) = month
>      monfrac(1) = (15.0 - day) / 30.0
>      monfrac(2) = 1.0 - monfrac(1)
>   ELSE 
>      monin(2) = month + 1
>      IF (monin(2) == 13) monin(2) = 1
>      monin(1) = month
>      monfrac(2) = (day - 15) / 30.0
>      monfrac(1) = 1.0 - monfrac(2)
>   ENDIF
>   nmon = 2
> 
>   sao3 = 0.0; astd = 0.0
>   IF (which_aperr == 1 .OR. which_aperr == 3 .OR. which_aperr == 4) THEN     
>      IF (first) THEN
>         nlay = 62; nlat = 18
>         pres(2:62) = (/(1013.25*10.0**(-1.0*i/16.0), i = 60, 0, -1)/)
>         pres(1) = 0.05  ! about 70 km
>         apfname = TRIM(ADJUSTL(atmdbdir)) // 'mpclima/llmclima_std.dat'
>         OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
>         READ (atmos_unit, '(A)') ;  READ(atmos_unit, '(A)') 
>         DO i = 1, nm 
>            READ(atmos_unit, '(A)') ;  READ(atmos_unit, '(A)')  ! read month label
>            DO k = nlay, 2, -1
>               READ(atmos_unit, *) idum, (stds(i, j, k), j=1, nlat) ! ppmv
>            ENDDO
>         ENDDO
>         CLOSE(atmos_unit)
>         first = .FALSE.
>      ENDIF
> 
>      IF (lat <= -85.0) THEN
>         nband = 1; latin(1) = 1; latfrac(1) = 1.0
>      ELSE IF (lat >= 85.0) THEN
>         nband = 1; latin(1) = nlat; latfrac(1) = 1.0
>      ELSE
>         nband = 2     ; frac = (lat + 85.0) / 10.0 + 1
>         latin(1) = INT(frac); latin(2) = latin(1) + 1
>         latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>      ENDIF
> 
>      DO i = 1, nband
>         DO j = 1, nmon
>            astd(2:nlay) =  astd(2:nlay) + stds(monin(j), latin(i), 2:nlay) * monfrac(j) * latfrac(i)
>         ENDDO
>      ENDDO
>      astd(1) =  astd(2)
>   ELSE 
>      IF (first) THEN
>         nlay = 20; nlat = 17
>         apfname = TRIM(ADJUSTL(atmdbdir)) // 'fkclima/fortuin_o3_sdev.dat'
>         pres(1:nlay) = (/0.05, 0.3, 0.5, 1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 20., &
>              30., 50., 70., 100., 150., 200., 300., 500., 700., 1000.0/)
>         
>         OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
>         DO i = 1, nm 
>            READ(atmos_unit, '(A)')  ! read month label
>            READ(atmos_unit, *) ((stds(i, j, k), j=1, nlat), k=nlay, 2, -1) ! ppmv
>         ENDDO
>         CLOSE(atmos_unit)
>         first = .FALSE.
>      ENDIF
> 
>     IF (lat <= -80.0) THEN
>         nband = 1; latin(1) = 1; latfrac(1) = 1.0
>      ELSE IF (lat >= 80.0) THEN
>         nband = 1; latin(1) = nlat; latfrac(1) = 1.0
>      ELSE
>         nband = 2     ; frac = (lat + 80.0) / 10.0 + 1
>         latin(1) = INT(frac); latin(2) = latin(1) + 1
>         latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>      ENDIF
> 
>      DO i = 1, nband
>         DO j = 1, nmon
>            astd(2:nlay) =  astd(2:nlay) + stds(monin(j), latin(i), 2:nlay) * monfrac(j) * latfrac(i)
>         ENDDO
>      ENDDO
>      astd(1) =  astd(2)
>   ENDIF
> 
>   cumastd(1) = 0.0
>   ! convert from ppmv to partial column and accumulate
>   DO i = 2, nlay
>      cumastd(i) = cumastd(i-1) + (astd(i) + astd(i-1)) * &
>           0.5 * (pres(i)-pres(i-1)) / 1.267
>   ENDDO
>     
>   ! Interpolate to LIDORT grid
>   IF (ps(nz) > pres(nlay)) pres(nlay) = ps(nz)
>   preslg = LOG(pres); pslg = LOG(ps)
>   
>   CALL BSPLINE(preslg(1:nlay), cumastd(1:nlay), nlay, pslg(0:nz),&
>        nstd(0:nz), nz+1, errstat)
>   IF (errstat < 0) THEN
>      WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat; STOP
>   ENDIF
>     
>   ! Contruct the full covariance matrix for ozone (in Dobson units)
>   nstd(1:nz) = nstd(1:nz) - nstd(0:nz-1)
>   !print *, SUM(nstd(ntp+1:nz)) / SUM(ozprof(ntp+1:nz))
>   !nstd(1:nz) =  ozprof(1:nz) * 0.5
> 
>   IF (which_aperr == 3) THEN
>      ps1(0) = ps(nz)
>      DO i = 1, nz
>         ps1(i) = ps(nz-i); nstd1(i) = nstd(nz-i+1)
>      ENDDO
>      CALL GET_GEOSCHEM_O3STD(month, lon, lat, ps1, nstd1(1:nz), nz, nz-ntp)  
>      DO i = 1, nz
>         nstd(i) = nstd1(nz-i+1)
>      ENDDO
>   ELSE IF (which_aperr == 4) THEN
>      ps1(0) = ps(nz)
>      DO i = 1, nz
>         ps1(i) = ps(nz-i); nstd1(i) = nstd(nz-i+1)
>      ENDDO
>   
>      mnorstd = 2
>      CALL get_mlso3prof(the_year, month, day, lat, nz, mnorstd, ps1(0:nz), zs1(0:nz), nstd1(1:nz), tmpntp, errstat)
>      IF (errstat < 0) THEN
>         WRITE(*, *) modulename, ': Error in getting MLS ozone variabilities!!!'; STOP
>      ENDIF
>      DO i = 1, nz
>         nstd(i) = nstd1(nz-i+1)
>      ENDDO
>   ELSE IF (which_aperr == 5) THEN
>      ps1(0) = ps(nz)
>      DO i = 1, nz
>         ps1(i) = ps(nz-i); nstd1(i) = nstd(nz-i+1)
>      ENDDO
>   
>      mnorstd = 2
>      CALL get_mlso3prof_single(the_year, month, day, lat, nz, mnorstd, ps1(0:nz), zs1(0:nz), nstd1(1:nz), tmpntp, errstat)
>      IF (errstat < 0) THEN
>         WRITE(*, *) modulename, ': Error in getting MLS ozone variabilities!!!'; STOP
>      ENDIF
>      DO i = 1, nz
>         nstd(i) = nstd1(nz-i+1)
>      ENDDO
>   ENDIF
> 
>   ! Loose a priori constraint (because those from climatology are sometimes too small)
>   IF (loose_aperr) THEN
>      DO i = 1, ntp-1 
>         IF (nstd(i) / ozprof(i) < min_serr) THEN
>            nstd(i) = ozprof(i) * min_serr
>         ENDIF
>      ENDDO
>      
>      DO i = ntp, nz 
>         IF (nstd(i) / ozprof(i) < min_terr) THEN
>            nstd(i) = ozprof(i) * min_terr
>         ENDIF
>      ENDDO     
>   ENDIF
>  
>   IF (use_logstate) nstd(1:nz) = nstd(1:nz)/ozprof(1:nz)
> 
>   DO i = 1, nz
>      sao3(i, i)= nstd(i) ** 2.0 
>   ENDDO
> 
>   ! This is based on retrieval stastistics 
>   zmid = (zs(0:nz-1) + zs(1:nz)) / 2.0  
>   DO i = 1, nz
>      DO j = 1, i - 1
>         sao3(i, j) = SQRT(sao3(i,i) * sao3(j, j)) * &
>              EXP(- ABS((zmid(i)-zmid(j)) / corrlen)**2 )
>         sao3(j, i) = sao3(i, j) 
>      ENDDO
>   ENDDO
> 
>   !WRITE(77, *) 'Se  (ozone parameters only)'
>   !WRITE(77, '(11d12.4)') sao3
>     
>   RETURN
> END SUBROUTINE get_apriori_covar_old
> 
> 
534d862
< 
============================
get_cloud.f90
147c147,148
<   USE OMSAO_variables_module, ONLY: sol_identifier,atmdbdir
---
>   USE OMSAO_variables_module, ONLY: sol_identifier
>   USE OMSAO_variables_module, ONLY: atmdbdir
============================
get_initial_albedo.f90
18c18
<                                     the_aza_atm, reduce_resolution, use_redfixwav
---
>       the_aza_atm, reduce_resolution, use_redfixwav
51,53d50
< 
<      !    print * ,nrefl, rad_posr(1:nrefl)
< 
85d81
< 
87d82
<     ! wave_r ~ 346nm
98c93
<     
---
>  
104c99
<     
---
> 
108,109c103
<   ! noalb is TRUE' 
< 
---
>  
113,114c107,108
< ! WRITE(*, '(A, d12.4)') ' The initial albedo is: ', albedo
< 
---
>  !WRITE(*, '(A, d12.4)') ' The initial albedo is: ', albedo
>  
116c110
<     WRITE(*, *) modulename, ' : Surface albedo out of bounds!!!', albedo, measref
---
>     WRITE(*, *) modulename, ' : Surface albedo out of bounds!!!'
389c383
<        nctp, fzs, lambcld_initalb, taodfind, twaefind, scacld_initcod, the_ctp, simref
---
>        nctp, fzs, lambcld_initalb, taodfind, twaefind, scacld_initcod
405c399
<        ctpwf, taodwf, twaewf, saodwf, sprswf, so2zwf, walb0s
---
>        ctpwf, taodwf, twaewf, saodwf, sprswf, so2zwf, walb0s, wfc0s
425a420
> 
445d439
< 
447c441
<      ! Weighting function needs to be calculated     
---
>      ! Weighting function needs to be calculated
460,461c454
<      the_cfrac = cfrac;  wfcarr(1) = cfrac
<      
---
>      the_cfrac = cfrac;  wfcarr(1) = cfrac; wfc0s(1) = cfrac
465c458,459
<           albpmax, vary_sfcalb, walb0s, nwfc, wfcarr, wfcpmin, wfcpmax, nostk, albwf, ozwf, tmpwf, o3shiwf, cfracwf, &
---
>           albpmax, vary_sfcalb, walb0s, nwfc, wfcarr, wfcpmin, wfcpmax, wfc0s,              &
>           nostk, albwf, ozwf, tmpwf, o3shiwf, cfracwf, &
467d460
<       
477c470
<      simref  = simrad(1)
---
>      
511,513c504,505
<      
<      IF (scnwrt) WRITE(*, '(A20,4d14.5)') ' Rs, Rc, Fc, Tc: ', albedo, lambcld_refl, cfrac, ctau
<   
---
> 
>      IF (scnwrt) WRITE(*, '(A20,4d14.5)') '  Rs, Rc, Fc, Tc: ', albedo, lambcld_refl, cfrac, ctau
525d516
<            print * , 'albedo > 1.0 in adjust_albedo'
531,534c522,523
<     
<      !print * ,'adjust albedo', (measref-simrad(1))/simrad(1)*100., the_ctp
<      ! print * , 
<      IF ( ABS(delta_cfrac) <= 0.001 .AND. ABS(delta_alb) <= 0.001 .AND. ABS(delta_cod) <= 0.001 ) EXIT
---
>      IF ( ABS(delta_cfrac) <= 0.001 .AND. ABS(delta_alb) <= 0.001 .AND. &
>           ABS(delta_cod) <= 0.001 ) EXIT
684c673
<  
---
> 
713c702,705
<      
---
> 
>      !print *, measref, simrad
>      !print *, albwf, cfracwf
> 
728c720
<     
---
> 
741c733
<      ENDIF   
---
>      ENDIF
745c737
<      
---
> 
992c984
<   INTEGER (KIND=8), PARAMETER     :: nlat = 360, nlon = 720
---
>   INTEGER (KIND=4), PARAMETER     :: nlat = 360, nlon = 720
1010,1012c1002,1004
<   INTEGER (KIND=8)               :: start = 0, stride = 1
<   INTEGER (KIND=8), DIMENSION(4) :: start_alb = 0, stride_alb = 1
<   INTEGER (KIND=8), DIMENSION(4) :: edge_alb = (/nlon, nlat, nwvl, nmon/)
---
>   INTEGER (KIND=4)               :: start = 0, stride = 1
>   INTEGER (KIND=4), DIMENSION(4) :: start_alb = 0, stride_alb = 1
>   INTEGER (KIND=4), DIMENSION(4) :: edge_alb = (/nlon, nlat, nwvl, nmon/)
1017,1022c1009
<   !alb_fname = TRIM(ADJUSTL(atmdbdir)) // 'KNMI_OMIALB/OMI-Aura_L3-OMLER_2005m01-2009m12_v003-2010m0503t063707.he5'
<  !  328.0000       335.0000       342.0000       345.0000       354.0000    
<  !  367.0000       372.0000       376.0000       380.0000       388.0000    
<  !  406.0000       416.0000       418.0000       425.0000       440.0000    
<  !  442.0000       452.0000       463.0000       471.0000       477.0000    
<  !  488.0000       494.0000       499.0000
---
> 
1057c1044
<     
---
>      
1070c1057
<           
---
>      
1102c1089
<      lonin = MOD(lonin, nlon)
---
>      IF (lonin > nlon) lonin = MOD(lonin, nlon)
============================
get_initial_albedo_32bit.f90
============================
get_raman.f90
1c1
< SUBROUTINE GET_RAMAN(nl, ozprof, errstat)
---
> 3SUBROUTINE GET_RAMAN(nl, ozprof, errstat)
7c7
<        up_radbnd, nsol_ring, n_refwvl_sav, do_bandavg, fitvar_rad,curr_rad_spec,n_rad_wvl,  &
---
>        up_radbnd, nsol_ring, n_refwvl_sav, do_bandavg, fitvar_rad,          &
13d12
<   USE ring_data_module,    ONLY :maxnu, nuhi, nulo, nu,avgt, cosvza, cossza, ring  , st, vt
22c21
< !  INTEGER, PARAMETER :: maxnu = 15000
---
>   INTEGER, PARAMETER :: maxnu = 15000
31,32c30,31
<  ! REAL (KIND=dp), DIMENSION(maxnu, nflay)     :: st, vt
< !  REAL (KIND=dp), DIMENSION(maxnu)            :: ring
---
>   REAL (KIND=dp), DIMENSION(maxnu, nflay)     :: st, vt
>   REAL (KIND=dp), DIMENSION(maxnu)            :: ring
36,37c35,36
<  ! INTEGER,                                        SAVE :: nuhi, nulo, nu
<  ! REAL (KIND=dp),                                 SAVE :: avgt, cosvza, cossza
---
>   INTEGER,                                        SAVE :: nuhi, nulo, nu
>   REAL (KIND=dp),                                 SAVE :: avgt, cosvza, cossza
50,51c49
<   IF (ozabs_convl) THEN   ! Check this for each cross track position !ozabs_convl = .TRUE.; so2crs_convl = .TRUE.
< 
---
>   IF (ozabs_convl) THEN   ! Check this for each cross track position
54c52,53
<      swavs(1:nsol_ring) = sol_spec_ring(1, 1:nsol_ring) ! 264-334
---
>      swavs(1:nsol_ring) = sol_spec_ring(1, 1:nsol_ring)
> 
59,62d57
<       
<      nuhi = INT(1.0D7 / swavs(1)) ! maximum of frequency, 37745
<      nulo = INT(1.0D7 / swavs(nsol_ring)) + 1 ! minimum of frequency, 29977
<      nu = 0
63a59,61
>      nuhi = INT(1.0D7 / swavs(1))
>      nulo = INT(1.0D7 / swavs(nsol_ring)) + 1
>      nu = 0
66c64
<         ramanwav(nu) = 1.0D7 / REAL(i, KIND=dp) ! very high resolution
---
>         ramanwav(nu) = 1.0D7 / REAL(i, KIND=dp)
69c67
< 
---
>      
81c79
<    
---
>      
84c82
<  
---
> 
95d92
<     
99c96
<     
---
> 
101c98
<         print *, swavs(1), swavs(nsol_ring)
---
>         PRINT *, swavs(1), swavs(nsol_ring)
145,146c142
<     
<      
---
>   
149a146
>      
157d153
<        
159a156
>      
172d168
<           
176c172
< 
---
>  
179d174
<       
183d177
< 
186,189c180,182
< 
< 
<   CALL RAMAN2 (nulo, nuhi, nu, nflay)  !(refdbdir, nulo, nuhi, nu, nflay, avgt, the_sca_atm, cossza, &
<              ! st(1:nu,:), vt(1:nu,:), frhos(1:nflay), ring(1:nu))
---
>   ! Call raman program
>   CALL RAMAN(refdbdir, nulo, nuhi, nu, nflay, avgt, the_sca_atm, cossza, &
>        st(1:nu,:), vt(1:nu,:), frhos(1:nflay), ring(1:nu))
198d190
<   
202a195,200
>   !WRITE(90, *) 'After Coadding'
>   !DO i = 1, n_refwvl_sav
>   !   WRITE(90, '(f8.4, D14.5)') refwvl_sav(i), newring(i)
>   !ENDDO
>   !STOP
>   
214d211
<  
216,217c213
< 
< 
---
>   
219,221d214
<   IF (num_iter == 0) THEN 
<       OPEN (92, file='./ring.dat', status='unknown')
<   ENDIF
225a219
>      !stop
232a227,441
> 
> !  Get Ring from KaiYang's LUT
> SUBROUTINE GET_RAMAN_LUT (nl, ozprof, errstat)    
> 
>   USE OMSAO_precision_module
>   USE OMSAO_parameters_module, ONLY : maxchlen, deg2rad,max_ring_pts
>   !USE OMSAO_indices_module,    ONLY: 
>   USE OMSAO_variables_module,  ONLY: the_sza_atm, the_vza_atm, the_aza_atm, refdbdir, &
>        sol_spec_ring, nsol_ring, database, n_refwvl, refwvl, fitvar_rad, the_lats, &
>        n_refwvl_sav, refwvl_sav, do_bandavg, yn_varyslit, which_slit, fitvar_sol, &
>        mask_fitvar_sol, fixslitcal, n_rad_wvl, refidx,  fitvar_rad_init, fitvar_rad_str, &
>        refnhextra, nradpix, numwin
>   USE OMSAO_slitfunction_module
>   USE ozprof_data_module,      ONLY: ps0,eff_alb, the_ctp, the_cfrac, num_iter, &
>        lambcld_refl, eff_alb_init,  fozs, nflay, wrtring, albidx, nalb, which_cld
>   USE OMSAO_indices_module,    ONLY : vgl_idx, vgr_idx, hwr_idx, hwl_idx, &
>        hwe_idx, asy_idx, solar_idx, ring_idx
>   USE OMSAO_errstat_module
> 
>   USE LRRS_iitrsb_TAB_m, ONLY: LRRS_iitrsTAB_Init, LRRS_Read_flux
>   USE rrs_lut_m,         ONLY: LocalTab_SetCommon, ItoaOzJ1
>   USE cloud_data_module, ONLY: the_solwin
>   !USE UTIL_tools_class, ONLY : hunt, wl2index, remove_dups, lat2zone
> 
>   IMPLICIT NONE
> 
>   ! Input/Output variables
>   INTEGER, INTENT(IN)                       :: nl
>   INTEGER, INTENT(OUT)                      :: errstat
>   REAL (KIND=dp), DIMENSION(nl), INTENT(IN) :: ozprof
> 
>   ! Local Variables
>   LOGICAL                                   :: lfail
>   INTEGER, PARAMETER                        :: maxnfr = 11001
>   INTEGER                                   :: i, iwin, j, n0alb, albord, npts
>   INTEGER                                   :: nwlLRRS, ntemp, nextra, fidx, lidx
>   INTEGER, DIMENSION(numwin)                :: ralbmin, ralbmax
>   REAL(kind=dp)                             :: totoz, wavavg, clref, pt, pc
>   REAL(KIND=dp), PARAMETER                  :: ATM1 = 1013.25d0
>   REAL(kind=dp), DIMENSION(2)               :: wavlim
>   REAL(KIND=dp), DIMENSION(1)               :: polyC
>   INTEGER                                   :: nPolyC
>   REAL (KIND=dp), DIMENSION(max_ring_pts)   :: swavs
>   !REAL(KIND=8), DIMENSION(2, maxnfr)        :: flux
>   !REAL(KIND=8), DIMENSION(maxnfr)           :: wlg, REratio, ItoaELA, ItoaRRS
>   REAL(KIND=dp), DIMENSION(:, :), ALLOCATABLE :: flux
>   REAL(KIND=dp), DIMENSION(:), ALLOCATABLE    :: wlg
>   REAL (KIND=dp), DIMENSION(n_refwvl_sav)     :: REratio, ItoaELA, ItoaRRS
>   CHARACTER(LEN=maxchlen)                     :: LUTdir
>   CHARACTER(len=maxchlen)                     :: msg
>   REAL (KIND=dp), DIMENSION(n_refwvl_sav)     :: newring, lambdas, grref
>   LOGICAL,                              SAVE  :: first=.TRUE.
>   ! ==============================
>   ! Name of this module/subroutine
>   ! ==============================
>   CHARACTER (LEN=9), PARAMETER :: modulename = 'GET_RAMAN_LUT'
> 
> 
> 
>   ! Initial error stat
>   errstat = pge_errstat_ok
> 
> 
>   ! Get position for raman calculation
>   swavs(1:nsol_ring) = sol_spec_ring(1, 1:nsol_ring)
> 
>   ! Get total ozone
>   IF (num_iter == 0) THEN
>      totoz = SUM(fozs(1:nflay))
>   ELSE
>      totoz = SUM( ozprof(1:nl))
>   ENDIF
> 
>   ! Initial RRS LUT 
> 
>   IF (first .AND. which_cld /= 5) THEN
> 
>      ! ALLOCATABLE some lager arrays 
>      ALLOCATE(flux(2,maxnfr ), wlg(maxnfr))
> 
>      ! Initializing some parameters
>      ! Note that the wavelength stages is 265-375 nm
>      LUTdir = TRIM(ADJUSTL(refdbdir)) // '/LRRSzTABs/'
>      wavlim(1) = swavs(1); wavlim(2) =  swavs(nsol_ring)
>      IF ( wavlim(1) <= 265.05) wavlim(1) = 265.05
>      IF ( wavlim(2) >= 374.95) wavlim(2) = 374.95
>      !wavlim(1) = refwvl_sav(1) - 2.5;  wavlim(2) = refwvl_sav(n_refwvl_sav) + 2.7
>      CALL LRRS_iitrsTAB_Init( LUTdir, wavlim, lfail, msg )
>      IF (lfail) THEN
>         WRITE(*, *) modulename//':'//TRIM(msg)
>         errstat = pge_errstat_error; RETURN
>      ENDIF
> 
>      ! Get solar flux from RRS LUT
>      CALL LRRS_Read_flux( nwlLRRS, flux, wavlim )
>      IF( nwlLRRS > maxnfr ) THEN
>         WRITE(*, *) modulename, ': Increas max_fine_wlmaxnfr to cover nwlLRRS'
>         errstat = pge_errstat_error; RETURN
>      ENDIF
> 
>      wlg(1:nwlLRRS) = flux(1, 1:nwlLRRS)
> 
>      CALL LocalTab_SetCommon(wlg(1:nwlLRRS),flux(2, 1:nwlLRRS), nwlLRRS, LFAIL, msg )
>      DEALLOCATE(flux, wlg)
> 
>      first = .FALSE.
> 
>   ENDIF
> 
>   ! Preapre surface reflectivity, cloud fraction
>   ! Use initial value here, add fitvars later for each window
>   grref(1:n_refwvl_sav) = -999.0
>   IF (num_iter == 0) THEN
>      grref(1:n_refwvl_sav) = fitvar_rad_init(albidx)
>   ELSE
>      nextra     = refnhextra * 2
>      fidx = 1
>      DO i = 1, numwin
>         lidx = fidx + nradpix(i) + nextra - 1     
>         ralbmin(i) = fidx; ralbmax(i) = lidx
>         fidx = lidx + 1
>      ENDDO
> 
>      n0alb = 0
>      DO i = 1, nalb
>         j = albidx - 1 + i
>         READ(fitvar_rad_str(j)(4:4), '(I1)') albord
>         IF (albord == 0) THEN
>            n0alb = n0alb + 1
>            grref(ralbmin(n0alb):ralbmax(n0alb)) =  fitvar_rad(j)
>         ELSE  
>            READ(fitvar_rad_str(j)(1:1), '(I1)') iwin     
>            fidx=ralbmin(iwin); lidx=ralbmax(iwin)    
>            wavavg = SUM(refwvl_sav(fidx:lidx)/(1.0+lidx-fidx))
>            grref(fidx:lidx) = grref(fidx:lidx) + fitvar_rad(j) * (refwvl_sav(fidx:lidx) - wavavg)**albord   
>         ENDIF
>      ENDDO
>   ENDIF
> 
>   ! Go through groud ler to check all wavelenghs have been set
>   IF (ANY(grref(1:n_refwvl_sav) < -1.d0)) THEN
>      WRITE(*, *) 'GET_RAMAN_LUT: Albedo is not specified for all wavelengths!!!'
>      errstat = pge_errstat_error; RETURN
>   ENDIF
>   IF (ANY(grref(1:n_refwvl_sav) < 0.d0)) THEN
>     where(grref(1:n_refwvl_sav) < 0.d0) grref(1:n_refwvl_sav)= 0.001d0
>   ENDIF
> 
> 
>   clref = lambcld_refl
>   wavavg = refwvl_sav(1) ! dummy 
>   pt = ps0
>   pc = the_ctp
>   IF( pt < pc ) pc = pt
>   IF( pc < 0.1d0*ATM1 ) pc = 0.1d0*ATM1  
>   pc = pc/ATM1; pt = pt/ATM1
>   if (pt > 1.0) pt = 1.0d0
>   if (pt < 0.1) pt = 0.1d0
>   if (pc > 1.0) pc = 1.0d0
>   if (pc < 0.1) pc = 0.1d0
> 
> 
>   nPolyC  = 1  ! dummy 
>   polyC(1:nPolyC) = 0.d0  ! dummy 
>   !print*,grref, clref, pt,  pc,  ps0, the_ctp, totoz, the_lats(5),the_cfrac,  nwlLRRS;pause
>  
>   ! Calling this routine to read RRS LUT and interpolate to specific set of ozone, pressure, angles,
>   ! Getting elastic and rrs TOA radiance and their derivatives w.r.t column ozone and surface ref.
>   fidx = 1
>   nextra   = refnhextra * 2
>   DO i = 1, numwin
>      the_solwin = i
>      lidx = fidx + nradpix(i) + nextra - 1 
>      npts = lidx - fidx + 1
>      CALL ItoaOzJ1( refwvl_sav(fidx:lidx),npts , the_sza_atm, the_vza_atm,       &
>           the_aza_atm, pt, pc, totoz, the_lats(5), wavavg, the_cfrac, &
>           grref(fidx:lidx), clref,  polyC, nPolyC, ItoaELA(fidx:lidx), ItoaRRS(fidx:lidx),   &
>           LFAIL, msg, REratio(fidx:lidx) )   
>      IF (LFAIL) THEN
>         WRITE(*, *) modulename//':'//TRIM(msg)
>         errstat = pge_errstat_error; RETURN
>      ENDIF
> 
>      fidx = lidx + 1  
>   ENDDO
> 
>   newring(1:n_refwvl_sav) = LOG(REratio(1:n_refwvl_sav))
> 
>   IF (do_bandavg) THEN
>      CALL avg_band_refspec(refwvl_sav(1:n_refwvl_sav), newring(1:n_refwvl_sav), &
>           n_refwvl_sav, ntemp, errstat)
>      IF ( errstat /= 0 .OR. ntemp /= n_refwvl) THEN
>         WRITE(*, *) modulename, ': Ring Spectra Averaging Error ', n_refwvl_sav, ntemp
>         errstat = pge_errstat_error; RETURN
>      ENDIF
>   ENDIF
> 
>   ! put the Ring spectrum into database
>   database(ring_idx,  1:n_refwvl)  = newring(1:n_refwvl)
> 
>   IF (wrtring) THEN
>      WRITE(92, *) n_rad_wvl
>      DO i = 1, n_rad_wvl
>         WRITE(92, '(f8.4, D14.5)') refwvl(refidx(i)), newring(refidx(i))
>      ENDDO
>      !stop
>   ENDIF
> 
>   RETURN
> 
> END SUBROUTINE GET_RAMAN_LUT
> 
> 
> 
> 
============================
get_reg_matrix.f90
============================
gsvd_data_module.f90
============================
gsvd_lcurve_gcv.f90
============================
gsvd_o3prof_utilities.f
4251,4254c4251
<           if(its.eq.30) then 
<           print * , 'no convergence in svdcmp'; return
<           !pause 'no convergence in svdcmp'
<           ENDIF
---
> c          if(its.eq.30) pause 'no convergence in svdcmp'
============================
lidort_prof_env.f90
14,15c14,15
<      nw, waves, nos, o3shi, sza, vza, aza, nl, ozprof, tprof, n0alb, albarr, &
<      albpmin, albpmax, vary_sfcalb, walb0s, n0wfc, wfcarr, wfcpmin, wfcpmax, nostk, albwf, ozwf,  &
---
>      nw, waves, nos, o3shi, sza, vza, aza, nl, ozprof, tprof, n0alb, albarr, albpmin, albpmax, &
>      vary_sfcalb, walb0s, n0wfc, wfcarr, wfcpmin, wfcpmax, wfc0s, nostk,  albwf, ozwf,          &
25c25
<        n_refspec_pts, winlim, n_rad_wvl, which_slit
---
>        n_refspec_pts, winlim, n_rad_wvl
40c40
<   
---
> 
42c42
<   
---
> 
46c46
<   
---
> 
56c56
<   
---
> 
58c58
<   
---
> 
69c69
<   REAL (KIND=dp), DIMENSION(nw),  INTENT(IN)   :: waves, walb0s
---
>   REAL (KIND=dp), DIMENSION(nw),  INTENT(IN)   :: waves, walb0s, wfc0s
78c78
<   
---
> 
111,112c111,112
<   
< !  Exception handling for VLIDORT Model Calculation. New code, 13 October 2010
---
> 
>   !  Exception handling for VLIDORT Model Calculation. New code, 13 October 2010
119,120c119,120
<   REAL (KIND=dp), DIMENSION(0:mflay),                       SAVE :: ts
<   !REAL (KIND=dp), DIMENSION(max_fit_pts, mflay),            SAVE :: aersca, aerext, aerasy 
---
>   REAL (KIND=dp), DIMENSION(0:mflay),                   SAVE :: ts
>   !REAL (KIND=dp), DIMENSION(max_fit_pts, mflay),       SAVE :: aersca, aerext, aerasy 
122,128c122,128
<   REAL (KIND=dp), DIMENSION(3, max_fit_pts),                SAVE :: abscrs_qtdepen
<   REAL (KIND=dp), DIMENSION(max_fit_pts, mflay),            SAVE :: abscrs, dads, dadt
<   LOGICAL, DIMENSION(mflay),                                SAVE :: aermsk
<   LOGICAL, DIMENSION(max_fit_pts),                          SAVE :: do_radcals, do_polcorrs
<   INTEGER, DIMENSION(max_fit_pts),                          SAVE :: polcorr_idxs, radcal_idxs
<   REAL (KIND=dp), DIMENSION(max_fit_pts, mflay),            SAVE :: so2crs
<   INTEGER,                                                  SAVE :: so2idx, so2vidx, o4idx, so2crsidx
---
>   REAL (KIND=dp), DIMENSION(3, max_fit_pts),            SAVE :: abscrs_qtdepen
>   REAL (KIND=dp), DIMENSION(max_fit_pts, mflay),        SAVE :: abscrs, dads, dadt
>   LOGICAL, DIMENSION(mflay),                            SAVE :: aermsk
>   LOGICAL, DIMENSION(max_fit_pts),                      SAVE :: do_radcals, do_polcorrs
>   INTEGER, DIMENSION(max_fit_pts),                      SAVE :: polcorr_idxs, radcal_idxs
>   REAL (KIND=dp), DIMENSION(max_fit_pts, mflay),        SAVE :: so2crs, o4crs
>   INTEGER,                                              SAVE :: so2idx, so2vidx, o4idx, so2crsidx, o4crsidx
132c132,133
<   LOGICAL :: use_so2dtcrs  = .true.  ! Use SO2 cross section at different temperatures
---
>   LOGICAL :: use_so2dtcrs  = .TRUE.  ! Use SO2 cross section at different temperatures
>   LOGICAL :: use_o4dtcrs   = .TRUE.  ! Use O4 cross section at different temperatures
153c154
<            status_inputread, nreadmessages, readmessages, readactions )
---
>           status_inputread, nreadmessages, readmessages, readactions )
167c168
<                
---
> 
174c175
<      
---
> 
186a188
>      IF (fgasidxs(o4idx) <= 0) use_o4dtcrs = .FALSE.
189a192
>      IF (fgassidxs(o4idx) > 0  .AND. use_o4dtcrs) use_o4dtcrs = .FALSE.
193c196
<  
---
> 
195c198
<    IF (num_iter == 0 ) THEN
---
>   IF (num_iter == 0 ) THEN
201c204
<      
---
> 
204c207
<      
---
> 
224,225c227
<         WRITE(*, *) modulename, ' : # of layers exceeded allowed !!!',nz, maxlayers
< 
---
>         WRITE(*, *) modulename, ' : # of layers exceeded allowed !!!'
232c234
<        
---
> 
240c242
<     
---
> 
247c249
<          
---
> 
256d257
< 
258c259
<      DO i = 1, nl 
---
>      DO i = 1, nl
265c266
<         
---
> 
269c270
<         
---
> 
277,294c278,280
<  ELSE
<     ozs(1:nz) = ozprof(1:nl);    varyprof(1:nz) = ozvary(1:nl)
<  ENDIF
<  
<  nz1 = nfsfc - 1 
<  ! Update aerosol fields: first AOD
<  IF (do_taodwf .AND. num_iter > 0) THEN
<     aodscl = fitvar_rad(taodind) / tropaod(actawin)
<     tropaod(1:actawin) = tropaod(1:actawin) * aodscl
<     gaext(1:actawin, nup2p(ntp)+1:nz1) = gaext(1:actawin, nup2p(ntp)+1:nz1) * aodscl
<     
<     IF (.NOT. do_twaewf) THEN ! Single scattering albedo does not change
<        tropsca(1:actawin) = tropsca(1:actawin) * aodscl
<        gasca(1:actawin, nup2p(ntp)+1:nz1) = gasca(1:actawin, nup2p(ntp)+1:nz1) * aodscl
<     ENDIF
<  ELSE
<     aodscl = 1.0
<  ENDIF
---
>   ELSE
>      ozs(1:nz) = ozprof(1:nl);    varyprof(1:nz) = ozvary(1:nl)
>   ENDIF
296,301c282,287
<  IF (do_twaewf .AND. num_iter > 0) THEN
<     waerscl = fitvar_rad(twaeind) / tropwaer(actawin)   ! Scale single scattering albedo
<     tropwaer(1:actawin) = tropwaer(1:actawin) * waerscl
<     tropsca(1:actawin)  = tropsca(1:actawin) * waerscl * aodscl
<     gasca(1:actawin, nup2p(ntp)+1:nz1) = gasca(1:actawin, nup2p(ntp)+1:nz1) * waerscl * aodscl
<  ENDIF
---
>   nz1 = nfsfc - 1 
>   ! Update aerosol fields: first AOD
>   IF (do_taodwf .AND. num_iter > 0) THEN
>      aodscl = fitvar_rad(taodind) / tropaod(actawin)
>      tropaod(1:actawin) = tropaod(1:actawin) * aodscl
>      gaext(1:actawin, nup2p(ntp)+1:nz1) = gaext(1:actawin, nup2p(ntp)+1:nz1) * aodscl
303,309c289,337
<  IF (do_saodwf .AND. num_iter > 0) THEN
<     aodscl = fitvar_rad(saodind) / strataod(actawin)
<     strataod(1:actawin) = strataod(1:actawin) * aodscl
<     stratsca(1:actawin) = stratsca(1:actawin) * aodscl
<     gaext(1:actawin, 1:nup2p(ntp)) = gaext(1:actawin, 1:nup2p(ntp)) * aodscl
<     gasca(1:actawin, 1:nup2p(ntp)) = gasca(1:actawin, 1:nup2p(ntp)) * aodscl
<  ENDIF
---
>      IF (.NOT. do_twaewf) THEN ! Single scattering albedo does not change
>         tropsca(1:actawin) = tropsca(1:actawin) * aodscl
>         gasca(1:actawin, nup2p(ntp)+1:nz1) = gasca(1:actawin, nup2p(ntp)+1:nz1) * aodscl
>      ENDIF
>   ELSE
>      aodscl = 1.0
>   ENDIF
> 
>   IF (do_twaewf .AND. num_iter > 0) THEN
>      waerscl = fitvar_rad(twaeind) / tropwaer(actawin)   ! Scale single scattering albedo
>      tropwaer(1:actawin) = tropwaer(1:actawin) * waerscl
>      tropsca(1:actawin)  = tropsca(1:actawin) * waerscl * aodscl
>      gasca(1:actawin, nup2p(ntp)+1:nz1) = gasca(1:actawin, nup2p(ntp)+1:nz1) * waerscl * aodscl
>   ENDIF
> 
>   IF (do_saodwf .AND. num_iter > 0) THEN
>      aodscl = fitvar_rad(saodind) / strataod(actawin)
>      strataod(1:actawin) = strataod(1:actawin) * aodscl
>      stratsca(1:actawin) = stratsca(1:actawin) * aodscl
>      gaext(1:actawin, 1:nup2p(ntp)) = gaext(1:actawin, 1:nup2p(ntp)) * aodscl
>      gasca(1:actawin, 1:nup2p(ntp)) = gasca(1:actawin, 1:nup2p(ntp)) * aodscl
>   ENDIF
> 
>   IF (do_sprswf .AND. num_iter > 0) THEN
>      temp = (fitvar_rad(sprsind) - fps(nup2p(nsfc-1)))/ (fps(nz1) - fps(nup2p(nsfc-1)))
>      frhos(nup2p(nsfc-1)+1:nz1) = frhos(nup2p(nsfc-1)+1:nz1) * temp
>      delps(nup2p(nsfc-1)+1:nz1) = (fps(nup2p(nsfc-1)+1:nz1)-fps(nup2p(nsfc-1):nz1-1))  * temp
>      DO i = nup2p(nsfc-1)+1, nz1
>         fps(i) = fps(i-1) + delps(i)
>      ENDDO
>   ENDIF
> 
>   ! albedo array
>   IF (.NOT. vary_sfcalb) THEN
>      DO i = 1, n0alb
>         albs(albpmin(i):albpmax(i)) = albarr(i)
>      ENDDO
>   ELSE
>      albs(1:nw) = walb0s(1:nw)
>   ENDIF
> 
>   ! Cloud fraction array
>   IF (.NOT. vary_sfcalb) THEN
>      DO i = 1, n0wfc
>         wfcs(wfcpmin(i):wfcpmax(i)) = wfcarr(i)
>      ENDDO
>   ELSE
>      wfcs(1:nw) = wfc0s(1:nw)
>   ENDIF
311,331d338
<  IF (do_sprswf .AND. num_iter > 0) THEN
<     temp = (fitvar_rad(sprsind) - fps(nup2p(nsfc-1)))/ (fps(nz1) - fps(nup2p(nsfc-1)))
<     frhos(nup2p(nsfc-1)+1:nz1) = frhos(nup2p(nsfc-1)+1:nz1) * temp
<     delps(nup2p(nsfc-1)+1:nz1) = (fps(nup2p(nsfc-1)+1:nz1)-fps(nup2p(nsfc-1):nz1-1))  * temp
<     DO i = nup2p(nsfc-1)+1, nz1
<        fps(i) = fps(i-1) + delps(i)
<     ENDDO
<  ENDIF
<   
<  ! albedo array
<  IF (.NOT. vary_sfcalb) THEN
<     DO i = 1, n0alb
<        albs(albpmin(i):albpmax(i)) = albarr(i)
<     ENDDO
<  ELSE
<     albs(1:nw) = walb0s(1:nw)
<  ENDIF
<             
<  DO i = 1, n0wfc
<     wfcs(wfcpmin(i):wfcpmax(i)) = wfcarr(i)
<  ENDDO
342c349
<   
---
> 
411,416d417
<       
< !  print *, n_totalatmos_wfs, nz
< !  print *, layer_vary_flag(1:nz)
< !  print *, layer_vary_number(1:nz)
<   
<   ! ==================== Get Ozone Absorption Cross Section ====================  
417a419,423
>   !print *, n_totalatmos_wfs, nz
>   !print *, layer_vary_flag(1:nz)
>   !print *, layer_vary_number(1:nz)
> 
>   ! ==================== Get Ozone Absorption Cross Section ====================   
419d424
<    
422c427
<      
---
> 
426,427c431,435
<            IF (use_so2dtcrs) so2crsidx = nfgas
<            
---
>            !IF (use_so2dtcrs) so2crsidx = nfgas
>            !IF (use_o4dtcrs) o4crsidx = nfgas
>            IF (use_so2dtcrs .AND. (gasidxs(k) == so2_idx .OR. gasidxs(k) == so2v_idx)) so2crsidx = nfgas
>            IF (use_o4dtcrs .AND. gasidxs(k) == o2o2_idx) o4crsidx = nfgas
> 
431,432d438
<            !print * , allcol(nfgas,1:nz1)
< 
436c442
<      IF (use_effcrs) THEN !F
---
>      IF (use_effcrs) THEN
446c452
<                  
---
> 
460c466
<               
---
> 
463c469
<               
---
> 
469c475
<         
---
> 
473d478
<   
481c486
<     
---
> 
484d488
< 
488c492
<            
---
> 
493c497
<         ENDIF      
---
>         ENDIF
502c506
<         
---
> 
510c514,522
<         
---
> 
>         IF ( num_iter == 0 .AND. fgasidxs(o4idx) > 0 .AND. use_o4dtcrs) THEN
>            CALL GETO4_CRS(radwvl_sav, n_radwvl_sav, nw, nz1, ts(1:nz1), o4crs(1:nw, 1:nz1), problems)
>            IF (problems) THEN
>               WRITE(*, *) modulename, ' : Problems in reading O4 absorption !!!'
>               errstat = pge_errstat_error; RETURN
>            ENDIF
>         ENDIF
> 
515,516c527,529
<                             
<               IF ((k /= so2idx .AND. k /= so2vidx) .OR. .NOT. use_so2dtcrs) THEN
---
> 
>               IF (((k /= so2idx .AND. k /= so2vidx) .OR. .NOT. use_so2dtcrs) .and. &
>                    (k /= o4idx .OR. .NOT. use_o4dtcrs) ) THEN
525c538
<                     
---
> 
530c543
<                        
---
> 
533c546
<                        
---
> 
543c556
<                  
---
> 
552c565
<         
---
> 
557c570
<               
---
> 
560c573
<                  
---
> 
574c587
<                     
---
> 
581c594
<                  
---
> 
585c598
<                  
---
> 
588c601
<               
---
> 
604c617
<         
---
> 
612c625
<         
---
> 
620c633
<      ELSE   ! .NOT. use_effcrs here is implemeted
---
>      ELSE   ! .NOT. use_effcrs
629c642
<      
---
> 
636d648
<                  
655c667
<  ELSE
---
>   ELSE
675c687
<  
---
> 
684c696
<      
---
> 
689c701
<     
---
> 
698c710
<   
---
> 
710c722
<   
---
> 
725c737
<         
---
> 
729c741
<         
---
> 
733,734c745,746
<         
< !        CALL lup_polerror(toz, fps(nz1), nw, waves, tmpalbs, polerr(1:nw, 1, 1), errstat)
---
> 
>         !        CALL lup_polerror(toz, fps(nz1), nw, waves, tmpalbs, polerr(1:nw, 1, 1), errstat)
738c750
<      
---
> 
749c761
<         
---
> 
753c765
<         
---
> 
757,758c769,770
<         
< !        CALL lup_polerror(toz, fps(nctp-1), nw, waves, tmpalbs, polerr(1:nw, 2, 1), errstat)
---
> 
>         !        CALL lup_polerror(toz, fps(nctp-1), nw, waves, tmpalbs, polerr(1:nw, 2, 1), errstat)
792c804
<                          !(waves(idum) < 304. .AND. waves(i) >= 304.0) .OR.  &
---
>                                 !(waves(idum) < 304. .AND. waves(i) >= 304.0) .OR.  &
805c817
<                           
---
> 
819c831
<            
---
> 
833c845
<                  npolcorr = npolcorr + 1; polcorr_idxs(npolcorr) = i
---
>               npolcorr = npolcorr + 1; polcorr_idxs(npolcorr) = i
837c849
<         
---
> 
845c857
<   
---
> 
847d858
<   
849c860
<     
---
> 
852d862
<      
854c864
<       
---
> 
868c878
<   
---
> 
877c887
<           
---
> 
886d895
< 
890c899
<         
---
> 
893c902
<         
---
> 
909c918
<      
---
> 
915c924
<         
---
> 
927c936
<      
---
> 
934c943
<      
---
> 
941c950
<     
---
> 
945c954
<            
---
> 
955c964
<            
---
> 
961c970
<            
---
> 
971c980
<               
---
> 
984c993
<         
---
> 
986c995
<         
---
> 
997c1006
<            
---
> 
1001c1010
<               
---
> 
1005c1014
<               
---
> 
1008c1017
<               
---
> 
1013c1022
<                  
---
> 
1021c1030
<                  IF (problems) then
---
>                  IF (problems) THEN
1029c1038
<               
---
> 
1035c1044
<               
---
> 
1038c1047
<               
---
> 
1047c1056
<                  
---
> 
1054c1063
<            
---
> 
1079c1088
<            
---
> 
1083c1092
<            
---
> 
1085c1094
<               
---
> 
1093c1102
<               
---
> 
1127c1136
<               
---
> 
1134c1143
<               
---
> 
1139c1148
<               
---
> 
1148c1157
<                             surfacewf(1, 1, 1, 1:nostk, 1) * polerr(iw, ic, 1:nostk) * frac ! / lambertian_albedo 
---
>                          surfacewf(1, 1, 1, 1:nostk, 1) * polerr(iw, ic, 1:nostk) * frac ! / lambertian_albedo 
1154c1163
<               
---
> 
1156c1165
<            
---
> 
1162c1171
<   
---
> 
1176c1185
<     
---
> 
1190c1199
<   
---
> 
1192c1201
<   IF (nw > 1 .AND. do_radinter ) THEN ! do_radinter F
---
>   IF (nw > 1 .AND. do_radinter ) THEN
1194d1202
<  
1200d1207
<     
1203c1210
<   
---
> 
1205c1212
<      IF (do_fraywf .AND. do_fozwf) THEN  !! here is done
---
>      IF (do_fraywf .AND. do_fozwf) THEN 
1220d1226
<   
1256c1262
<   
---
> 
1268c1274
<   
---
> 
1322c1328
<    
---
> 
1328c1334
<   
---
> 
1332c1338
<   
---
> 
1344c1350
<      
---
>      PRINT *, nw, nz
============================
lidort_prof_prep.f90
188d187
< 
191,193c190,192
<         WRITE(*,'(A,f8.2,i5,i5)') 'Negative total absorption: at', lamda, i, ngas
<         print *, 'abscrs:',abscrs(1:ngas, i)
<         print *, 'gascol:',gascol(1:ngas, i)       
---
>         print *, 'Negative total absorption: ', lamda, i, ngas
>         print *, abscrs(1:ngas, i)
>         print *, gascol(1:ngas, i)       
============================
lidort_prof_utilities.f90
4c4
<      albarr, albpmin, albpmax, vary_sfcalb, walb0s, n0wfc, wfcarr, wfcpmin, wfcpmax, &
---
>      albarr, albpmin, albpmax, vary_sfcalb, walb0s, n0wfc, wfcarr, wfcpmin, wfcpmax, wfc0s, &
9c9,10
<   USE OMSAO_variables_module, ONLY : fitvar_rad_str, fitwavs, numwin, fitvar_rad
---
>   USE OMSAO_variables_module, ONLY : fitvar_rad_str, fitwavs, numwin,  &
>        fitvar_rad, mask_fitvar_rad, rmask_fitvar_rad
12,13c13,17
<        wfcfidx, nwfc, nfwfc, wfcidx, wfcmin, wfcmax, wfcfpix, wfclpix, hreswav
< 
---
>        wfcfidx, nwfc, nfwfc, wfcidx, wfcmin, wfcmax, wfcfpix, wfclpix, &
>        hreswav, which_cld, do_alb_longwav, use_prefitalb, pf2ba0,      &
>        pf2ba1, pf2fc0, pf2fc1
>   USE cloud_data_module, ONLY : new_cfrac, new_alb, new_ps0, new_ctp, n_newalb, &
>        n_newwfc, use_retctp, use_retalb, avgwav_cld
15c19
<   
---
> 
17c21
<   
---
> 
28c32
<   REAL (KIND=dp), DIMENSION(nw),  INTENT(IN)           :: waves, walb0s
---
>   REAL (KIND=dp), DIMENSION(nw),  INTENT(IN)           :: waves, walb0s, wfc0s
37c41
<   
---
> 
41,42c45,46
<   INTEGER :: i, j, k, fidx, lidx, fidx0, lidx0
<   REAL (KIND=dp), DIMENSION(nw0)            :: waves0, walb0s0
---
>   INTEGER :: i, j, k, m, n, fidx, lidx, fidx0, lidx0, albord, wfcord
>   REAL (KIND=dp), DIMENSION(nw0)            :: waves0, walb0s0, wfc0s0
49c53,54
<   
---
>   LOGICAL  :: no2alb0
>   CHARACTER(LEN=1)  :: ordchar
56a62,64
> 
>   ! no2alb0 this make no change 
>   no2alb0 = .TRUE.
60c68,70
<      IF (fitvar_rad_str(j)(4:4) == '0') THEN
---
> 
>      READ(fitvar_rad_str(j)(4:4), '(I1)') albord
>      IF (albord == 0) THEN
68d77
< 
69a79,97
> 
>         IF (do_alb_longwav .AND. numwin == 3 .AND. fitvar_rad_str(j) == '2ba0' &
>              .AND. rmask_fitvar_rad(j) <= 0 .AND. vary_sfcalb) THEN
>            DO n = i, nalb
>               m = albidx -1 + n
>               IF (fitvar_rad_str(m) == '3ba0'.AND. rmask_fitvar_rad(m) > 0) EXIT 
>            ENDDO
>            IF (n > nalb) THEN
>               WRITE(*, *)  'HRES_RADCALC_ENV: ERROR 2ba0 is not filled'
>               errstat = pge_errstat_error; RETURN   
>            ENDIF
>            walb0s0(fidx0:lidx0) = fitvar_rad(m)
>            no2alb0 = .TRUE.
>            !ELSE IF (do_alb_longwav.AND. numwin == 2 .AND. which_cld == 5 .AND. use_retalb) THEN
>            !   walb0s0(fidx0:lidx0) = new_alb(1)
>         ELSE IF (use_prefitalb .AND. fitvar_rad_str(j) == '2ba0' &
>              .AND. rmask_fitvar_rad(j) <= 0 .AND. vary_sfcalb) THEN
>            walb0s0(albpmin0(k):albpmax0(k)) = pf2ba0
>         ENDIF
75c103
<            
---
> 
77c105,134
<            walb0s0(fidx0:lidx0) = walb0s0(fidx0:lidx0) + fitvar_rad(j) * (waves0(fidx0:lidx0) - wavavg)
---
>            walb0s0(fidx0:lidx0) = walb0s0(fidx0:lidx0) + fitvar_rad(j) * (waves0(fidx0:lidx0) - wavavg)**albord
> 
>            IF (do_alb_longwav .AND. numwin == 3 .AND. fitvar_rad_str(j)(1:3) == '2ba' &
>                 .AND. rmask_fitvar_rad(j) <= 0)  THEN
>               WRITE(ordchar, '(I1)') albord 
> 
>               DO n = i, nalb
>                  m = albidx -1 + n
>                  IF (fitvar_rad_str(m) == '3ba'//ordchar.AND. rmask_fitvar_rad(m) > 0) EXIT 
>               ENDDO
>               IF (n > nalb) THEN
>                  WRITE(*, *)  'HRES_RADCALC_ENV: ERROR 2ba1 is not filled'
>                  errstat = pge_errstat_error; RETURN   
>               ENDIF
>               IF (no2alb0) THEN
>                  fidx = albfpix(n)
>                  lidx = alblpix(n)
>                  wavavg = SUM(waves(fidx:lidx)/(1.0+lidx-fidx))
>               ENDIF
>               walb0s0(fidx0:lidx0) = walb0s0(fidx0:lidx0) + fitvar_rad(m) * (waves0(fidx0:lidx0) - wavavg)**albord
>            ELSE IF (do_alb_longwav.AND. numwin == 2 .AND. which_cld == 5 .AND. use_retalb) THEN
>               m = albord + 1
>               IF (m > n_newalb) THEN
>                  WRITE(*, *)  'HRES_RADCALC_ENV: which_cld==5, alb variables not consist'
>               ENDIF
>               walb0s0(fidx0:lidx0) = walb0s0(fidx0:lidx0) + new_alb(m) * (waves0(fidx0:lidx0) - avgwav_cld)**albord
>            ELSE IF (use_prefitalb .AND. fitvar_rad_str(j)(1:3) == '2ba'  &
>                 .AND. rmask_fitvar_rad(j) <= 0)  THEN
>               walb0s0(fidx0:lidx0) = walb0s0(fidx0:lidx0) + pf2ba1 * (waves0(fidx0:lidx0) - wavavg)**albord
>            ENDIF
80d136
<     
83,87c139,142
<   k = 0
<   DO i = 1, nwfc
<      j = wfcidx - 1 + i
<      IF (fitvar_rad_str(j)(4:4) == '0') THEN
<         k = k + 1
---
>   IF (n0wfc > 0) THEN
>      k = 0;  wfcpmin0(1) = 1; wfcpmax0(n0wfc) = ncalcp 
>      DO i = 1, nwfc
>         j = wfcidx - 1 + i
89,93c144,181
<         IF (k > 1) wfcpmin0(k)= wfcpmax0(k-1) + 1 
<         IF (k < n0wfc) wfcpmax0(k)= MINVAL(MAXLOC(waves0(1:ncalcp), MASK=(waves0(1:ncalcp) &
<              >= wfcmin(i) .AND. waves0(1:ncalcp) < wfcmax(i))))  
<      ENDIF
<   ENDDO
---
>         READ(fitvar_rad_str(j)(4:4), '(I1)') wfcord
>         IF (wfcord == 0) THEN
>            k = k + 1
> 
>            IF (k > 1) wfcpmin0(k)= wfcpmax0(k-1) + 1 
>            IF (k < n0wfc) wfcpmax0(k)= MINVAL(MAXLOC(waves0(1:ncalcp), MASK=(waves0(1:ncalcp) &
>                 >= wfcmin(i) .AND. waves0(1:ncalcp) < wfcmax(i))))  
> 
>            fidx0 = wfcpmin0(k); lidx0 = wfcpmax0(k)
>            IF (vary_sfcalb) wfc0s0(wfcpmin0(k):wfcpmax0(k)) = wfcarr(k)
>            ! If use longwave albedo/cfrac
>            IF (do_alb_longwav .AND. numwin == 3 .AND. fitvar_rad_str(j) == '2fc0' &
>                 .AND. rmask_fitvar_rad(j) <= 0 .AND. vary_sfcalb)  THEN
>               DO n = i, nwfc
>                  m = wfcidx -1 + n
>                  IF (fitvar_rad_str(m) == '3fc0'.AND. rmask_fitvar_rad(m) > 0) EXIT 
>               ENDDO
>               IF (n > nwfc) THEN
>                  WRITE(*, *)  'HRES_RADCALC_ENV: ERROR 2fc0 is not filled'
>                  errstat = pge_errstat_error; RETURN   
>               ENDIF
>               wfc0s0(fidx0:lidx0) = fitvar_rad(m)
>               no2alb0 = .TRUE.
>               !ELSE IF (do_alb_longwav.AND. numwin == 2 .AND. which_cld == 5 .AND. use_retalb) THEN
>               !   wfc0s0(fidx0:lidx0) = new_cfrac(1)
>            ELSE IF (use_prefitalb .AND. fitvar_rad_str(j) == '2fc0' &
>                 .AND. rmask_fitvar_rad(j) <= 0 .AND. vary_sfcalb) THEN
>               wfc0s0(wfcpmin0(k):wfcpmax0(k)) = pf2fc0
>            ENDIF
>         ELSE
>            IF (vary_sfcalb) THEN
>               fidx=wfcfpix(i); lidx=wfclpix(i)
>               wavavg = SUM(waves(fidx:lidx)/(1.0+lidx-fidx)) 
>               wfc0s0(fidx0:lidx0) = wfc0s0(fidx0:lidx0) + fitvar_rad(j) * (waves0(fidx0:lidx0) - wavavg)**wfcord
>               ! If use longwave albedo/cfrac
>               IF (do_alb_longwav .AND. numwin == 3 .AND. fitvar_rad_str(j)(1:3) == '2fc' &
>                    .AND. rmask_fitvar_rad(j) <= 0)  THEN
>                  WRITE(ordchar, '(I1)') wfcord 
94a183,214
>                  DO n = i, nwfc
>                     m = wfcidx -1 + n
>                     IF (fitvar_rad_str(m) == '3fc'//ordchar.AND. rmask_fitvar_rad(m) >= 0) EXIT 
>                  ENDDO
>                  IF (n > nwfc) THEN
>                     WRITE(*, *)  'HRES_RADCALC_ENV: ERROR 2fc1 is not filled'
>                     errstat = pge_errstat_error; RETURN   
>                  ENDIF
>                  IF (no2alb0) THEN
>                     fidx = wfcfpix(n)
>                     lidx = wfclpix(n)
>                     wavavg = SUM(waves(fidx:lidx)/(1.0+lidx-fidx))
>                  ENDIF
>                  wfc0s0(fidx0:lidx0) = wfc0s0(fidx0:lidx0) + fitvar_rad(m) * (waves0(fidx0:lidx0) - wavavg)**wfcord
>               ELSE IF (do_alb_longwav .AND. numwin == 2 .AND. which_cld == 5 .AND. use_retalb) THEN
>                  m = wfcord + 1
>                  IF (m > n_newwfc) THEN
>                     WRITE(*, *) 'HRES_RADCALC_ENV: which_cld==5, cfrac variables not consist'
>                  ENDIF
>                  wfc0s0(fidx0:lidx0) = wfc0s0(fidx0:lidx0) + new_cfrac(m) * (waves0(fidx0:lidx0) - avgwav_cld)**wfcord
>               ELSE IF (use_prefitalb .AND. fitvar_rad_str(j)(1:3) == '2fc'  &
>                    .AND. rmask_fitvar_rad(j) <= 0)  THEN
>                  wfc0s0(fidx0:lidx0) = wfc0s0(fidx0:lidx0) + pf2fc1 * (waves0(fidx0:lidx0) - wavavg)**wfcord
>               ENDIF
>            ENDIF
>         ENDIF
>      ENDDO
>   ENDIF
>   !do i = 1, ncalcp
>   !   write(89, '(F9.4, 1p30D16.7)') waves0(i), walb0s0(i), wfc0s0(i)
>   !enddo
>   !pause
104,105d223
< 
< 
110c228
<        nostk, albwf0, ozwf0, tmpwf0, o3shiwf0, cfracwf0, codwf0, ctpwf0, taodwf0,     &
---
>        wfc0s0, nostk, albwf0, ozwf0, tmpwf0, o3shiwf0, cfracwf0, codwf0, ctpwf0, taodwf0,     &
112c230
<  
---
> 
164c282
<   invdhw = 1.0 / dhw0 !100.
---
>   invdhw = 1.0 / dhw0
166c284
<   ! (1) Establish high resolution grid (0.01 nm grid)
---
>   ! Establish high resolution grid (0.01 nm grid)
169,170c287
< 
<   IF (.NOT. use_redfixwav) THEN !F
---
>   IF (.NOT. use_redfixwav) THEN
177c294
< 
---
>         
179c296
<         hreswav(nhresp+1:nhresp+nsub) = swav + dhw0 * (/(j, j = 0, nsub-1)/) 
---
>         hreswav(nhresp+1:nhresp+nsub) = swav + dhw0 * (/(j, j = 0, nsub-1)/)      
210,211d326
< 
<   ! hres_samprate 0.05 nm, dhw0 0.01, invdhw 20, nratio 5, nhalf 2
214a330
>   
221a338
>   
230d346
<   ! 1.0 0.4 0.6
242c358
< 
---
>      
245d360
<         !write(*,'(2i5, 3f12.4)') j, ncalcp, tmp, hreswav(j), radcwav(ncalcp)
254d368
< 
255a370
>      
263a379,380
> 
>   !DO i = 1, nhresp
393c510
<     
---
> 
433c550
<           o3tdepend, no3t, o3normc, problems)           
---
>           o3tdepend, no3t, o3normc, problems)
434a552
>         PRINT *, 'mxsect = ', mxsect
438c556
<     
---
> 
449c567
<    
---
>      
483d600
<        
488d604
<               
493c609
<               
---
>            
525d640
<           
534c649
<        
---
> 
598d712
<        
746c860
<     
---
>      
861c975
<  
---
> 
889c1003
<  
---
>   
898d1011
<  
917c1030
<   
---
> 
949c1062
<   
---
> 
1186c1299
< 
---
>   
1194d1306
< 
1198d1309
< 
1267c1378
< 
---
>    
1428c1539
<  
---
> 
1547c1658
<        ozabs_convl, refwvl_sav, n_refwvl_sav, here_stop
---
>        ozabs_convl, refwvl_sav, n_refwvl_sav
1565,1566c1676,1677
<   INTEGER, PARAMETER :: maxline  = 10057      ! # of wavelengths
<   INTEGER, PARAMETER :: maxt = 5              ! # of Ts or # of coeff.
---
>   INTEGER, PARAMETER :: maxline  = 12001      ! # of wavelengths
>   INTEGER, PARAMETER :: maxt = 12 !5              ! # of Ts or # of coeff.
1630,1631c1741,1742
<  
<      READ (ozabs_unit, *) tdepend, nt, slitconv ! T 3 T
---
>      
>      READ (ozabs_unit, *) tdepend, nt, slitconv
1643,1647c1754,1758
<      IF ((nt > 1 .AND. .NOT. tdepend ) .AND. (MINVAL(ts(1:nt)) > &
<           MINVAL(tsgrid) .OR.  MAXVAL(ts(1:nt)) < MAXVAL(tsgrid))) THEN
<         WRITE(*, *) 'Temperature range for cross section not enough!!!'
<         problems = .TRUE.; CLOSE (ozabs_unit); RETURN
<      ENDIF
---
>      !IF ((nt > 1 .AND. .NOT. tdepend ) .AND. (MINVAL(ts(1:nt)) > &
>      !     MINVAL(tsgrid) .OR.  MAXVAL(ts(1:nt)) < MAXVAL(tsgrid))) THEN
>      !   WRITE(*, *) 'Temperature range for cross section not enough!!!'
>      !   problems = .TRUE.; CLOSE (ozabs_unit); RETURN
>      !ENDIF
1659c1770
<         WRITE(*, *) 'Need to increase parameter maxline!!!', nline, maxline
---
>         WRITE(*, *) 'Need to increase parameter maxline!!!', nline
1668a1780
>      
1679a1792
> 
1843,1845c1956
< 
< 
<  
---
>   
1948c2059
<  
---
>   
2028a2140,2324
> SUBROUTINE GETO4_CRS(lamda, nlsav, nlamda, nlayers, tsgrid, abscrs, problems)
> 
>   USE OMSAO_precision_module  
>   USE OMSAO_parameters_module,ONLY : zerok
>   USE OMSAO_variables_module, ONLY : yn_varyslit, do_bandavg, refdbdir, &
>        which_slit, n_refspec_pts, refspec_orig_data, refidx_sav, &
>        o4crs_convl, refwvl_sav, n_refwvl_sav
>   USE ozprof_data_module,     ONLY : ozabs_unit, mxsect
>   USE OMSAO_slitfunction_module
>   IMPLICIT NONE
>   
>   ! Input variables
>   INTEGER, INTENT(IN)                                     :: nlamda, nlsav, nlayers
>   REAL (KIND=dp), INTENT(IN), DIMENSION(nlsav)            :: lamda
>   REAL (KIND=dp), INTENT(IN), DIMENSION(nlayers)          :: tsgrid
>   
>   ! Output variables
>   REAL (KIND=dp), DIMENSION(nlamda, nlayers), INTENT(OUT) :: abscrs
>   LOGICAL, INTENT(OUT)                                    :: problems
>   
>   ! Local variables
>   INTEGER, PARAMETER   :: maxline  = 16000      ! # of wavelengths
>   INTEGER, PARAMETER   :: maxt = 5             ! # of Ts or # of coeff.
>   
>   INTEGER, SAVE        :: nline, nt
>   LOGICAL, SAVE        :: first = .TRUE., tdepend, slitconv
>   REAL (KIND=dp), SAVE :: maxw, minw, normc
>   REAL (KIND=dp), SAVE, DIMENSION(maxline)       :: refwavs, lowresi0
>   REAL (KIND=dp), SAVE, DIMENSION(maxt)          :: ts
>   REAL (KIND=dp), SAVE, DIMENSION(maxt, maxline) :: refabs0, refabs
> 
>   REAL (KIND=dp), DIMENSION(maxt, nlsav)   :: savabs
>   REAL (KIND=dp), DIMENSION(maxt, nlamda)  :: tmpabs
> 
>   REAL (KIND=dp), DIMENSION(nlsav)         :: tmpi0
>   
>   INTEGER            :: i, j, errstat, ntemp, nline1, ni0, fidx, lidx
>   REAL (KIND=dp)     :: thet, frac, scalex
>   LOGICAL            :: get_lresi0
> 
>   CHARACTER (LEN=130):: absfname
>   CHARACTER (LEN=14) :: tmpchar
> 
>   ! ------------------------------
>   ! Name of this subroutine/module
>   ! ------------------------------
>   CHARACTER (LEN=9), PARAMETER    :: modulename = 'geto4_crs'
>   
>   problems = .FALSE.
> 
>   absfname = TRIM(ADJUSTL(refdbdir)) // 'OMSAO_Thalman_O4quad_extended654nm.dat'
> 
>   IF (first) THEN
>      tmpchar = ' ' 
>      OPEN(UNIT = ozabs_unit, file=absfname, status='old')
>      DO WHILE (tmpchar /= 'START OF TABLE') 
>         READ (ozabs_unit, '(A14)') tmpchar
>      ENDDO
>      
>      READ (ozabs_unit, *) nline, minw, maxw, normc
>      IF (nline > maxline) THEN
>         WRITE(*, *) 'Need to increase parameter maxline!!!'
>         problems = .TRUE.; CLOSE (ozabs_unit); RETURN
>      ENDIF
>      
>      IF (minw > lamda(nlsav) .OR. maxw < lamda(1)) THEN
>         WRITE(*, *) 'Cross section does not cover any part of the spectral range'
>         problems = .TRUE.; CLOSE (ozabs_unit); RETURN
>      ENDIF
>      
>      READ (ozabs_unit, *) tdepend, nt, slitconv
>      IF (nt > maxt) THEN
>         WRITE(*, *) 'Need to increase parameter maxt!!!'
>         problems = .TRUE.; CLOSE (ozabs_unit); RETURN
>      ENDIF
> 
>      IF (tdepend .AND. nt > 3) THEN
>         WRITE(*, *) 'High-order (>2) T-dependent cross section not implemented!!!'
>         problems = .TRUE.; CLOSE (ozabs_unit); RETURN
>      ENDIF
>      
>      READ (ozabs_unit, *) ts(1:nt)
>      !Allow extrapolation over temperature here
>      !IF ((nt > 1 .AND. .NOT. tdepend ) .AND. (MINVAL(ts(1:nt)) > &
>      !     MINVAL(tsgrid) .OR.  MAXVAL(ts(1:nt)) < MAXVAL(tsgrid))) THEN
>      !   WRITE(*, *) 'Temperature range for cross section not enough!!!'
>      !   problems = .TRUE.; CLOSE (ozabs_unit); RETURN
>      !ENDIF
>   
>      j = 1
>      DO i = 1, nline
>         READ(ozabs_unit, *) refwavs(j), refabs0(1:nt, j)
>         IF (refwavs(j) > lamda(1) - 5.0 .AND. refwavs(j) < &
>              lamda(nlsav) + 5.0)  j = j + 1
>      ENDDO
>      nline = j - 1
>      CLOSE (ozabs_unit)
>      first = .FALSE.
>   ENDIF
>   
>   IF (o4crs_convl) THEN   
>      refabs(1:nt, 1:nline) = refabs0(1:nt, 1:nline)
>      
>      IF (slitconv) THEN
>         ni0 = n_refspec_pts(1)
>         scalex = 0.1  ! dummy number, not used any more
>         DO i = 1, nt 
>            CALL CORRECT_I0EFFECT(refwavs(1:nline), refabs(i, 1:nline), nline, refspec_orig_data(1, 1:ni0, 1), &
>                 refspec_orig_data(1, 1:ni0, 2), ni0, scalex, get_lresi0, errstat, lowresi0(1:nline))
>            IF ( errstat /= 0 ) THEN
>               WRITE(*, *) 'Error in Correct I0 Effect!!!'
>               problems = .TRUE.; RETURN
>            ENDIF
>         ENDDO
>      ENDIF
>      o4crs_convl = .FALSE.
>   ENDIF
> 
>   ! Convolution and interpolation
>   savabs(1:nt, :) = 0.0d0
>   fidx = MINVAL(MINLOC(lamda(1:nlsav), MASK=(lamda(1:nlsav) >= refwavs(1))))
>   lidx = MINVAL(MAXLOC(lamda(1:nlsav), MASK=(lamda(1:nlsav) <= refwavs(nline))))
>   ntemp = lidx - fidx + 1
>   DO i = 1, nt
>      CALL BSPLINE(refwavs(1:nline), refabs(i, 1:nline), nline, lamda(fidx:lidx), &
>           savabs(i, fidx:lidx), ntemp, errstat)
>      IF (errstat < 0) THEN
>         WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat
>         problems = .TRUE.; RETURN
>      ENDIF
> 
>      IF (do_bandavg) THEN
>         CALL avg_band_effozcrs(lamda, savabs(i, :), nlsav, ntemp, errstat)
> 
>         IF ( errstat /= 0 .OR. ntemp /= nlamda) THEN
>            WRITE(*, *) 'O4 Spectra Averaging Error: ', nlsav, nlamda, ntemp
>            problems = .TRUE.; RETURN
>         ENDIF
>         tmpabs(i, :) = savabs(i, 1:nlamda)
>      ELSE
>         tmpabs(i, :) = savabs(i, 1:nlamda)
>      ENDIF
> 
>   ENDDO
>     
>   ! Interpolate with respect to temperature
>   IF (tdepend .AND. nt == 3) THEN       ! qudratic T dependent coefficients
>      DO i = 1, nlayers
>         thet = tsgrid(i) - zerok
>         abscrs(:, i) = (tmpabs(1, :) + tmpabs(2, :) * thet &
>              + tmpabs(3, :) * thet * thet )
>      ENDDO
>   ELSE IF (tdepend .AND. nt == 2) THEN   ! linear T dependent coefficients
>      DO i = 1, nlayers
>         thet = tsgrid(i) - zerok
>         abscrs(:, i) = (tmpabs(1, :) + tmpabs(2, :) * thet)
>      ENDDO
>   ELSE IF (nt == 1)  THEN           ! only 1 T
>      DO i = 1, nlayers
>         abscrs(:, i) = tmpabs(1, :)
>      ENDDO
>   ELSE IF (nt == 2) THEN            ! have 2 T values
>      DO i = 1, nlayers
>         frac = 1.0 - (tsgrid(i) - ts(1)) / (ts(2) - ts(1))
>         abscrs(:, i) = (frac * tmpabs(1, :) + (1.0 - frac) * tmpabs(2, :))
>      END DO
>   ELSE IF (.NOT. tdepend .AND. nt >= 3) THEN ! have more than n T     
>      DO i = 1, nlamda           ! interpolate over T   
>         CALL INTERPOL(ts(1:nt), tmpabs(1:nt,i), nt, tsgrid, abscrs(i, :), nlayers, errstat)
>         IF (errstat < 0) THEN
>            WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat
>            problems = .TRUE.; RETURN
>         ENDIF
>      ENDDO   
>   ELSE 
>      WRITE(*, *) modulename, ': Such type of O4 cross sections not implemented' 
>      problems = .TRUE.; RETURN
>   ENDIF
> 
>   abscrs = abscrs * normc
>   
>   RETURN  
> END SUBROUTINE GETO4_CRS
> 
> 
============================
make_atm.f90
40,41c40,42
<        the_surfalt, the_lon, the_lat, fitvar_rad_init, currline, atmdbdir, here_stop
<   USE OMSAO_indices_module,   ONLY : so2_idx, hcho_idx, bro_idx, bro2_idx, no2_t1_idx, so2v_idx, o2o2_idx
---
>        the_surfalt, the_lon, the_lat, fitvar_rad_init, currline, atmdbdir
>   USE OMSAO_indices_module,   ONLY : so2_idx, hcho_idx, bro_idx, bro2_idx, no2_t1_idx, so2v_idx, &
>        o2o2_idx, o2_idx, bro_idx, no2_t2_idx, h2o_idx, o2t2_idx, h2ot2_idx
50,51c51
<        so2zind, so2vprofn1p1, so2valts, atmos_unit, ozone_above60km, pv811, trpz
< 
---
>        so2zind, so2vprofn1p1, so2valts, atmos_unit, ozone_above60km, pv811, trpz, insert_sfc_layer
108c108
<   REAL (KIND=dp), DIMENSION (1:60)           :: a1, a2, a3
---
> 
113c113
<   LOGICAL :: use_input_spres = .TRUE., fixed_temp = .FALSE.
---
>   LOGICAL :: use_input_spres = .TRUE.
118c118
<   
---
> 
128,129c128
<  
<     
---
>   
135,136c134
< ! CALL GET_NCEPT(year, month, day, the_lon, the_lat, told(1:nlecm))
<  
---
>   ! CALL GET_NCEPT(year, month, day, the_lon, the_lat, told(1:nlecm))
139d136
< 
142c139
<   ! Use TOMS V8 temperature climatology for 0.70, 0.35 mb 
---
>   ! Use TOMS V8 temperature climatology for 0.70, 0.35 mb
155,156d151
<   if (fixed_temp) told = told0
< 
162c157
<   ! xliu (08/17/2008): Use extrapolation 
---
>   ! xliu (08/17/2008): Use extrapolation
164,168c159,163
<     IF (spres > pold(0) ) THEN
<        pold(0) = spres; told(0) = sfct
<     ELSE
<        told(0) = told(1) + (told(1)-told(2))/(LOG(pold(1))-LOG(pold(2))) * (LOG(pold(0))-LOG(pold(1)))
<     ENDIF
---
>      IF (spres > pold(0) ) THEN
>         pold(0) = spres; told(0) = sfct
>      ELSE
>         told(0) = told(1) + (told(1)-told(2))/(LOG(pold(1))-LOG(pold(2))) * (LOG(pold(0))-LOG(pold(1)))
>      ENDIF
217c212
<         
---
> 
230d224
<    
254c248,249
<            IF (umkp0(numk) > p0 * 2.0D0 ** (-13.5D0)) umkp0(numk) = p0 * 2.0D0 ** (-13.5D0) 
---
>            !IF (umkp0(numk) > p0 * 2.0D0 ** (-13.5D0)) umkp0(numk) = p0 * 2.0D0 ** (-13.5D0) 
>            umkp0(numk) = p0 * 2.0D0 ** (-13.5D0) 
258c253
<      
---
> 
275a271
> 
316,317c312,314
<      ntp = MAXVAL(MINLOC(ABS(LOG(tpres)-umkp))) - 1;  umkp(ntp) = LOG(tpres)
<      IF ( ntp == 0 ) ntp = 1 ! should not replace surface (xliu: 08/09/12) 
---
>      ntp = MAXVAL(MINLOC(ABS(LOG(tpres)-umkp))) - 1
>      IF (ntp == 0) ntp = 1  ! Should not replace surface (xliu: 8/9/12)
>      umkp(ntp) = LOG(tpres)
324,327c321,332
<      dlgp = (umkp(0) - umkp(ntp)) / REAL(ntp, KIND=dp)
<      DO i = 1, ntp-1
<         umkp(i) = umkp(i-1) - dlgp
<      ENDDO
---
>      IF (.NOT. insert_sfc_layer) THEN
>         dlgp = (umkp(0) - umkp(ntp)) / REAL(ntp, KIND=dp)
>         DO i = 1, ntp-1
>            umkp(i) = umkp(i-1) - dlgp
>         ENDDO
>      ELSE
>         umkp(1) = LOG(spres-10.0)
>         dlgp = (umkp(1) - umkp(ntp)) / REAL(ntp-1, KIND=dp)
>         DO i = 2, ntp-1
>            umkp(i) = umkp(i-1) - dlgp
>         ENDDO
>      ENDIF
337c342
<         DO i = 1, ntp
---
>         DO i = 1, numk !ntp
349a355,368
> 
>      IF (insert_sfc_layer) THEN
>         IF (nsfc == 0 ) THEN
>            IF (EXP(umkp(0)) - EXP(umkp(2)) >= 20.0 ) THEN
>               umkp(1) = LOG(EXP(umkp(0)) - 10.0)
>            ELSE
>               umkp(1) = (umkp(2) + umkp(0)) / 2.0
>            ENDIF
>         ELSE IF (EXP(umkp(nsfc))-EXP(umkp(nsfc+1)) > 20.0) THEN
>            nsfc = nsfc - 1
>            umkp(nsfc) = LOG(spres)
>            umkp(nsfc+1) = LOG(EXP(umkp(nsfc)) - 10.0)
>         ENDIF
>      ENDIF
352,354c371,381
<   !=================================================================================!
<   !  GET ozone profile in retrieval grid
<   !=================================================================================!
---
> 
>   ! loading troppause height in km
>   CALL INTERPOL(pold, zold, nold+1,umkp(ntp), trpz, 1, errstat)
>   IF (errstat < 0) THEN
>      WRITE(*, *) modulename, ': INTERPOL error, errstat = ', errstat
>      errstat = pge_errstat_error; RETURN
>   ENDIF 
> 
>   ! Get a priori climatology for 0-60 km (pressure altitude)
>   ! Perform interpolation over the time domain (xliu: 01/18/2006)
>   !CALL GET_V8PROF(month, day, the_lat, toz, which_clima, v8oz(1:nv8), ozref(1:nmpref-1))
362,363d388
<   
<   ! Get a priori climatology for 0-60 km (pressure altitude)
366d390
<   ! loading troppause height in km
368,388c392,401
<   CALL INTERPOL(pold, zold, nold+1,umkp(ntp), trpz, 1, errstat)
< 
<   IF (errstat < 0) THEN
<      WRITE(*, *) modulename, ': INTERPOL error, errstat = ', errstat
<      errstat = pge_errstat_error; RETURN
<   ENDIF 
< ! 1 = surface , 0-1km ~  59~60 km   
<   IF (which_clima == 1 .or. which_clima == 6) THEN 
<          CALL GET_MCPROF (ozref(1:nmpref-1)) 
<   ELSE IF  (which_clima >= 2 .and. which_clima <=4) THEN
<          CALL GET_TBPROF (ozref(1:nmpref-1),1)
<   ELSE  IF (which_clima == 5) THEN
<          CALL GET_IUPPROF(toz, ozref(1:nmpref-1))   
<   ELSE  IF (which_clima == 12) THEN 
<          CALL GET_MLprof(ozref(1:nmpref-1), 1)
<   ELSE  IF (which_clima == 13) THEn 
<          CALL GET_TJprof(ozref(1:nmpref-1), 1)
<   ELSE  IF (which_clima == 14) THEn 
<          CALL get_OMIPROF(ozref(1:nmpref-1), 1)
<   ELSE 
<          CALL GET_MCPROF (ozref(1:nmpref-1)) 
---
>   IF (which_clima == 1 .OR. which_clima == 6) THEN
>      CALL GET_MCPROF (ozref(1:nmpref-1)) 
>   ELSE IF (which_clima >= 2 .AND. which_clima <=4) THEN
>      CALL GET_TBPROF (ozref(1:nmpref-1))
>   ELSE IF (which_clima == 5) THEN
>      CALL GET_IUPPROF(toz, ozref(1:nmpref-1))   
>   ELSE IF (which_clima == 12) THEN
>      CALL GET_MLprof(ozref(1:nmpref-1), 1)
>   ELSE
>      CALL GET_MCPROF (ozref(1:nmpref-1)) 
391c404
< 
---
>   !IF (spres > p0 .OR. EXP(umkp(0)) > p0) refp(0) = MAX(LOG(spres), umkp(0))
398c411
<   IF (refp(nref) > EXP(umkp(numk)) ) refp(nref) = EXP(umkp(numk)) !top
---
>   IF (refp(nref) > EXP(umkp(numk)) ) refp(nref) = EXP(umkp(numk))  !top
401c414
<   DO i = 1, nref
---
>   DO i = 1, nref  
404d416
< 
407,409d418
<   IF (refp(0) < umkp(0)  .and. abs(refp(0)-umkp(0)) < 1E-10 ) THEN
<        umkp(0) =refp(0)
<   ENDIf
411,413c420,422
< 
<   IF (errstat < 0) THEN 
<      WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat ;stop
---
>   IF (errstat < 0) THEN
>      WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat
>      errstat = pge_errstat_error; RETURN
417,418c426
<    
<   CALL get_v8prof(toz, v8oz(1:nv8)) 
---
>      CALL get_v8prof(toz, v8oz(1:nv8))
423a432,436
>      ! May have negative values for upper layers or lead to inproper interpolation 
>      ! when interpolated from the 11 layer climatology and the partial column ozone 
>      ! for these layers are very small, need readjustment using the McPeters Clima
>      umkoz1 = umkoz
> 
424a438
>      !IF (spres > p0 .OR. EXP(umkp(0)) > p0) pv8(0) = MAX(LOG(spres), umkp(0))
430,435c444
<         pv8(nv8) = umkp(numk)
< 
<      ! May have negative values for upper layers or lead to inproper interpolation 
<      ! when interpolated from the 11 layer climatology and the partial column ozone 
<      ! for these layers are very small, need readjustment using the McPeters Clima
<      umkoz1 = umkoz
---
>      pv8(nv8) = umkp(numk)
439c448
<         WRITE(*, *) modulename, ': BSPLINE error 1, errstat = ', errstat
---
>         WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat
455c464
<     
---
>  
473c482
<      IF ( i == numk) fndiv = fndiv + 1  ! Add one more layers for the top layer
---
>      IF ( i == numk) fndiv = fndiv + 3  ! Add one more layers for the top layer
482d490
< 
609d616
< 
641c648
<    
---
> 
643d649
<    
667c673
<            IF (gasidxs(i) == no2_t1_idx) THEN
---
>            IF (gasidxs(i) == no2_t1_idx .OR. gasidxs(i) == no2_t2_idx) THEN
726a733,737
>            ELSE IF (gasidxs(i) == o2_idx .OR. gasidxs(i) == o2t2_idx) THEN
>               ! Assume 20.95% for O2
>               mgasprof(i, 1:np) = frhos(1:np)*0.2095
>            ELSE IF (gasidxs(i) == h2o_idx .OR. gasidxs(i) == h2ot2_idx) THEN
>               CALL GET_AFGLUS_H2O (fps(nfsfc:np), mgasprof(i, nfsfc+1:np), np-nsfc)
740,741d750
< 
< 
937c946
< 
---
> !ozprof(1:numk) = ozprof(1:numk) * 305.0/316.0
947c956
<   
---
> 
============================
oe_inversion.f90
29c29
<                                                                         
---
> 
32c32
<                                                                         
---
> 
61c61
<                                                                  
---
> 
66,97c66,67
<  USE OMSAO_precision_module
<  IMPLICIT NONE
<      
<  ! ====================================
<  ! Input / Output variaibles
<  ! ====================================
<  LOGICAL, INTENT(IN)         :: do_sa_diagonal, do_oe_output, last_iter
<  INTEGER, INTENT(IN)         :: file_unit, num_iter, nx, ny, sidx, eidx
<  REAL (KIND=dp), INTENT (IN) :: delta_chi_min
<  REAL (KIND=dp), DIMENSION(ny, nx), INTENT (IN)  :: rK 
<  REAL (KIND=dp), DIMENSION(ny), INTENT (IN)      :: y, dy
<  REAL (KIND=dp), DIMENSION(nx, nx), INTENT(IN)   :: Sa 
<  REAL (KIND=dp), DIMENSION(nx), INTENT (IN)      :: xap, xold
<  CHARACTER(len=6), DIMENSION(nx), INTENT(IN)     :: xname
<  
<  LOGICAL, INTENT(OUT)                            :: conv                                   
<  REAL (KIND=dp), INTENT(OUT)                     :: ozdfs, ozinfoh, chi_new
<  REAL (KIND=dp), DIMENSION(nx), INTENT(OUT)      :: x
<  REAL (KIND=dp), DIMENSION(ny), INTENT (OUT)     :: ynew
<  REAL (KIND=dp), DIMENSION(nx, nx), INTENT (OUT) :: Sx, Sxn, rkernel
<  REAL (KIND=dp), DIMENSION(nx, ny), INTENT (OUT) :: contr
<                                                                         
<  ! =======================                                                              
<  ! Local variables                                                       
<  ! =======================         
<  INTEGER                          :: i, j, l, k 
<  REAL(KIND=dp)                    :: dfn, chi_old, wsa_min, dfs, h,  wsa_max, delta_chi 
<  REAL(KIND=dp), DIMENSION(nx)     :: y_prime, xa_prime, x_prime, wsa, wsa_inv, w, xastd, xa, &
<       tmpw2, tmpw2p1, tmpratio
<  REAL (KIND=dp), DIMENSION(ny)    :: ytmp
<  REAL(KIND=dp), DIMENSION(ny, nx) :: rK_tilde, u, tmp2
<  REAL(KIND=dp), DIMENSION(nx, nx) :: usa, vsa, sasqp, sasqn, tmp, tmp1, v
---
>   USE OMSAO_precision_module
>   IMPLICIT NONE
99,103c69,79
<  conv = .FALSE. 
<  xa = xap - xold
<  DO i = 1, nx
<     xastd(i) = SQRT(Sa (i, i))
<  ENDDO
---
>   ! ====================================
>   ! Input / Output variaibles
>   ! ====================================
>   LOGICAL, INTENT(IN)         :: do_sa_diagonal, do_oe_output, last_iter
>   INTEGER, INTENT(IN)         :: file_unit, num_iter, nx, ny, sidx, eidx
>   REAL (KIND=dp), INTENT (IN) :: delta_chi_min
>   REAL (KIND=dp), DIMENSION(ny, nx), INTENT (IN)  :: rK 
>   REAL (KIND=dp), DIMENSION(ny), INTENT (IN)      :: y, dy
>   REAL (KIND=dp), DIMENSION(nx, nx), INTENT(IN)   :: Sa 
>   REAL (KIND=dp), DIMENSION(nx), INTENT (IN)      :: xap, xold
>   CHARACTER(len=6), DIMENSION(nx), INTENT(IN)     :: xname
105,215c81,86
<  IF (do_sa_diagonal) THEN      ! Diagonal Apriori    
<     ! Construct rK_tilde = Sy^(-1/2)*K*Sa^(1/2) (u=Ktil for dsvdcmp) 
<     DO j = 1, nx           
<        rK_tilde (:, j) = xastd(j) * rK (:, j) / dy 
<     ENDDO
<     u = rK_tilde
<     
<     ! SVD of Ktil:                                                          
<     CALL dsvdcmp (u, ny, nx, ny, nx, w, v) 
<     tmpw2 = w ** 2;    tmpw2p1 = tmpw2 + 1.0d0; tmpratio = tmpw2 / tmpw2p1
<     
<     ! Construct y_prime=UT*Sy^(-1/2)*y:                                     
<     DO i = 1, nx 
<        y_prime (i) = SUM ( u(:, i) * y / dy )
<     ENDDO
<                                                                         
<     ! Construct xa_prime=VT*Sa^(-1/2)*xa:                                   
<     DO i = 1, nx 
<        xa_prime (i) = SUM ( v(:, i) * xa  / xastd ) 
<     ENDDO
<                                                                         
<     ! ACTUAL RETRIEVAL: Calculate x_prime = (WT*W+I)^(-1)(W*y_prime + xa_prime) 
<     x_prime = (w * y_prime + xa_prime ) / tmpw2p1
<     
<     ! Construct x=Sa^(1/2)*V*x_prime:                                       
<     DO i = 1, nx 
<        x (i) = SUM ( v (i, :) * x_prime * xastd(i) )
<     ENDDO
<     
<     ! Construct Sx=Sa^(1/2)*V* (WT*W+I)^(-1) *VT*Sa^(1/2)                   
<     DO i = 1, nx 
<        DO j = 1, nx 
<           Sx (i, j) = SUM( v (i, :) * v (j, :) / tmpw2p1 )  * xastd(i) * xastd(j)
<        ENDDO
<     ENDDO
<     
<     IF (last_iter .OR. do_oe_output) THEN
<        ! Construct rkernel=Sa^(1/2)*V* (W^t*W+I)^(-1)*WT*W *V^t*Sa^(-1/2)      
<        DO i = 1, nx 
<           DO j = 1, nx 
<              rkernel (i, j) = SUM (v (i, :) * v (j, :) * tmpratio ) * xastd(i) * xastd(j)
<           ENDDO
<        ENDDO
<     ENDIF     
<                                                                                                    
<  ELSE ! Sa is not diagonal      
<     
<     ! SVD of Sa to calculate Sa^(1/2) and Sa^(-1/2)                         
<     ! NOTE: Sa is square and symmetric: u=v                                 
<     usa = sa
<     CALL dsvdcmp (usa, nx, nx, nx, nx, wsa, vsa) 
<    
<     ! Make reciprokal of very small eigenvalues zero: ! replaced with follow
<     wsa_min = 1.d-16
<     wsa_inv = 0.0d0
<     DO i = 1, nx 
<        IF (wsa (i) > wsa_min) wsa_inv (i) = 1.0d0 / wsa (i) 
<     ENDDO
<                                                                         
<     ! Sa^(1/2) = U*W^(1/2)*UT and Sa^(-1/2) = U*W^(-1/2)*UT                 
<     DO i = 1, nx 
<        DO j = 1, nx 
<           sasqp (i, j) = SUM ( usa (i, :) * usa (j, :) * SQRT (wsa) )
<           sasqn (i, j) = SUM ( usa (i, :) * usa (j, :) * SQRT (wsa_inv) )
<        ENDDO
<     ENDDO
<     
<     ! Construct rK_tilde = Sy^(-1/2)*K*Sa^(1/2) (u=Ktil for dsvdcmp)        
<     ! NOTE: Sy is assumed to be diagonal!!!:                                
<     DO i = 1, ny 
<        DO j = 1, nx 
<           rK_tilde (i, j) = SUM (rK (i, :) * sasqp (:, j))
<           u (i, j) = rK_tilde (i, j) / dy (i) 
<        ENDDO
<     ENDDO
<                                                                           
<     ! SVD of Ktil:                                                          
<     CALL dsvdcmp (u, ny, nx, ny, nx, w, v) 
<     tmpw2 = w ** 2;    tmpw2p1 = tmpw2 + 1.0d0; tmpratio = tmpw2 / tmpw2p1
<     
<     ! Construct y_prime=UT*Sy^(-1/2)*y:                                     
<     DO i = 1, nx 
<        y_prime (i) = SUM (u (:, i) * y / dy) 
<     ENDDO
<     
<     ! Construct xa_prime=VT*Sa^(-1/2)*xa: 
<     DO i = 1, nx 
<        DO j = 1, nx 
<           tmp (i, j) = SUM (v (:, i) * sasqn (:, j))
<        ENDDO
<        xa_prime (i) = SUM (tmp (i, :) * xa)
<     ENDDO
<     
<     ! ACTUAL RETRIEVAL: Calculate x_prime = (WT*W+I)^(-1)(W*y_prime + xa_prime)
<     x_prime = (w * y_prime + xa_prime ) / tmpw2p1   
<     
<     ! Construct x=Sa^(1/2)*V*x_prime:                                                                                   
<     DO i = 1, nx 
<        DO j = 1, nx 
<           tmp (i, j) = SUM(sasqp(i, :) * v (:, j)) 
<        ENDDO
<        x (i) =  SUM(tmp (i, :) * x_prime)
<     ENDDO
<     
<     ! Construct Sx=Sa^(1/2)*V* (WT*W+I)^(-1) *VT*Sa^(1/2)                   
<     ! First: tmp = Sa^(1/2)*V* (WT*W+I)^(-1)                                
<     DO i = 1, nx 
<        DO j = 1, nx 
<           tmp (i, j) =  SUM (sasqp (i, :) * v (:, j) / tmpw2p1(j)) 
<        ENDDO
<     ENDDO
---
>   LOGICAL, INTENT(OUT)                            :: conv                                   
>   REAL (KIND=dp), INTENT(OUT)                     :: ozdfs, ozinfoh, chi_new
>   REAL (KIND=dp), DIMENSION(nx), INTENT(OUT)      :: x
>   REAL (KIND=dp), DIMENSION(ny), INTENT (OUT)     :: ynew
>   REAL (KIND=dp), DIMENSION(nx, nx), INTENT (OUT) :: Sx, Sxn, rkernel
>   REAL (KIND=dp), DIMENSION(nx, ny), INTENT (OUT) :: contr
217,222c88,97
<     ! then: tmp1 = tmp*VT:                                                  
<     DO i = 1, nx 
<        DO j = 1, nx 
<           tmp1 (i, j) = SUM( tmp (i, :) * v (j, :))
<        ENDDO
<     ENDDO
---
>   ! =======================                                                              
>   ! Local variables                                                       
>   ! =======================         
>   INTEGER                          :: i, j, l, k 
>   REAL(KIND=dp)                    :: dfn, chi_old, wsa_min, dfs, h,  wsa_max, delta_chi 
>   REAL(KIND=dp), DIMENSION(nx)     :: y_prime, xa_prime, x_prime, wsa, wsa_inv, w, xastd, xa, &
>        tmpw2, tmpw2p1, tmpratio
>   REAL(KIND=dp), DIMENSION(ny)     :: ytmp
>   REAL(KIND=dp), DIMENSION(ny, nx) :: rK_tilde, u, tmp2
>   REAL(KIND=dp), DIMENSION(nx, nx) :: usa, vsa, sasqp, sasqn, tmp, tmp1, v
224,239c99,103
<     ! then: sx = tmp1*Sa^(1/2):                                             
<     DO i = 1, nx 
<        DO j = 1, nx 
<           sx (i, j) = SUM (tmp1 (i, :) * sasqp (:, j) )
<        ENDDO
<     ENDDO
<     
<     ! IF (last_iter .OR. do_oe_output) THEN                        
<     
<     ! Construct rkernel=Sa^(1/2)*V* (W^t*W+I)^(-1)*WT*W *V^t*Sa^(-1/2)      
<     ! First: tmp = Sa^(1/2)*V* (WT*W+I)^(-1)*WT*W                           
<     DO i = 1, nx 
<        DO j = 1, nx 
<           tmp (i, j) = SUM (sasqp (i, :) * v (:, j) * tmpratio(j) )
<        ENDDO
<     ENDDO
---
>   conv = .FALSE. 
>   xa = xap - xold
>   DO i = 1, nx
>      xastd(i) = SQRT(Sa (i, i))
>   ENDDO
241,246c105,110
<     ! then: tmp1 = tmp*VT:                                                  
<     DO i = 1, nx 
<        DO j = 1, nx 
<           tmp1 (i, j) = SUM(tmp (i, :) * v (j, :))  
<        ENDDO
<     ENDDO
---
>   IF (do_sa_diagonal) THEN      ! Diagonal Apriori    
>      ! Construct rK_tilde = Sy^(-1/2)*K*Sa^(1/2) (u=Ktil for dsvdcmp) 
>      DO j = 1, nx           
>         rK_tilde (:, j) = xastd(j) * rK (:, j) / dy 
>      ENDDO
>      u = rK_tilde
248,284c112,114
<     ! then: rkernel = tmp1*Sa^(-1/2):                                       
<     DO i = 1, nx 
<        DO j = 1, nx 
<           rkernel (i, j) = SUM (tmp1 (i, :) * sasqn (:, j) )
<        ENDDO
<     ENDDO
<                                                                         
<     ! endif          
<  ENDIF  ! Sa diagonal or not diagonal  
<                                                                         
< ! Improvement in Chi:                                                   
<  chi_old = SQRT(SUM( (y / dy) ** 2) / ny)
<  DO i = 1, ny 
<     ytmp(i) = SUM (rK (i, :) * x )
<  ENDDO
<  chi_new   =  SQRT (SUM(((y - ytmp) / dy ) **2) / ny)
<  ynew      = y - ytmp
<  delta_chi = ABS ( (chi_new - chi_old) / chi_old) 
<                                                                         
<  ! Check convergence                                                     
<  IF (delta_chi < delta_chi_min) conv = .TRUE. 
<  
<  IF (last_iter .OR. do_oe_output) THEN   
<     ! Construct contribution function: Sx K^T Sy^(-1):                  
<     DO i = 1, nx 
<        DO j = 1, ny 
<           contr(i, j) = SUM(sx(i, :) * rK(j, :)) / (dy(j) ** 2) 
<        ENDDO
<     ENDDO  
<  ENDIF
<                                                                         
< ! Construct retrieval noise covariance matrix: Sx K^T Sy^(-1) K Sx      
<  DO i = 1, ny 
<     DO j = 1, nx 
<        tmp2(i, j) = SUM(rK (i, :) * sx (:, j)) / (dy (i) ** 2)    
<     ENDDO
<  ENDDO
---
>      ! SVD of Ktil:                                                          
>      CALL dsvdcmp (u, ny, nx, ny, nx, w, v) 
>      tmpw2 = w ** 2;    tmpw2p1 = tmpw2 + 1.0d0; tmpratio = tmpw2 / tmpw2p1
286,290c116,119
<  DO i = 1, nx 
<     DO j = 1, nx 
<        tmp(i, j) =  SUM(rK (:, i) * tmp2 (:, j))
<     ENDDO
<  ENDDO
---
>      ! Construct y_prime=UT*Sy^(-1/2)*y:                                     
>      DO i = 1, nx 
>         y_prime (i) = SUM ( u(:, i) * y / dy )
>      ENDDO
292,308c121,124
<  DO i = 1, nx 
<     DO j = 1, nx 
<        Sxn(i, j) = SUM(Sx(:, i) * tmp (:, j))
<     ENDDO
<  ENDDO
<  
<  ! Degrees of Freedom Noise and Signal, Information content (dfn,dfs,h): 
<  IF (last_iter .OR. do_oe_output) THEN  
<     
<     dfn = SUM(1.0d0 / tmpw2p1)
<     h = SUM(0.5d0 * LOG (tmpw2p1) )
<     dfs = nx - dfn 
<     
<     ozdfs = 0.0 
<     DO i = sidx, eidx 
<        ozdfs = ozdfs + rkernel (i, i) 
<     ENDDO
---
>      ! Construct xa_prime=VT*Sa^(-1/2)*xa:                                   
>      DO i = 1, nx 
>         xa_prime (i) = SUM ( v(:, i) * xa  / xastd ) 
>      ENDDO
310,339c126,127
<     ! need to check for this later        
<     ozinfoh = ozdfs / dfs * h    
<  ENDIF
<                                                                         
<  !  Level 2 output debug                                                 
<  !  --------------------                                                 
<  IF (do_oe_output) THEN
<     ! chi-square                                                            
<     WRITE (file_unit, '(A, I5)')    'Iteration = ', num_iter 
<     WRITE (file_unit, '(A, D14.6)') 'Old Chi   = ', chi_old 
<     WRITE (file_unit, '(A, D14.6)') 'New Chi   = ', chi_new 
<     WRITE (file_unit, '(A, D14.6, A1,D14.6)') 'Delchi / limit value = ', &
<          delta_chi, '/', delta_chi_min                                  
<     
<     ! Degrees of Freedom Noise and Signal, Information content (dfn,dfs,h): 
<     WRITE (file_unit, '(2(A, D14.6))') 'DFN =       ', dfn, ' OZDFN  = ',  (eidx - sidx + 1)  - ozdfs                                   
<     WRITE (file_unit, '(2(A, D14.6))') 'DFS =       ', dfs, ' OZDFS  = ', ozdfs                                                         
<     WRITE (file_unit, '(2(A, D14.6))') 'Information content = ', h,  ' OZINFO = ', ozinfoh                                          
<     
<     !! Eigenvalues:                                                          
<     !WRITE(file_unit,'(A)') ' Eigenvalues:'                       
<     !WRITE(file_unit,'(A)') ' columns, points'                    
<     !WRITE(file_unit,'(I3,I5)') 1, nx                               
<     !DO i = 1, nx                                                 
<     !   WRITE(file_unit,'(I3,5D15.7)') i, w(i)                      
<     !ENDDO
<     
<     ! A priori and its error and retrieved state and error                                       
<     WRITE (file_unit, '(A6,6A14)') '  Var  ', ' retrieved ', ' noise error', 'smooth error', &
<          'Previous ', ' apriori  ', ' apr. error '  
---
>      ! ACTUAL RETRIEVAL: Calculate x_prime = (WT*W+I)^(-1)(W*y_prime + xa_prime) 
>      x_prime = (w * y_prime + xa_prime ) / tmpw2p1
341,346c129,132
<     DO i = 1, nx 
<        WRITE (file_unit, '(A6, 6D14.6)') xname (i), x (i) + xold (i), SQRT (sxn (i, i) ), &
<             SQRT (Sx (i, i) ), xold (i), xap (i), xastd(i)                                             
<     ENDDO
<     
<  ENDIF
---
>      ! Construct x=Sa^(1/2)*V*x_prime:                                       
>      DO i = 1, nx 
>         x (i) = SUM ( v (i, :) * x_prime * xastd(i) )
>      ENDDO
348c134,348
<  RETURN 
---
>      ! Construct Sx=Sa^(1/2)*V* (WT*W+I)^(-1) *VT*Sa^(1/2)                   
>      DO i = 1, nx 
>         DO j = 1, nx 
>            Sx (i, j) = SUM( v (i, :) * v (j, :) / tmpw2p1 )  * xastd(i) * xastd(j)
>         ENDDO
>      ENDDO
> 
>      IF (last_iter .OR. do_oe_output) THEN
>         ! Construct rkernel=Sa^(1/2)*V* (W^t*W+I)^(-1)*WT*W *V^t*Sa^(-1/2)      
>         DO i = 1, nx 
>            DO j = 1, nx 
>               rkernel (i, j) = SUM (v (i, :) * v (j, :) * tmpratio ) * xastd(i) * xastd(j)
>            ENDDO
>         ENDDO
>      ENDIF
> 
>   ELSE ! Sa is not diagonal      
> 
>      ! SVD of Sa to calculate Sa^(1/2) and Sa^(-1/2)                         
>      ! NOTE: Sa is square and symmetric: u=v                                 
>      usa = sa
>      CALL dsvdcmp (usa, nx, nx, nx, nx, wsa, vsa) 
> 
>      ! Make reciprokal of very small eigenvalues zero: ! replaced with follow
>      wsa_min = 1.d-16
>      wsa_inv = 0.0d0
>      DO i = 1, nx
>         IF (wsa (i) > wsa_min) wsa_inv (i) = 1.0d0 / wsa (i) 
>      ENDDO
> 
>      ! Sa^(1/2) = U*W^(1/2)*UT and Sa^(-1/2) = U*W^(-1/2)*UT                 
>      DO i = 1, nx 
>         DO j = 1, nx 
>            sasqp (i, j) = SUM ( usa (i, :) * usa (j, :) * SQRT (wsa) )
>            sasqn (i, j) = SUM ( usa (i, :) * usa (j, :) * SQRT (wsa_inv) )
>         ENDDO
>      ENDDO
> 
>      ! Construct rK_tilde = Sy^(-1/2)*K*Sa^(1/2) (u=Ktil for dsvdcmp)        
>      ! NOTE: Sy is assumed to be diagonal!!!:                                
>      DO i = 1, ny 
>         DO j = 1, nx 
>            rK_tilde (i, j) = SUM (rK (i, :) * sasqp (:, j))
>            u (i, j) = rK_tilde (i, j) / dy (i) 
>         ENDDO
>      ENDDO
> 
>      ! SVD of Ktil:                                                          
>      CALL dsvdcmp (u, ny, nx, ny, nx, w, v)
>      tmpw2 = w ** 2;    tmpw2p1 = tmpw2 + 1.0d0; tmpratio = tmpw2 / tmpw2p1
> 
>      ! Construct y_prime=UT*Sy^(-1/2)*y:                                     
>      DO i = 1, nx 
>         y_prime (i) = SUM (u (:, i) * y / dy) 
>      ENDDO
> 
>      ! Construct xa_prime=VT*Sa^(-1/2)*xa: 
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp (i, j) = SUM (v (:, i) * sasqn (:, j))
>         ENDDO
>         xa_prime (i) = SUM (tmp (i, :) * xa)
>      ENDDO
> 
>      ! ACTUAL RETRIEVAL: Calculate x_prime = (WT*W+I)^(-1)(W*y_prime + xa_prime)
>      x_prime = (w * y_prime + xa_prime ) / tmpw2p1   
> 
>      ! Construct x=Sa^(1/2)*V*x_prime:                                                                                   
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp (i, j) = SUM(sasqp(i, :) * v (:, j)) 
>         ENDDO
>         x (i) =  SUM(tmp (i, :) * x_prime)
>      ENDDO
> 
>      ! Construct Sx=Sa^(1/2)*V* (WT*W+I)^(-1) *VT*Sa^(1/2)                   
>      ! First: tmp = Sa^(1/2)*V* (WT*W+I)^(-1)                                
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp (i, j) =  SUM (sasqp (i, :) * v (:, j) / tmpw2p1(j)) 
>         ENDDO
>      ENDDO
> 
>      ! then: tmp1 = tmp*VT:                                                  
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp1 (i, j) = SUM( tmp (i, :) * v (j, :))
>         ENDDO
>      ENDDO
> 
>      ! then: sx = tmp1*Sa^(1/2):                                             
>      DO i = 1, nx 
>         DO j = 1, nx 
>            sx (i, j) = SUM (tmp1 (i, :) * sasqp (:, j) )
>         ENDDO
>      ENDDO
> 
>      ! IF (last_iter .OR. do_oe_output) THEN                        
> 
>      ! Construct rkernel=Sa^(1/2)*V* (W^t*W+I)^(-1)*WT*W *V^t*Sa^(-1/2)      
>      ! First: tmp = Sa^(1/2)*V* (WT*W+I)^(-1)*WT*W                           
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp (i, j) = SUM (sasqp (i, :) * v (:, j) * tmpratio(j) )
>         ENDDO
>      ENDDO
> 
>      ! then: tmp1 = tmp*VT:                                                  
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp1 (i, j) = SUM(tmp (i, :) * v (j, :))  
>         ENDDO
>      ENDDO
> 
>      ! then: rkernel = tmp1*Sa^(-1/2):                                       
>      DO i = 1, nx 
>         DO j = 1, nx 
>            rkernel (i, j) = SUM (tmp1 (i, :) * sasqn (:, j) )
>         ENDDO
>      ENDDO
> 
>      ! endif          
>   ENDIF  ! Sa diagonal or not diagonal  
> 
>   ! Improvement in Chi:                                                   
>   chi_old = SQRT(SUM( (y / dy) ** 2) / ny)
>   DO i = 1, ny 
>      ytmp(i) = SUM (rK (i, :) * x )
>   ENDDO
>   chi_new   =  SQRT (SUM(((y - ytmp) / dy ) **2) / ny)
>   ynew      = y - ytmp
>   delta_chi = ABS ( (chi_new - chi_old) / chi_old) 
> 
>   ! Check convergence                                                     
>   IF (delta_chi < delta_chi_min) conv = .TRUE. 
> 
>   IF (last_iter .OR. do_oe_output) THEN   
>      ! Construct contribution function: Sx K^T Sy^(-1):                  
>      DO i = 1, nx 
>         DO j = 1, ny 
>            contr(i, j) = SUM(sx(i, :) * rK(j, :)) / (dy(j) ** 2) 
>         ENDDO
>      ENDDO
>   ENDIF
> 
>   ! Construct retrieval noise covariance matrix: Sx K^T Sy^(-1) K Sx      
>   DO i = 1, ny 
>      DO j = 1, nx 
>         tmp2(i, j) = SUM(rK (i, :) * sx (:, j)) / (dy (i) ** 2)    
>      ENDDO
>   ENDDO
> 
>   DO i = 1, nx 
>      DO j = 1, nx 
>         tmp(i, j) =  SUM(rK (:, i) * tmp2 (:, j))
>      ENDDO
>   ENDDO
> 
>   DO i = 1, nx 
>      DO j = 1, nx 
>         Sxn(i, j) = SUM(Sx(:, i) * tmp (:, j))
>      ENDDO
>   ENDDO
> 
>   ! Degrees of Freedom Noise and Signal, Information content (dfn,dfs,h): 
>   IF (last_iter .OR. do_oe_output) THEN  
> 
>      dfn = SUM(1.0d0 / tmpw2p1)
>      h = SUM(0.5d0 * LOG (tmpw2p1) )
>      dfs = nx - dfn 
> 
>      ozdfs = 0.0 
>      DO i = sidx, eidx 
>         ozdfs = ozdfs + rkernel (i, i) 
>      ENDDO
> 
>      ! need to check for this later        
>      ozinfoh = ozdfs / dfs * h    
>   ENDIF
> 
>   !  Level 2 output debug                                                 
>   !  --------------------                                                 
>   IF (do_oe_output) THEN
>      ! chi-square                                                            
>      WRITE (file_unit, '(A, I5)')    'Iteration = ', num_iter 
>      WRITE (file_unit, '(A, D14.6)') 'Old Chi   = ', chi_old 
>      WRITE (file_unit, '(A, D14.6)') 'New Chi   = ', chi_new 
>      WRITE (file_unit, '(A, D14.6, A1,D14.6)') 'Delchi / limit value = ', &
>           delta_chi, '/', delta_chi_min                                  
> 
>      ! Degrees of Freedom Noise and Signal, Information content (dfn,dfs,h): 
>      WRITE (file_unit, '(2(A, D14.6))') 'DFN =       ', dfn, ' OZDFN  = ',  (eidx - sidx + 1)  - ozdfs                                   
>      WRITE (file_unit, '(2(A, D14.6))') 'DFS =       ', dfs, ' OZDFS  = ', ozdfs                                                         
>      WRITE (file_unit, '(2(A, D14.6))') 'Information content = ', h,  ' OZINFO = ', ozinfoh                                          
> 
>      !! Eigenvalues:                                                          
>      !WRITE(file_unit,'(A)') ' Eigenvalues:'                       
>      !WRITE(file_unit,'(A)') ' columns, points'                    
>      !WRITE(file_unit,'(I3,I5)') 1, nx                               
>      !DO i = 1, nx                                                 
>      !   WRITE(file_unit,'(I3,5D15.7)') i, w(i)                      
>      !ENDDO
> 
>      ! A priori and its error and retrieved state and error                                       
>      WRITE (file_unit, '(A6,6A14)') '  Var  ', ' retrieved ', ' noise error', 'smooth error', &
>           'Previous ', ' apriori  ', ' apr. error '  
> 
>      DO i = 1, nx 
>         WRITE (file_unit, '(A6, 6D14.6)') xname (i), x (i) + xold (i), SQRT (sxn (i, i) ), &
>              SQRT (Sx (i, i) ), xold (i), xap (i), xastd(i)                                             
>      ENDDO
> 
>   ENDIF
> 
>   RETURN 
349a350,942
> 
> 
> 
> 
> ! Sy is not diognal
> SUBROUTINE oe_inversion_y (do_sa_diagonal, do_oe_output, file_unit, delta_chi_min, last_iter, &
>      num_iter, ny, nx, y, sy, rk, xap, xold, sa, xname, sidx, eidx, x, sx, sxn, conv, &
>      rkernel, contr, ozdfs, ozinfoh, chi_new, ynew)  
> 
>   USE OMSAO_precision_module
>   IMPLICIT NONE
> 
>   ! ====================================
>   ! Input / Output variaibles
>   ! ====================================
>   LOGICAL, INTENT(IN)         :: do_sa_diagonal, do_oe_output, last_iter
>   INTEGER, INTENT(IN)         :: file_unit, num_iter, nx, ny, sidx, eidx
>   REAL (KIND=dp), INTENT (IN) :: delta_chi_min
>   REAL (KIND=dp), DIMENSION(ny, nx), INTENT (IN)  :: rK 
>   REAL (KIND=dp), DIMENSION(ny), INTENT (IN)      :: y
>   REAL (KIND=dp), DIMENSION(ny, ny), INTENT (IN)  :: sy
>   REAL (KIND=dp), DIMENSION(nx, nx), INTENT(IN)   :: Sa 
>   REAL (KIND=dp), DIMENSION(nx), INTENT (IN)      :: xap, xold
>   CHARACTER(len=6), DIMENSION(nx), INTENT(IN)     :: xname
> 
>   LOGICAL, INTENT(OUT)                            :: conv                                   
>   REAL (KIND=dp), INTENT(OUT)                     :: ozdfs, ozinfoh, chi_new
>   REAL (KIND=dp), DIMENSION(nx), INTENT(OUT)      :: x
>   REAL (KIND=dp), DIMENSION(ny), INTENT (OUT)     :: ynew
>   REAL (KIND=dp), DIMENSION(nx, nx), INTENT (OUT) :: Sx, Sxn, rkernel
>   REAL (KIND=dp), DIMENSION(nx, ny), INTENT (OUT) :: contr
> 
>   ! =======================                                                              
>   ! Local variables                                                       
>   ! =======================         
>   INTEGER                          :: i, j, l, k 
>   REAL(KIND=dp), DIMENSION(1, 1)   :: chi
>   REAL(KIND=dp)                    :: dfn, chi_old, wsa_min, dfs, h,  wsa_max, delta_chi 
>   REAL(KIND=dp), DIMENSION(nx)     :: y_prime, xa_prime, x_prime, wsa, wsa_inv, w, xastd, xa, &
>        tmpw2, tmpw2p1, tmpratio
>   REAL(KIND=dp), DIMENSION(ny)     :: wsy, wsy_inv
>   REAL(KIND=dp), DIMENSION(ny)     :: ytmp, dy
>   REAL(KIND=dp), DIMENSION(1, ny)  :: y1t
>   REAL(KIND=dp), DIMENSION(ny, 1)  :: y1
>   REAL(KIND=dp), DIMENSION(nx, 1)  :: matx1
>   REAL(KIND=dp), DIMENSION(ny, ny) :: sy_inv
>   REAL(KIND=dp), DIMENSION(ny, nx) :: rK_tilde, u, tmp2
>   REAL(KIND=dp), DIMENSION(nx, nx) :: usa, vsa, sasqp, sasqn, tmp, tmp1, v
>   REAL(KIND=dp), DIMENSION(ny, ny) :: usy, vsy, sysqp, sysqn, wsy2, wsy2_inv!, tmp, tmp1, v
> 
>   conv = .FALSE. 
> 
>   dy = 1.0D0
>   !y1t(1, 1:ny) = y(1:ny)  
>   y1(1:ny, 1)  = y(1:ny) 
>   DO i = 1, ny
>      dy(i) = SQRT(sy(i, i))
>   ENDDO
> 
> 
>   xa = xap - xold
>   DO i = 1, nx
>      xastd(i) = SQRT(Sa (i, i))
>   ENDDO
> 
>   IF (do_sa_diagonal) THEN      ! Diagonal Apriori    
>      ! Construct rK_tilde = Sy^(-1/2)*K*Sa^(1/2) (u=Ktil for dsvdcmp) 
>      DO j = 1, nx           
>         rK_tilde (:, j) = xastd(j) * rK (:, j) / dy 
>      ENDDO
>      u = rK_tilde
> 
>      ! SVD of Ktil:                                                          
>      CALL dsvdcmp (u, ny, nx, ny, nx, w, v) 
>      tmpw2 = w ** 2;    tmpw2p1 = tmpw2 + 1.0d0; tmpratio = tmpw2 / tmpw2p1
> 
>      ! Construct y_prime=UT*Sy^(-1/2)*y:                                     
>      DO i = 1, nx 
>         y_prime (i) = SUM ( u(:, i) * y / dy )
>      ENDDO
> 
>      ! Construct xa_prime=VT*Sa^(-1/2)*xa:                                   
>      DO i = 1, nx 
>         xa_prime (i) = SUM ( v(:, i) * xa  / xastd ) 
>      ENDDO
> 
>      ! ACTUAL RETRIEVAL: Calculate x_prime = (WT*W+I)^(-1)(W*y_prime + xa_prime) 
>      x_prime = (w * y_prime + xa_prime ) / tmpw2p1
> 
>      ! Construct x=Sa^(1/2)*V*x_prime:                                       
>      DO i = 1, nx 
>         x (i) = SUM ( v (i, :) * x_prime * xastd(i) )
>      ENDDO
> 
>      ! Construct Sx=Sa^(1/2)*V* (WT*W+I)^(-1) *VT*Sa^(1/2)                   
>      DO i = 1, nx 
>         DO j = 1, nx 
>            Sx (i, j) = SUM( v (i, :) * v (j, :) / tmpw2p1 )  * xastd(i) * xastd(j)
>         ENDDO
>      ENDDO
> 
>      IF (last_iter .OR. do_oe_output) THEN
>         ! Construct rkernel=Sa^(1/2)*V* (W^t*W+I)^(-1)*WT*W *V^t*Sa^(-1/2)      
>         DO i = 1, nx 
>            DO j = 1, nx 
>               rkernel (i, j) = SUM (v (i, :) * v (j, :) * tmpratio ) * xastd(i) * xastd(j)
>            ENDDO
>         ENDDO
>      ENDIF
> 
>   ELSE ! Sa is not diagonal      
> 
>      ! SVD of Sa to calculate Sa^(1/2) and Sa^(-1/2)                         
>      ! NOTE: Sa is square and symmetric: u=v                                 
>      usa = sa
>      CALL dsvdcmp (usa, nx, nx, nx, nx, wsa, vsa) 
> 
>      ! Make reciprokal of very small eigenvalues zero: ! replaced with follow
>      wsa_min = 1.d-16
>      wsa_inv = 0.0d0
>      DO i = 1, nx
>         IF (wsa (i) > wsa_min) wsa_inv (i) = 1.0d0 / wsa (i) 
>      ENDDO
> 
>      ! Sa^(1/2) = U*W^(1/2)*UT and Sa^(-1/2) = U*W^(-1/2)*UT                 
>      DO i = 1, nx 
>         DO j = 1, nx 
>            sasqp (i, j) = SUM ( usa (i, :) * usa (j, :) * SQRT (wsa) )
>            sasqn (i, j) = SUM ( usa (i, :) * usa (j, :) * SQRT (wsa_inv) )
>         ENDDO
>      ENDDO
> 
>      ! Sy is not diagonal
>      usy = sy
> 
>      CALL dsvdcmp (usy, ny, ny, ny, ny, wsy, vsy) 
>      ! Make reciprokal of very small eigenvalues zero: 
>      wsy_inv = 0.0d0
>      DO i = 1, ny
>         IF (wsy (i) > wsa_min) wsy_inv (i) = 1.0d0 / wsy (i) 
>      ENDDO
>      ! Sy^(1/2) = U*W^(1/2)*UT and Sy^(-1/2) = U*W^(-1/2)*UT 
>      !do i =1, ny
>      !   wsy2(i, i) = wsy(i)
>      !   wsy2_inv(i, i) = wsy_inv(i)
>      !enddo
>      !sysqp = MATMUL(MATMUL(usy, SQRT (wsy2)), TRANSPOSE(usy))
>      !sysqn = MATMUL(MATMUL(usy, SQRT (wsy2_inv)), TRANSPOSE(usy))
>      !sy_inv= MATMUL(MATMUL(usy, wsy2_inv), TRANSPOSE(usy))
>      DO i = 1, ny 
>         DO j = 1, ny 
>            sysqp (i, j) = SUM ( usy (i, :) * usy (j, :) * SQRT (wsy) )
>            sysqn (i, j) = SUM ( usy (i, :) * usy (j, :) * SQRT (wsy_inv) )
>            sy_inv(i, j) = SUM ( usy (i, :) * usy (j, :) * wsy_inv )
>         ENDDO
>      ENDDO
> 
>      ! Construct rK_tilde = Sy^(-1/2)*K*Sa^(1/2) (u=Ktil for dsvdcmp)        
>      ! NOTE: Sy is assumed to be not diagonal!!!:                                
>      !DO i = 1, ny 
>      !   DO j = 1, nx 
>      !      rK_tilde (i, j) = SUM (rK (i, :) * sasqp (:, j))
>      !      u (i, j) = rK_tilde (i, j) / dy (i) 
>      !   ENDDO
>      !ENDDO
> 
>      rK_tilde =  MATMUL(MATMUL(sysqn, rK), sasqp)
>      u = rK_tilde
> 
>      ! SVD of Ktil:                                                          
>      CALL dsvdcmp (u, ny, nx, ny, nx, w, v)
>      tmpw2 = w ** 2;    tmpw2p1 = tmpw2 + 1.0d0; tmpratio = tmpw2 / tmpw2p1
> 
>      ! Construct y_prime=UT*Sy^(-1/2)*y:                                     
>      !DO i = 1, nx 
>      !   y_prime (i) = SUM (u (:, i) * y / dy) 
>      !ENDDO
>      matx1 = MATMUL(MATMUL(TRANSPOSE(u), sysqn), y1)
>      y_prime(1:nx) = matx1(1:nx, 1)
> 
>      ! Construct xa_prime=VT*Sa^(-1/2)*xa: 
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp (i, j) = SUM (v (:, i) * sasqn (:, j))
>         ENDDO
>         xa_prime (i) = SUM (tmp (i, :) * xa)
>      ENDDO
>      !xa_prime = MATMUL(MATMUL(TRANSPOSE(v), sasqn), xa)
> 
>      ! ACTUAL RETRIEVAL: Calculate x_prime = (WT*W+I)^(-1)(W*y_prime + xa_prime)
>      x_prime = (w * y_prime + xa_prime ) / tmpw2p1   
> 
>      ! Construct x=Sa^(1/2)*V*x_prime:                                                                                   
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp (i, j) = SUM(sasqp(i, :) * v (:, j)) 
>         ENDDO
>         x (i) =  SUM(tmp (i, :) * x_prime)
>      ENDDO
>      !x = MATMUL(MATMUL(sasqp, v), x_prime)
> 
> 
>      ! Construct Sx=Sa^(1/2)*V* (WT*W+I)^(-1) *VT*Sa^(1/2)                   
>      ! First: tmp = Sa^(1/2)*V* (WT*W+I)^(-1)                                
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp (i, j) =  SUM (sasqp (i, :) * v (:, j) / tmpw2p1(j)) 
>         ENDDO
>      ENDDO
> 
>      ! then: tmp1 = tmp*VT:                                                  
>      !DO i = 1, nx 
>      !   DO j = 1, nx 
>      !      tmp1 (i, j) = SUM( tmp (i, :) * v (j, :))
>      !   ENDDO
>      !ENDDO
>      tmp1 = MATMUL(tmp, TRANSPOSE(v))
> 
>      ! then: sx = tmp1*Sa^(1/2):                                             
>      !DO i = 1, nx 
>      !   DO j = 1, nx 
>      !      sx (i, j) = SUM (tmp1 (i, :) * sasqp (:, j) )
>      !   ENDDO
>      !ENDDO
>      sx = MATMUL(tmp1, sasqp)
> 
>      ! IF (last_iter .OR. do_oe_output) THEN                        
> 
>      ! Construct rkernel=Sa^(1/2)*V* (W^t*W+I)^(-1)*WT*W *V^t*Sa^(-1/2)      
>      ! First: tmp = Sa^(1/2)*V* (WT*W+I)^(-1)*WT*W                           
>      DO i = 1, nx 
>         DO j = 1, nx 
>            tmp (i, j) = SUM (sasqp (i, :) * v (:, j) * tmpratio(j) )
>         ENDDO
>      ENDDO
> 
>      ! then: tmp1 = tmp*VT:                                                  
>      !DO i = 1, nx 
>      !   DO j = 1, nx 
>      !      tmp1 (i, j) = SUM(tmp (i, :) * v (j, :))  
>      !   ENDDO
>      !ENDDO
>      tmp1 = MATMUL(tmp, TRANSPOSE(v))
> 
>      ! then: rkernel = tmp1*Sa^(-1/2):                                       
>      !DO i = 1, nx 
>      !   DO j = 1, nx 
>      !      rkernel (i, j) = SUM (tmp1 (i, :) * sasqn (:, j) )
>      !   ENDDO
>      !ENDDO
>      rkernel = MATMUL(tmp1, sasqn)     
> 
>      ! endif          
>   ENDIF  ! Sa diagonal or not diagonal  
> 
>   ! Improvement in Chi:                                                   
>   !chi_old = SQRT(SUM( (y / dy) ** 2) / ny)
>   chi = SQRT(MATMUL(MATMUL(TRANSPOSE(y1), sy_inv),y1) / ny)
>   chi_old = chi(1, 1)
> 
>   DO i = 1, ny 
>      ytmp(i) = SUM (rK (i, :) * x )
>   ENDDO
>   !chi_new   =  SQRT (SUM(((y - ytmp) / dy ) **2) / ny)
> 
>   y1(1:ny, 1) = y-ytmp
>   chi     =  SQRT(MATMUL(MATMUL(TRANSPOSE(y1), sy_inv), y1) / ny)
>   chi_new =  chi(1, 1)
> 
>   ynew      = y - ytmp
>   delta_chi = ABS ( (chi_new - chi_old) / chi_old) 
> 
>   ! Check convergence                                                     
>   IF (delta_chi < delta_chi_min) conv = .TRUE. 
> 
>   IF (last_iter .OR. do_oe_output) THEN   
>      ! Construct contribution function: Sx K^T Sy^(-1):                  
>      !DO i = 1, nx 
>      !   DO j = 1, ny 
>      !      contr(i, j) = SUM(sx(i, :) * rK(j, :)) / (dy(j) ** 2) 
>      !   ENDDO
>      !ENDDO
>      contr = MATMUL(MATMUL(sx, TRANSPOSE(rk)), sy_inv)
>   ENDIF
> 
>   ! Construct retrieval noise covariance matrix: Sx K^T Sy^(-1) K Sx      
>   !DO i = 1, ny 
>   !   DO j = 1, nx 
>   !      tmp2(i, j) = SUM(rK (i, :) * sx (:, j)) / (dy (i) ** 2)    
>   !   ENDDO
>   !ENDDO
>   !DO i = 1, nx 
>   !   DO j = 1, nx 
>   !      tmp(i, j) =  SUM(rK (:, i) * tmp2 (:, j))
>   !   ENDDO
>   !ENDDO
>   !DO i = 1, nx 
>   !   DO j = 1, nx 
>   !      Sxn(i, j) = SUM(Sx(:, i) * tmp (:, j))
>   !   ENDDO
>   !ENDDO
> 
>   Sxn = MATMUL(MATMUL(MATMUL(MATMUL(sx, TRANSPOSE(rK)), sy_inv), rK), Sx)
> 
>   ! Degrees of Freedom Noise and Signal, Information content (dfn,dfs,h): 
>   IF (last_iter .OR. do_oe_output) THEN  
> 
>      dfn = SUM(1.0d0 / tmpw2p1)
>      h = SUM(0.5d0 * LOG (tmpw2p1) )
>      dfs = nx - dfn 
> 
>      ozdfs = 0.0 
>      DO i = sidx, eidx 
>         ozdfs = ozdfs + rkernel (i, i) 
>      ENDDO
> 
>      ! need to check for this later        
>      ozinfoh = ozdfs / dfs * h    
>   ENDIF
> 
>   !  Level 2 output debug                                                 
>   !  --------------------                                                 
>   IF (do_oe_output) THEN
>      ! chi-square                                                            
>      WRITE (file_unit, '(A, I5)')    'Iteration = ', num_iter 
>      WRITE (file_unit, '(A, D14.6)') 'Old Chi   = ', chi_old 
>      WRITE (file_unit, '(A, D14.6)') 'New Chi   = ', chi_new 
>      WRITE (file_unit, '(A, D14.6, A1,D14.6)') 'Delchi / limit value = ', &
>           delta_chi, '/', delta_chi_min                                  
> 
>      ! Degrees of Freedom Noise and Signal, Information content (dfn,dfs,h): 
>      WRITE (file_unit, '(2(A, D14.6))') 'DFN =       ', dfn, ' OZDFN  = ',  (eidx - sidx + 1)  - ozdfs                                   
>      WRITE (file_unit, '(2(A, D14.6))') 'DFS =       ', dfs, ' OZDFS  = ', ozdfs                                                         
>      WRITE (file_unit, '(2(A, D14.6))') 'Information content = ', h,  ' OZINFO = ', ozinfoh                                          
> 
>      !! Eigenvalues:                                                          
>      !WRITE(file_unit,'(A)') ' Eigenvalues:'                       
>      !WRITE(file_unit,'(A)') ' columns, points'                    
>      !WRITE(file_unit,'(I3,I5)') 1, nx                               
>      !DO i = 1, nx                                                 
>      !   WRITE(file_unit,'(I3,5D15.7)') i, w(i)                      
>      !ENDDO
> 
>      ! A priori and its error and retrieved state and error                                       
>      WRITE (file_unit, '(A6,6A14)') '  Var  ', ' retrieved ', ' noise error', 'smooth error', &
>           'Previous ', ' apriori  ', ' apr. error '  
> 
>      DO i = 1, nx 
>         WRITE (file_unit, '(A6, 6D14.6)') xname (i), x (i) + xold (i), SQRT (sxn (i, i) ), &
>              SQRT (Sx (i, i) ), xold (i), xap (i), xastd(i)                                             
>      ENDDO
> 
>   ENDIF
> 
>   RETURN 
> END SUBROUTINE oe_inversion_y
> 
> SUBROUTINE sq_matrix_invert(x, n, x_inv)
> 
>   USE OMSAO_precision_module
>   IMPLICIT NONE
> 
>   ! ====================================
>   ! Input / Output variaibles
>   ! ====================================
>   INTEGER,                        INTENT(IN)  :: n
>   REAL(KIND=dp), DIMENSION(n, n), INTENT(IN)  :: x
>   REAL(KIND=dp), DIMENSION(n, n), INTENT(OUT) :: x_inv
> 
>   ! Local
>   INTEGER                         :: i, j
>   REAL(KIND=dp), PARAMETER        :: w_min = 1.D-16
>   REAL(KIND=dp), DIMENSION(n, n)  :: u, v
>   REAL(KIND=dp), DIMENSION(n)     :: w, w_inv
> 
>   u = x
> 
>   CALL dsvdcmp (u, n, n, n, n, w, v)  
> 
>   w_inv = 0.0D0
>   DO i = 1, n
>      IF (w (i) > w_min) w_inv (i) = 1.0d0 / w (i) 
>   ENDDO
>   DO i = 1, n
>      DO j = 1, n
>         x_inv(i, j) = SUM(u(i, :) * u(j, :) * w_inv) 
>      ENDDO
>   ENDDO
> 
>   RETURN
> 
> END SUBROUTINE sq_matrix_invert
> 
> !!$
> !!$
> !!$! Follow Rodger 2000
> !!$SUBROUTINE oe_inversion_new (do_sa_diagonal, do_oe_output, file_unit, delta_chi_min, last_iter, &
> !!$     num_iter, ny, nx, y, dy, rk, xap, xold, sa, xname, sidx, eidx, x, sx, sxn, conv, &
> !!$     rkernel, contr, ozdfs, ozinfoh, chi_new, ynew)  
> !!$
> !!$  USE OMSAO_precision_module
> !!$  IMPLICIT NONE
> !!$
> !!$  ! ====================================
> !!$  ! Input / Output variaibles
> !!$  ! ====================================
> !!$  LOGICAL, INTENT(IN)         :: do_sa_diagonal, do_oe_output, last_iter
> !!$  INTEGER, INTENT(IN)         :: file_unit, num_iter, nx, ny, sidx, eidx
> !!$  REAL (KIND=dp), INTENT (IN) :: delta_chi_min
> !!$  REAL (KIND=dp), DIMENSION(ny, nx), INTENT (IN)  :: rK 
> !!$  REAL (KIND=dp), DIMENSION(ny), INTENT (IN)      :: y
> !!$  REAL (KIND=dp), DIMENSION(ny, ny), INTENT (IN)  :: dy
> !!$  REAL (KIND=dp), DIMENSION(nx, nx), INTENT(IN)   :: Sa 
> !!$  REAL (KIND=dp), DIMENSION(nx), INTENT (IN)      :: xap, xold
> !!$  CHARACTER(len=6), DIMENSION(nx), INTENT(IN)     :: xname
> !!$
> !!$  LOGICAL, INTENT(OUT)                            :: conv                                   
> !!$  REAL (KIND=dp), INTENT(OUT)                     :: ozdfs, ozinfoh, chi_new
> !!$  REAL (KIND=dp), DIMENSION(nx), INTENT(OUT)      :: x
> !!$  REAL (KIND=dp), DIMENSION(ny), INTENT (OUT)     :: ynew
> !!$  REAL (KIND=dp), DIMENSION(nx, nx), INTENT (OUT) :: Sx, Sxn, rkernel
> !!$  REAL (KIND=dp), DIMENSION(nx, ny), INTENT (OUT) :: contr
> !!$
> !!$  ! =======================                                                              
> !!$  ! Local variables                                                       
> !!$  ! =======================         
> !!$  INTEGER                          :: i, j, l, k 
> !!$  REAL(KIND=dp)                    :: dfn, chi_old, wsa_min, dfs, h,  wsa_max, delta_chi 
> !!$  REAL(KIND=dp), DIMENSION(nx)     :: y_prime, xa_prime, x_prime, wsa, wsa_inv, w, xastd, xa, &
> !!$       tmpw2, tmpw2p1, tmpratio
> !!$  REAL(KIND=dp), DIMENSION(ny)     :: ytmp, wsy, wsy_inv
> !!$  REAL(KIND=dp), DIMENSION(ny, ny) :: sy_inv, usy, vsy, tmpy, g, uu_inv
> !!$  REAL(KIND=dp), DIMENSION(ny, nx) :: rK_tilde, u, tmp2
> !!$  REAL(KIND=dp), DIMENSION(nx, ny) :: gain
> !!$  REAL(KIND=dp), DIMENSION(nx, nx) :: usa, vsa, sa_inv, sasqp, sasqn, tmp, tmp1, v
> !!$
> !!$  conv = .FALSE. 
> !!$  xa = xap - xold
> !!$  DO i = 1, nx
> !!$     xastd(i) = SQRT(Sa (i, i))
> !!$  ENDDO
> !!$
> !!$
> !!$
> !!$  ! SVD of Sa to calculate Sa^(-1)                       
> !!$  ! NOTE: Sa is square and symmetric: u=v                                 
> !!$  usa = sa
> !!$  CALL dsvdcmp (usa, nx, nx, nx, nx, wsa, vsa) 
> !!$
> !!$  ! Make reciprokal of very small eigenvalues zero: ! replaced with follow
> !!$  wsa_min = 1.d-16
> !!$  wsa_inv = 0.0d0
> !!$  DO i = 1, nx
> !!$     IF (wsa (i) > wsa_min) wsa_inv (i) = 1.0d0 / wsa (i) 
> !!$  ENDDO
> !!$
> !!$  !! Sa^(1/2) = U*W^(1/2)*UT and Sa^(-1/2) = U*W^(-1/2)*UT                 
> !!$  !DO i = 1, nx 
> !!$  !   DO j = 1, nx 
> !!$  !      sasqp (i, j) = SUM ( usa (i, :) * usa (j, :) * SQRT (wsa) )
> !!$  !      sasqn (i, j) = SUM ( usa (i, :) * usa (j, :) * SQRT (wsa_inv) )
> !!$  !   ENDDO
> !!$  !ENDDO
> !!$
> !!$  !!Sa^(-1) = U*W^(-1)*UT
> !!$  sa_inv = MATMUL(MATMUL(usa, wsa_inv), TRANSPOSE(usa))
> !!$
> !!$  ! Sy is not diagonal
> !!$  usy = Sy
> !!$  CALL dsvdcmp (usy, ny, ny, ny, ny, wsy, vsy) 
> !!$  ! Make reciprokal of very small eigenvalues zero: 
> !!$  wsy_inv = 0.0d0
> !!$  DO i = 1, nx
> !!$     IF (wsy (i) > wsa_min) wsy_inv (i) = 1.0d0 / wsy (i) 
> !!$  ENDDO
> !!$  !!Sy^(-1) = U*W^(-1)*UT 
> !!$  sy_inv= MATMUL(MATMUL(usy, wsy_inv), TRANSPOSE(usy))
> !!$
> !!$  ! Construct K*Sa*KT+Sy
> !!$  tmpy = matmul(matmul(rK, sa), transpose(rK)) + Sy
> !!$  uu = tmpy
> !!$  CALL dsvdcmp (uu, ny, ny, ny, ny, wu, vu)
> !!$  wsy_inv = 0.0d0
> !!$  DO i = 1, nx
> !!$     IF (wsy (i) > wsa_min) wsy_inv (i) = 1.0d0 / wu (i) 
> !!$  ENDDO
> !!$  uu_inv = MATMUL(MATMUL(uu, wsy_inv), TRANSPOSE(uu))
> !!$
> !!$  ! Get Gain matrix
> !!$  gain = matmul(matmul(Sa, transpose(rK)), uu_inv)
> !!$
> !!$  ! ACTUAL RETRIEVAL: Calculate x
> !!$  x = xap + matmul(gain, y - matmul(rK, xa))  
> !!$
> !!$  ! Construct Sx=Sa-G*K*Sa
> !!$  Sx = Sa - matmul(matmul(gain, rK), Sa)
> !!$
> !!$  ! Construct rkernel=G*K   
> !!$  rkernel = matmul(gain, rK)                                  
> !!$
> !!$
> !!$  ! Improvement in Chi:                                                   
> !!$  !chi_old = SQRT(SUM( (y / dy) ** 2) / ny)
> !!$  chi_old = SQRT(MATMUL(MATMUL(y, sy_inv), TRANSPOSE(y)) / ny)
> !!$  DO i = 1, ny 
> !!$     ytmp(i) = SUM (rK (i, :) * x )
> !!$  ENDDO
> !!$  !chi_new   =  SQRT (SUM(((y - ytmp) / dy ) **2) / ny)
> !!$  chi_new =  SQRT(MATMUL(MATMUL(y-ytmp, sy_inv), TRANSPOSE(y-ytmp)) / ny)
> !!$  ynew      = y - ytmp
> !!$  delta_chi = ABS ( (chi_new - chi_old) / chi_old) 
> !!$
> !!$  ! Check convergence                                                     
> !!$  IF (delta_chi < delta_chi_min) conv = .TRUE. 
> !!$
> !!$  IF (last_iter .OR. do_oe_output) THEN   
> !!$     ! Construct contribution function: Sx K^T Sy^(-1):                  
> !!$     contr = MATMUL(MATMUL(sx, TRANSPOSE(rk)), sy_inv)
> !!$  ENDIF
> !!$
> !!$  ! Construct retrieval noise covariance matrix: Sx K^T Sy^(-1) K Sx      
> !!$  DO i = 1, ny 
> !!$     DO j = 1, nx 
> !!$        tmp2(i, j) = SUM(rK (i, :) * sx (:, j)) / (dy (i) ** 2)    
> !!$     ENDDO
> !!$  ENDDO
> !!$
> !!$  DO i = 1, nx 
> !!$     DO j = 1, nx 
> !!$        tmp(i, j) =  SUM(rK (:, i) * tmp2 (:, j))
> !!$     ENDDO
> !!$  ENDDO
> !!$
> !!$  DO i = 1, nx 
> !!$     DO j = 1, nx 
> !!$        Sxn(i, j) = SUM(Sx(:, i) * tmp (:, j))
> !!$     ENDDO
> !!$  ENDDO
> !!$  Sxn = matmul(matmul(matmul(matmul(Sx, transpose(rK)), sy_inv), rK), Sx)
> !!$
> !!$
> !!$  ! Degrees of Freedom Noise and Signal, Information content (dfn,dfs,h): 
> !!$  IF (last_iter .OR. do_oe_output) THEN  
> !!$
> !!$     dfn = SUM(1.0d0 / tmpw2p1)
> !!$     h = SUM(0.5d0 * LOG (tmpw2p1) )
> !!$     dfs = nx - dfn 
> !!$
> !!$     ozdfs = 0.0 
> !!$     DO i = sidx, eidx 
> !!$        ozdfs = ozdfs + rkernel (i, i) 
> !!$     ENDDO
> !!$
> !!$     ! need to check for this later        
> !!$     ozinfoh = ozdfs / dfs * h    
> !!$  ENDIF
> !!$
> !!$  !  Level 2 output debug                                                 
> !!$  !  --------------------                                                 
> !!$  IF (do_oe_output) THEN
> !!$     ! chi-square                                                            
> !!$     WRITE (file_unit, '(A, I5)')    'Iteration = ', num_iter 
> !!$     WRITE (file_unit, '(A, D14.6)') 'Old Chi   = ', chi_old 
> !!$     WRITE (file_unit, '(A, D14.6)') 'New Chi   = ', chi_new 
> !!$     WRITE (file_unit, '(A, D14.6, A1,D14.6)') 'Delchi / limit value = ', &
> !!$          delta_chi, '/', delta_chi_min                                  
> !!$
> !!$     ! Degrees of Freedom Noise and Signal, Information content (dfn,dfs,h): 
> !!$     WRITE (file_unit, '(2(A, D14.6))') 'DFN =       ', dfn, ' OZDFN  = ',  (eidx - sidx + 1)  - ozdfs                                   
> !!$     WRITE (file_unit, '(2(A, D14.6))') 'DFS =       ', dfs, ' OZDFS  = ', ozdfs                                                         
> !!$     WRITE (file_unit, '(2(A, D14.6))') 'Information content = ', h,  ' OZINFO = ', ozinfoh                                          
> !!$
> !!$     !! Eigenvalues:                                                          
> !!$     !WRITE(file_unit,'(A)') ' Eigenvalues:'                       
> !!$     !WRITE(file_unit,'(A)') ' columns, points'                    
> !!$     !WRITE(file_unit,'(I3,I5)') 1, nx                               
> !!$     !DO i = 1, nx                                                 
> !!$     !   WRITE(file_unit,'(I3,5D15.7)') i, w(i)                      
> !!$     !ENDDO
> !!$
> !!$     ! A priori and its error and retrieved state and error                                       
> !!$     WRITE (file_unit, '(A6,6A14)') '  Var  ', ' retrieved ', ' noise error', 'smooth error', &
> !!$          'Previous ', ' apriori  ', ' apr. error '  
> !!$
> !!$     DO i = 1, nx 
> !!$        WRITE (file_unit, '(A6, 6D14.6)') xname (i), x (i) + xold (i), SQRT (sxn (i, i) ), &
> !!$             SQRT (Sx (i, i) ), xold (i), xap (i), xastd(i)                                             
> !!$     ENDDO
> !!$
> !!$  ENDIF
> !!$
> !!$  RETURN 
> !!$END SUBROUTINE oe_inversion_new
============================
ozprof_data_module.f90
8,9d7
< 
< 
14c12
<        max_iter, mrefl, maxwin, mflay, max_spec_pts
---
>        max_iter, mrefl, maxwin, mflay, max_spec_pts, mreflcld
17,18c15,16
<        hcho_idx, o2gam_idx, h2o_idx, so2v_idx, bro2_idx, maxoth, maxwfc, shift_offset !, &
< !       o2t2_idx, h2ot2_idx
---
>        hcho_idx, o2_idx, h2o_idx, so2v_idx, bro2_idx, maxoth, maxwfc, &
>        shift_offset, o2t2_idx, h2ot2_idx
152a151
>   LOGICAL :: insert_sfc_layer    ! T: insert a small surface layer of 10 hPa
164c163
<   INTEGER :: nos, nsh, nsl, nrn, ndc, nis, nir, ncm
---
>   INTEGER :: nos, nsh, nsl, nrn, ndc, nis, nir
175,176c174,175
<        rnind, rnfind, dcind, dcfind, isind, isfind, irind, irfind, cmind, cmfind
<   INTEGER, DIMENSION (maxoth, 2)      :: oswins, slwins, shwins, rnwins, dcwins, iswins, irwins, cmwins
---
>        rnind, rnfind, dcind, dcfind, isind, isfind, irind, irfind
>   INTEGER, DIMENSION (maxoth, 2)      :: oswins, slwins, shwins, rnwins, dcwins, iswins, irwins
210c209,212
<   REAL (KIND=dp)            :: measref, simref, salbedo
---
>   REAL (KIND=dp)            :: measref
>    REAL (KIND=dp)           :: pf2ba0, pf2ba1, pf2fc0, pf2fc1
>   LOGICAL                   :: do_alb_longwav, use_prefitalb
>   REAL (KIND=dp)            :: alb_swav, alb_ewav!, cld_swav, cld_ewav
217a220,225
>   ! Number of wavelength for cloud retrieval
>   INTEGER                          :: nreflcld
>   ! wavelengths and spectra in solar/earthshine for cloud retrieval
>   REAL(KIND=dp), DIMENSION(mreflcld) :: rad_posc, rad_spec, sun_posc, sun_specc
> 
> 
233c241
<   INTEGER, PARAMETER                 :: maxawin = 6
---
>   INTEGER, PARAMETER                 :: maxawin = 7
275c283
<   LOGICAL        :: ring_on_line, ring_convol, fit_atanring
---
>   LOGICAL        :: ring_on_line, ring_convol, fit_atanring, ring_LUT
277d284
<  
375c382,383
<   INTEGER, PARAMETER :: ngas = 11, nallgas = 12 
---
>   ! xliu, 10/31/2011, only list gases that can be treated in vlidort
>   INTEGER, PARAMETER :: ngas = 13, nallgas = 14 
378c386,389
<        o2o2_idx, so2_idx, bro_idx, oclo_idx, hcho_idx, o2gam_idx, h2o_idx, so2v_idx, bro2_idx/)  
---
>        o2o2_idx, so2_idx, bro_idx, oclo_idx, hcho_idx, o2_idx, h2o_idx, so2v_idx, &
>        bro2_idx, o2t2_idx, h2ot2_idx/)  
>   LOGICAL, DIMENSION(max_rs_idx)              :: rtm_treatment   ! included in RTM calculation
> 
402c413
<   INTEGER, PARAMETER :: mxsect    = 5
---
>   INTEGER, PARAMETER :: mxsect    = 12 !5
423d433
< 
438c448
<   REAL(KIND=dp)  ::which_tpres ! option for tropopause height data (Ncep or AIRS)
---
>   REAL(KIND=dp)  :: which_tpres ! option for tropopause height data (Ncep or AIRS)
440,452c450,456
< END MODULE ozprof_data_module
< 
< 
< 
< MODULE ring_data_module
<    USE OMSAO_precision_module
<    USE OMSAO_parameters_module, ONLY :  maxlay
<    IMPLICIT NONE
<    INTEGER, PARAMETER :: maxnu = 15000
<    INTEGER :: nuhi, nulo, nu
<    REAL (KIND=dp) :: avgt, cosvza, cossza
<    REAL (KIND=dp), DIMENSION(maxnu, maxlay)    :: st, vt
<    REAL (KIND=dp), DIMENSION(maxnu)            :: ring
---
>   ! ---------------------------------------------------------
>   ! Measurement error matrix 
>   ! ---------------------------------------------------------    
>   REAL(KIND=dp)                          :: merr_corrlen   ! systematic error correlation lenth (nm)
>   REAL(KIND=dp), dimension(max_fit_pts)  :: msyserr        ! systematic error
>   LOGICAL                                :: do_sy_diagonal
>   REAL(KIND=dp), DIMENSION(max_fit_pts, max_fit_pts) :: merr_covar 
454c458
< END MODULE ring_data_module
---
> END MODULE ozprof_data_module
============================
ozprof_inverse.f90
49,50c49,51
<        ozwrtcontri, update_o3, update_sao3, which_toz, the_ai
<   USE OMSAO_variables_module,   ONLY: fitvar_rad,fitvar_rad_str, mask_fitvar_rad, epsrel,                  &
---
>        ozwrtcontri, update_o3, update_sao3, which_toz, ring_LUT, merr_covar,     &
>        do_sy_diagonal
>   USE OMSAO_variables_module,   ONLY: fitvar_rad, mask_fitvar_rad, epsrel,                  &
91c92
<        nradrms, oradrms, readout_noise
---
>        nradrms, oradrms, readout_noise, syssig, corrlen
94a96
>   REAL (KIND=dp), DIMENSION(ns, ns)   :: Sy
103c105
<   
---
> 
105,109c107,111
<   LOGICAL                             :: adjust_merr
<   INTEGER, PARAMETER                  :: nreg = 5
<   INTEGER, DIMENSION(nreg)            :: regfidxs, reglidxs, regnpts
<   REAL (KIND=dp), DIMENSION(nreg)     :: reg_rms, reg_res
<   REAL (KIND=dp), DIMENSION(0:nreg)   :: reg_waves = &
---
>   LOGICAL                           :: adjust_merr
>   INTEGER, PARAMETER                :: nreg = 5
>   INTEGER, DIMENSION(nreg)          :: regfidxs, reglidxs, regnpts
>   REAL (KIND=dp), DIMENSION(nreg)   :: reg_rms, reg_res
>   REAL (KIND=dp), DIMENSION(0:nreg) :: reg_waves = &
111c113
<   CHARACTER (Len=3) :: chaidx
---
> 
115a118
> 
130c133
<      
---
> 
142c145
<         ENDIF        
---
>         ENDIF
153d155
< 
161c163
<   
---
> 
177c179,185
<  
---
> 
>   ! constract Sy, Sy = S_rnd + S_sys, S_rnd is diagonal, represented by measurements noise,
>   ! S_sys is square, symetric, represented by sig^2*exp(-(lambda1-lambda2)/h)  
>   IF (.NOT. do_sy_diagonal) THEN
>      Sy = merr_covar(1:ns, 1:ns)
>   ENDIF
> 
180,182c188,197
<      CALL GET_RAMAN(nlay, fitvar_rad(pfidx:plidx), errstat)
<      IF (errstat == pge_errstat_error) THEN
<         exval = -4; RETURN
---
>      IF (ring_LUT) THEN
>         CALL GET_RAMAN_LUT(nlay, fitvar_rad(pfidx:plidx), errstat)
>         IF (errstat == pge_errstat_error) THEN
>            exval = -4; RETURN
>         ENDIF
>      ELSE
>         CALL GET_RAMAN(nlay, fitvar_rad(pfidx:plidx), errstat)
>         IF (errstat == pge_errstat_error) THEN
>            exval = -4; RETURN
>         ENDIF
185c200
<  
---
> 
198c213
<  
---
> 
201d215
<      ! fitweights are corrected in pseudo_model Jbak
204d217
< 
212c225,230
<      xold = fitvar 
---
>      IF (.NOT. do_sy_diagonal) THEN
>         DO i = 1, nf  
>            dyda(:, i) = dyda(:, i) * fitweights(1:ns)
>         END DO
>         gspec(1:ns) = gspec(1:ns) * fitweights(1:ns)
>      ENDIF
213a232
>      xold = fitvar 
236c255
<       
---
> 
240,246c259,270
<            IF (.NOT. do_twostep) THEN 
<                         
<               CALL oe_inversion (do_sa_diagonal, ozwrtint, ozwrtint_unit, epsrel,        &
<                    last_iter, num_iter, ns, nf, gspec, sig, dyda, xap, xold, sa, &
<                    varname, ffidx, flidx, delta_x, covar(1:nf, 1:nf), ncovar(1:nf, 1:nf),&
<                    conv, avg_kernel(1:nf, 1:nf), contri(1:nf, 1:ns), ozdfs, ozinfo, lchisq, gspec_new)
<                 
---
>            IF (.NOT. do_twostep) THEN
>               IF (.NOT. do_sy_diagonal) THEN
>                  CALL oe_inversion_y (do_sa_diagonal, ozwrtint, ozwrtint_unit, epsrel,        &
>                       last_iter, num_iter, ns, nf, gspec, Sy, dyda, xap, xold, sa, &
>                       varname, ffidx, flidx, delta_x, covar(1:nf, 1:nf), ncovar(1:nf, 1:nf),&
>                       conv, avg_kernel(1:nf, 1:nf), contri(1:nf, 1:ns), ozdfs, ozinfo, lchisq, gspec_new) 
>               ELSE
>                  CALL oe_inversion (do_sa_diagonal, ozwrtint, ozwrtint_unit, epsrel,        &
>                       last_iter, num_iter, ns, nf, gspec, sig, dyda, xap, xold, sa, &
>                       varname, ffidx, flidx, delta_x, covar(1:nf, 1:nf), ncovar(1:nf, 1:nf),&
>                       conv, avg_kernel(1:nf, 1:nf), contri(1:nf, 1:ns), ozdfs, ozinfo, lchisq, gspec_new)
>               ENDIF
259,260c283
<           
<          !      print * , fitvar_rad_str(mask_fitvar_rad(30)), xold(30), xold(30) + delta_x(30)
---
> 
264,270d286
<            !DO i = 1, ns
<            !   WRITE(90, '(4D14.6)') fitwavs(i), fitspec(i), simrad(i), fitres(i)
<            !ENDDO
<            
<            ! Ring effect, assume ring effect last variable, one single band
<            !!gspec(1:ns) = gspec(1:ns) - dyda(1:ns, nf) * delta_x(nf) 
<            print * , 'remove effect in ozprof_inverse'
272,278c288,292
<            DO i = 1, nf
<              READ(fitvar_rad_str(mask_fitvar_rad(i)), '(a3)') chaidx
<              !print * , chaidx, delta_x(i)+xold(i), delta_x(i)
<              IF (chaidx == 'rin' .or. chaidx =='shi' .or. chaidx =='ozs' ) THEN 
<                  gspec(1:ns) = gspec(1:ns) - dyda(1:ns,i) * delta_x(i)   
<              ENDIF 
<            ENDDO
---
>            ! Ring effect, assume ring effect last variable, one single band
>            ! last two variables if using two bands
>            gspec(1:ns) = gspec(1:ns) - dyda(1:ns, nf) * delta_x(nf)  
>            !gspec(1:ns) = gspec(1:ns) - dyda(1:ns, 2) * delta_x(2)
>            !gspec(1:ns) = gspec(1:ns) - dyda(1:ns, nf-1) * delta_x(nf-1)   
282,286c296,299
<            fitres(1:ns) = gspec(1:ns) * fitweights(1:ns)     
<            fitspec(1:ns)= fitres(1:ns) + simrad(1:ns)
<            the_ai = the_ai*(delta_x(albfidx+1) + xold(albfidx+1))
<            exval = 0 ; RETURN
<            proceed = .FALSE.          
---
>            fitres(1:ns) = gspec(1:ns) * fitweights(1:ns)
>            fitspec(1:ns) = fitres(1:ns) + simrad(1:ns)
>            fitvar = delta_x + xold
>            exval = 0; RETURN
293c306
<         
---
> 
303c316
<         
---
> 
318c331
<      
---
> 
340c353
<       
---
> 
353c366
<         ENDIF        
---
>         ENDIF
376c389
< !     IF ((conv .OR. varconv)) THEN
---
>      !     IF ((conv .OR. varconv)) THEN
384,386c397,407
<         CALL GET_RAMAN(nlay, fitvar_rad(pfidx:plidx), errstat) 
<         IF (errstat == pge_errstat_error) THEN 
<            exval = -4; proceed = .FALSE.
---
>         !IF (ring_on_line ) THEN
>         IF (ring_LUT) THEN
>            CALL GET_RAMAN_LUT(nlay, fitvar_rad(pfidx:plidx), errstat)
>            IF (errstat == pge_errstat_error) THEN
>               exval = -4; RETURN
>            ENDIF
>         ELSE 
>            CALL GET_RAMAN(nlay, fitvar_rad(pfidx:plidx), errstat) 
>            IF (errstat == pge_errstat_error) THEN 
>               exval = -4; proceed = .FALSE.
>            ENDIF
389d409
< 
406c426
<         ENDIF        
---
>         ENDIF
408c428,429
<  
---
> 
> 
412,418c433,437
<        
<      IF ( use_oe == .TRUE. .and. do_twostep == .False. .and. num_iter == 1) THEN 
<        IF ( update_o3 == .TRUE. .or. update_sao3 ==.TRUE. .and. which_toz /= 0) THEN 
<          print * , 'Update apriori information based on retrieved total o3'
<          CALL update_o3_sao3 ( fitvar(ffidx:flidx), fitvarap(ffidx:flidx), sa(ffidx:flidx,ffidx:flidx ))
<          
<        ENDIF
---
>      IF ( use_oe == .TRUE. .AND. do_twostep == .FALSE. .AND. num_iter == 1) THEN 
>         IF ( update_o3 == .TRUE. .OR. update_sao3 ==.TRUE. .AND. which_toz /= 0) THEN 
>            !print * , 'Update apriori information based on retrieved total O3'
>            CALL update_o3_sao3 ( fitvar(ffidx:flidx), fitvarap(ffidx:flidx), sa(ffidx:flidx,ffidx:flidx ))         
>         ENDIF
420d438
< 
444d461
<   
447c464
<   
---
> 
455d471
<          
472c488
<        
---
> 
507c523
<         
---
> 
511c527
<         
---
> 
531,535d546
<         do i = ffidx, flidx
<           if ( (fitvar(i) <= lowbnd(i)) .or.  (fitvar(i) >= upbnd(i)) )  then
<                print *,i, fitvar(i), lowbnd(i), upbnd(i)
<           endif
<         enddo
550c561,572
<     
---
>      IF (.NOT. do_sy_diagonal) THEN
>         DO i = 1, nf  
>            weight_function(1:ns, i) = dyda(1:ns, i) 
>         ENDDO
> 
>      ELSE
>         DO i = 1, nf  
>            weight_function(1:ns, i) = dyda(1:ns, i) * fitweights(1:ns)
>         ENDDO
>      ENDIF
>   ENDIF
>   IF (.NOT. do_sy_diagonal) THEN
552c574,578
<         weight_function(1:ns, i) = dyda(1:ns, i) * fitweights(1:ns)
---
>         contri(i, 1:ns) = contri(i, 1:ns) 
>      ENDDO
>   ELSE
>      DO i = 1, nf  
>         contri(i, 1:ns) = contri(i, 1:ns) / fitweights(1:ns)
555,559d580
< 
<   DO i = 1, nf  
<      contri(i, 1:ns) = contri(i, 1:ns) / fitweights(1:ns)
<   ENDDO
< 
570c591
<       
---
> 
601d621
<      return
604c624
<      
---
> 
645,647d664
< 
< 
< 
689,690c706,707
<   IF (which_clima == 5 ) then
<       toz = sum(first_oz) -ozone_above60km 
---
>   IF (which_clima == 5 ) THEN
>       toz = SUM(first_oz) -ozone_above60km 
692c709
<   ELSE IF ( which_clima == 6) then 
---
>   ELSE IF ( which_clima == 6) THEN 
738c755
<             WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat; stop
---
>             WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat; STOP
767c784
<          WRITE(*, *) modulename, ': BSPLINE error 1, errstat = ', errstat ; stop
---
>          WRITE(*, *) modulename, ': BSPLINE error 1, errstat = ', errstat ; STOP
793c810
<   IF (update_sao3 == .TRUE. .and. which_aperr == 5) THEN
---
>   IF (update_sao3 == .TRUE. .AND. which_aperr == 5) THEN
795c812
<      call get_apriori_covar(toz, ozprof, sao3)
---
>      CALL get_apriori_covar(toz, ozprof, sao3)
841c858
<   LOGICAL                                         :: first = .true.
---
>   LOGICAL                                         :: first = .TRUE.
874c891
<            CALl REVERSE(ozs(1:nz), nz)
---
>            CALL REVERSE(ozs(1:nz), nz)
918,919d934
< 
< 
============================
prepare_atmosphere.f90
6d5
<   ! adding : ML (2011), TB (2012), TJ(2013), MLS daily (2016), OMI daily (2016)  climaotlogy by jbak
9,84c8
< 
< SUBROUTINE get_omiprof (ozref)
<   
<   USE OMSAO_precision_module 
<   USE ozprof_data_module,     ONLY: atmos_unit, trpz,which_clima
<   USE OMSAO_variables_module, ONLY: atmdbdir,the_lon, the_lat, raddate
<   IMPLICIT NONE
<   ! ======================
<   ! Input/Output variables
<   ! ======================
<   INTEGER, PARAMETER                             ::  nref = 60
<   REAL (KIND=dp), DIMENSION(nref), INTENT(OUT)   ::  ozref
< 
<   ! ======================
<   ! Local variables
<   ! ======================
<   INTEGER, PARAMETER :: nlon=72, nlat=36, nlay=60   ! 5x5
<   !INTEGER, PARAMETER :: nlon=180, nlat=90, nlay=60 ! 2x2
<   REAL (KIND=dp), PARAMETER   ::  lon0=-180.0, lat0=-90.0
<   INTEGER :: i, j,k, tmpc
<   INTEGER :: nblon, nblat, lonin(2), latin(2)
<   REAL (KIND=dp) :: lonfrac(2), latfrac(2)
<   REAL (KIND=dp) :: tmpsum , ozprof(nlay), ozprof_AB(nlay), tmpprof(nlay)
<   
<   LOGICAL,      SAVE   :: first=.true.
<   REAL (KIND=dp), SAVE :: longrid, latgrid
<   REAL (KIND=dp), SAVE :: lon (nlon), lat(nlat), refp(nlay+1)
<   REAL (KIND=dp), SAVE :: ozrefs(nlon, nlat, nlay)
<   CHARACTER (LEN=160)  :: apfname
< 
<   IF (first) THEN
<      apfname = TRIM(ADJUSTL(atmdbdir)) // 'OMO3P/' //'OMIO3PROF_'//TRIM(ADJUSTL(raddate))//'_05x05.txt'
<      OPEN (UNIT = atmos_unit, file = apfname, status = 'unknown')
<      READ (atmos_unit,*)
<      READ (atmos_unit,*) lon
<      READ (atmos_unit,*) lat
<      READ (atmos_unit,*) refp
<      READ (atmos_unit, '(60f10.3)') ((ozrefs( i,j,:), j=1, nlat), i=1, nlon)
<      CLOSE (atmos_unit)
<      longrid = abs(lon(1) - lon(2))
<      latgrid = abs(lat(1) - lat(2))
<      first = .FALSE.
<   ENDIf
< 
<   call get_gridfrac(nlon, nlat, longrid, latgrid, lon0, lat0, &
<        the_lon, the_lat, nblon, nblat, lonfrac, latfrac, lonin, latin)
< 
<   call get_ab( ozprof_ab, tmpprof, 1)
< 
<   ozprof(:) = -999
<  DO k = 1, nlay
<   DO i = 1, nblon 
<     DO j = 1, nblat
<            IF ( i ==1 .and. j ==1 ) THEN 
<               tmpsum = 0.0 ; tmpc = 0
<            ENDIF
<            IF (ozrefs(lonin(i),latin(j),k) >  0 ) THEN 
<              tmpsum = tmpsum + ozrefs(lonin(i),latin(j),k)*lonfrac(i)*latfrac(j)         
<              tmpc = tmpc + 1
<            ENDIF       
<            IF (tmpc == nblon + nblat) THEN 
<               ozprof(k) = tmpsum
<            ELSE
<               ozprof(k) = ozprof_ab(k)
<            ENDIF
<        ENDDO
<     ENDDO
<   ENDDO 
<   ozref = ozprof
<  ! print * , 'get omi profile'
<   !print * , ozref, sum(ozref)
< 
< return
< END SUBROUTINE
< 
< ! =====================================================================
---
> ! ===============================================================
88,89c12,15
< ! And then merging with ML rofile for upper stratosphere
< !                  with AB profile for lower tropopshere
---
> ! And then merging with LLM profile 
> ! ** variable shift region    between tropz - 5 km and tropz + 5 km
> ! ** merging with LLM region  between tropz+5km and tropz+10 km
> ! ** LLM                      above tropz + 10 km 
91,93c17,19
< ! ======================================================================
< SUBROUTINE get_tbprof (ozref, out_prof)
< 
---
> ! ===============================================================
> SUBROUTINE get_tbprof (ozref)
>   
95c21
<   USE ozprof_data_module,     ONLY: atmos_unit, trpz,which_clima, which_aperr
---
>   USE ozprof_data_module,     ONLY: atmos_unit, trpz,which_clima
98c24
< 
---
>   
103d28
<   INTEGER, INTENT(IN)                            ::  out_prof ! 1 = ozref 2 = std 
105c30
< 
---
>   
109,147c34,40
<   INTEGER :: i, which_is
<   REAL (KIND=dp), DIMENSION(nref):: ozref1, ozref2, llm,ml,ab, tmp, refz
<   REAL (KIND=dp)                 :: weight, weight1, weight2, meg, trpz1, trpz2,  del1, del2, meg1, meg2
< 
<   trpz1 = 14 ; trpz2  = 14
<   del1   = 1 ; del2   = 5  ! TB weight = 1   for trpz - del2 to trpz + del1 at trpopause region 
<   meg1   = 1 ; meg2   = 1  ! TB weight = 0~1 for trpz - del2 to trpz - del2 - meg2
<                            !                 for trpz - del1 to trpz - del1 - meg1
< 
<  if ( trpz >= 15 ) then 
<       del1 = 1 ; del2 = 5
<       meg1 = 1 ; meg2 = 1
<  endif
< 
< 
<  IF (out_prof == 1 ) THEN 
<    !CALL get_mcprof(llm)
<    CAll get_mlprof(llm, 1)
<    call get_tb (ozref1, tmp,1)     ! extra
<    call get_tb (ozref2, tmp,2)     ! tropics
<    call get_ab (AB, tmp,1) 
<    refz(1:nref) = (/(i*1.0+0.5, i = 0, nref-1 )/)
<  ELSE IF (out_prof == 2) THEN
<     CAll get_mlprof(llm, 2)
<     call get_tb (tmp,ozref1,1)  
<     call get_tb (tmp,ozref2,2) 
<     call get_ab (tmp, AB,1)   
<    refz(1:nref) = (/(i*1.0+0.5, i= nref-1, 0,-1 )/)
<  ENDIF
< 
< ! Vertical mixing. 
< DO i = 1, nref
<    weight1 = 1-(abs( refz(i) - trpz )-del1)/(meg1)
<    weight2 = 1-(abs( refz(i) - trpz )-del2)/(meg2)
<   if ( weight1 < 0 )  weight1 = 0
<   if ( weight1 > 1 )  weight1 = 1
<   if ( weight2 < 0 )  weight2 = 0
<   if ( weight2 > 1 )  weight2 = 1
<  
---
>   REAL (KIND=dp), DIMENSION(nref):: ozref1, ozref2, llm, tmp, refz
>   REAL (KIND=dp)                 :: weight, meg1, meg2, trpz1, trpz2
>   INTEGER :: i,which_offset
>   trpz1 = 13   ! lower limit of smoothing  
>   trpz2 = 15   ! upper limit of smoothing 
>   meg1   = 5    ! lower limit of vertical mixing 
>   meg2   = 10 ! upper limit of vertical mixing 
149,155c42,54
<   IF ( refz(i) >= trpz ) then ! stratosphere
<        ozref1(i) = ozref1(i)*weight1 +LLM(i)*(1-weight1)
<        ozref2(i) = ozref2(i)*weight1 +LLM(i)*(1-weight1)
<   endif
<   if ( refz(i) < trpz ) then  ! troposphere
<        ozref1(i) = ozref1(i)*weight2 +AB(i)*(1-weight2)
<        ozref2(i) = ozref2(i)*weight2 +AB(i)*(1-weight2)   
---
>   refz(1:nref) = (/(i*1.0, i= 0, 59 )/)
>   
>   ! Load basic clima 
>   CALL get_mcprof(llm)
>   
>   IF (which_clima == 4) then 
>      call get_AB (ozref,tmp, 1)
>      ! 1 = loading ABall clima 
>      ! 2 = loading AB14  clima 
>   ELSE IF (which_clima == 3 ) THEN   
>      call get_tb (ozref1, tmp,1)   ! loading TB extratropical clima 
>      call get_tb (ozref2, tmp,2)   ! loading TB tropical clima
>      !  call get_ab (ozref2, tmp,2)    
157,161c56,85
<    !  write(*,'(10f8.2)') refz(i),refz(i)-trpz,weight1, weight2,ozref2(i),llm(i), ab(i)
< ENDDO 
< ! spatial merging 
<     weight = (trpz2-trpz)/(trpz2-trpz1)
<     if (trpz <= trpz1) then  !100 % TB
---
>   
>   ! Vertical mixing. 
>   DO i = 1, nref
>      weight = 1-(abs( refz(i) - trpz )-meg1)/(meg2-meg1)
>      if ( abs(refz(i) - trpz) > meg2  ) then 
>         weight = 0 ! 100% LLM 
>      else if ( abs(refz(i) - trpz) <= meg1 ) then
>         weight = 1 ! 100% TB
>      endif
>      
>      IF ( refz(i) >= trpz ) then 
>         IF ( which_clima == 4 ) then 
>            ozref(i) = ozref(i)*weight +LLM(i)*(1-weight)
>         elseif ( which_clima == 3 ) then 
>            ozref1(i) = ozref1(i)*weight +LLM(i)*(1-weight)
>            ozref2(i) = ozref2(i)*weight +LLM(i)*(1-weight)
>         ENDIF
>      endif
>      ! if ( which_clima == 3 .and. refz(i) < 5 ) then 
>      !     weight    = (5.-refz(i))/5.
>      !     ozref1(i) = ozref1(i)*weight +LLM(i)*(1-weight)
>      !     ozref2(i) = ozref2(i)*weight +LLM(i)*(1-weight)
>      !    
>      ! ENDIF
>   ENDDO
>   
>   ! spatial mixing
>   IF ( which_clima == 3 ) then 
>      weight = (trpz2-trpz)/(trpz2-trpz1)
>      if (trpz <= trpz1) then  !100 % TB extratropical
163c87
<     else if (trpz > trpz2) then !100 % AB
---
>      else if (trpz > trpz2) then !100 % TB tropical 
165,168c89,94
<     endif   
<     ozref(:) = ozref1(:)*weight + ozref2(:)*(1-weight) !TB1
< 
< IF (any(ozref(:) < 0)) then ; print * , 'error at get_tbprof' ; stop ; ENDIF
---
>      endif
>      ozref(:) = ozref1(:)*weight + ozref2(:)*(1-weight)
>      write(*,'(6(a7,f6.2), f6.2)') 'LAT:', the_lat, 'TPH', trpz,'=TBx', weight
>   ENDIF
>   
>   IF (any(ozref(:) < 0)) then ; print * , 'error at get_tbprof' ; stop ; ENDIF
179,191c105,117
< ! ===============================================================
< 
< SUBROUTINE get_tb(ozref,std, which_tb)
< 
<   USE OMSAO_precision_module 
<   USE ozprof_data_module,     ONLY: atmos_unit, trpz, mzt
<   USE OMSAO_variables_module, ONLY: atmdbdir, the_month, the_day, the_lat
<   IMPLICIT NONE
< 
<   ! ======================
<   ! Input/Output variables
<   ! ======================
<   INTEGER, PARAMETER                             ::  nref = 60
---
> ! ===============================================================
> 
> SUBROUTINE get_tb(ozref,std,which_tb)
>   
>   USE OMSAO_precision_module 
>   USE ozprof_data_module,     ONLY: atmos_unit, trpz, mzt
>   USE OMSAO_variables_module, ONLY: atmdbdir, the_month, the_day, the_lat
>   IMPLICIT NONE
>   
>   ! ======================
>   ! Input/Output variables
>   ! ======================
>   INTEGER, PARAMETER                             ::  nref = 60
193c119
<   REAL (KIND=dp), DIMENSION(nref), INTENT(OUT)   ::  ozref,std
---
>   REAL (KIND=dp), DIMENSION(nref), INTENT(OUT)   ::  ozref,std
195,199c121,125
<   ! ======================
<   ! Local variables
<   ! ======================
<   CHARACTER (LEN=130)           :: apfname
< 
---
>   ! ======================
>   ! Local variables
>   ! ======================
>   CHARACTER (LEN=130)           :: apfname
> 
201,215c127,140
<   REAL (KIND=dp), PARAMETER         :: lat0=-90., latgrid=10.
<   REAL (KIND=dp), DIMENSION(nlay)   :: ozref0,std0 ! orignal profile
<   REAL (KIND=dp), DIMENSION(0:nlay) :: cum0,cums0, refz0, zstar, tb0
<   REAL (KIND=dp), DIMENSION(0:nref) :: cum,cums,refz, offset, tb
< 
<   INTEGER                           :: i, j, k,fidx, lidx, nband, nm, errstat
<   INTEGER, DIMENSION(2)             :: latin, monin
<   REAL (KIND=dp)                    :: frac,fdum
<   REAL (KIND=dp), DIMENSION(2)      :: latfrac, monfrac
<   REAL (KIND=dp)                    :: meg
<   REAL (KIND=dp)                    :: gravity_correct ! used for converting unit
< 
< 
<   LOGICAL, SAVE                     :: first = .TRUE.
<   REAL (KIND=dp), SAVE, DIMENSION(nmon, nlat, nlay) ::ozrefs,ozrefs1, ozrefs2
---
>   REAL (KIND=dp), DIMENSION(nlay)   :: ozref0,std0 ! orignal profile
>   REAL (KIND=dp), DIMENSION(0:nlay) :: cum0,cums0, refz0, zstar, tb0
>   REAL (KIND=dp), DIMENSION(0:nref) :: cum,cums,refz, offset, tb
> 
>   INTEGER                           :: i, j, k, nband, nm, errstat
>   INTEGER, DIMENSION(2)             :: latin, monin
>   REAL (KIND=dp)                    :: frac,fdum
>   REAL (KIND=dp), DIMENSION(2)      :: latfrac, monfrac
>   REAL (KIND=dp)                    :: meg
>   REAL (KIND=dp)                    :: gravity_correct ! used for converting unit
> 
> 
>   LOGICAL, SAVE                     :: first = .TRUE.
>   REAL (KIND=dp), SAVE, DIMENSION(nmon, nlat, nlay) ::ozrefs,ozrefs1, ozrefs2
218,237c143,164
<   REAL (KIND=dp), SAVE, DIMENSION(nlat)             ::lats
<   REAL (KIND=dp), SAVE, DIMENSION(nlay) :: z0
< 
<   ! ==============================
<   ! Name of this module/subroutine
<   ! ==============================
<   CHARACTER (LEN=17), PARAMETER :: modulename = 'get_TB_VS_OZ' 
< 
< ! ** load oz profiles ** !
<   IF (first) THEN
<           
<         apfname = '../../ATMOS/tbclima/TB14L-5.vs' ! jbak
< 
<         OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
<         READ (atmos_unit, '(A)') ;  READ(atmos_unit, '(A)')             
<         DO i = 1, nmon
<           DO j = nlat, 1, -1
<            READ(atmos_unit, *) fdum, lats(j), mtropz1(i,j) ! nsample, lat, mean ztrop
<            READ(atmos_unit, *) (z0(k), ozrefs1(i, j, k),stds1(i, j, k), k = nlay, 1, -1) ! ppb                      
<           ENDDO
---
>   REAL (KIND=dp), SAVE, DIMENSION(nlat) :: lats
>   REAL (KIND=dp), SAVE, DIMENSION(nlay) :: z0
> 
>   ! ==============================
>   ! Name of this module/subroutine
>   ! ==============================
>   CHARACTER (LEN=17), PARAMETER :: modulename = 'get_TB_VS_OZ' 
>   
>   ! ** load oz profiles ** !
>   IF (first) THEN
>      
>      apfname = TRIM(ADJUSTL(atmdbdir)) // 'tbclima/TB14L-5.vs' ! jbak
>      
>      OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
>      READ (atmos_unit, '(A)') ;  READ(atmos_unit, '(A)')             
>      DO i = 1, nmon
>         DO j = nlat, 1, -1
>            READ(atmos_unit, *) fdum, lats(j),mtropz1(i,j) 
>            DO k = nlay, 1, -1
>               READ(atmos_unit, *) z0(k), ozrefs1(i, j, k),stds1(i, j, k) ! ppb                      
>            ENDDO
>                   !  write(*,'(i5,f5.0, 10f9.4)') j, lats(j), ozrefs(i,j,10:18) 
239c166,167
<         CLOSE(atmos_unit)
---
>         ENDDO
>         CLOSE(atmos_unit)   
241,246c169,174
<         apfname = '../../ATMOS/tbclima/TB14H-5.vs' ! jbak
< 
<         OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
<         READ (atmos_unit, '(A)') ;  READ(atmos_unit, '(A)')             
<         DO i = 1, nmon
<           DO j = nlat, 1, -1
---
>         apfname = TRIM(ADJUSTL(atmdbdir)) // 'tbclima/TB14H-5.vs' ! jbak
> 
>         OPEN (UNIT = atmos_unit, file=apfname, status = 'unknown')
>         READ (atmos_unit, '(A)') ;  READ(atmos_unit, '(A)')             
>         DO i = 1, nmon
>         DO j = nlat, 1, -1
248,249c176,180
<            READ(atmos_unit, *) (z0(k), ozrefs2(i, j, k),stds2(i, j, k), k = nlay, 1, -1) ! ppb                      
<          ENDDO
---
>            DO k = nlay, 1, -1
>               READ(atmos_unit, *) z0(k), ozrefs2(i, j, k),stds2(i, j, k) ! ppb                      
>            ENDDO
>                   !  write(*,'(i5,f5.0, 10f9.4)') j, lats(j), ozrefs(i,j,10:18) 
>         ENDDO
252,261d182
<        
<         ! extratropical TB: fill 5, 15, 25 
<         fidx=minval(minloc(lats,mask = (lats(1:nlat) < 35 .and. lats(1:nlat) > 0)))
<         lidx=minval(maxloc(lats,mask = (lats(1:nlat) < 35 .and. lats(1:nlat) > 0)))
<         
<         DO i = fidx, lidx
<           ozrefs1(:,i, :) =ozrefs1(:, lidx+1, :)
<           stds1(:, i, :)  =stds1(:, lidx+1, :)
<           mtropz1(:,i)    =mtropz1(:,lidx+1)
<         ENDDO   
263,273c184,194
<         fidx=minval(minloc(lats,mask = (lats(1:nlat) < 0 .and. lats(1:nlat) > -35 )))
<         lidx=minval(maxloc(lats,mask = (lats(1:nlat) < 0 .and. lats(1:nlat) > -35)))
<         
<         DO i = fidx, lidx
<           ozrefs1(:,i, :) =ozrefs1(:, fidx-1, :)
<           stds1(:, i, :)  =stds1(:, fidx-1, :)
<           mtropz1(:,i)    =mtropz1(:,fidx-1)
<         ENDDO   
<       
<   
<         ! tropical TB: fill -85~-35 with -25, fill 35~85 with 35
---
>            ! fill abs(lat) <=25 with 35N/s
>         DO j = 1, 3
>               ozrefs1(:, j+9, :) =ozrefs1(:, 13, :)
>               stds1(:, j+9, :)   =stds1(:, 13, :)
>               mtropz1(:,j+9)     =mtropz1(:,13)
>               ozrefs1(:, j+6, :)   =ozrefs1(:, 6, :)
>               stds1(:, j+6, :)     =stds1(:, 6, :)
>               mtropz1(:,j+6)       =mtropz1(:,6)
>         ENDDO
>            ! fill lat <= - 35 with - 25
>            ! fill lat >= 35   with 25 or 35 depending on month
277c198
<               mtropz2(:,j)     =mtropz2(:,7)               
---
>               mtropz2(:,j)     =mtropz2(:,7)
279,281c200,206
<               ozrefs2(:, j+12, :)   =ozrefs1(:, 13, :) ! at 35
<               stds2(:, j+12, :)     =stds2(:, 13, :)
<               mtropz2(:,j+12)       =mtropz2(:,13)
---
>               ozrefs2(1:5, j+12, :)   =ozrefs1(1:5, 12, :) ! at 25
>               stds2(1:5, j+12, :)     =stds2(1:5, 12, :)
>               mtropz2(1:5,j+12)       =mtropz2(1:5,12)
> 
>               ozrefs2(5:12, j+12, :)   =ozrefs1(5:12, 13, :) ! at 35
>               stds2(5:12, j+12, :)     =stds2(5:12, 13, :)
>               mtropz2(5:12,j+12)       =mtropz2(5:12,13)
283,284c208,209
<         IF (any(ozrefs1 < 0) .or. any(ozrefs <0) ) then
<            print *, 'TB clima contain -999'  ; stop          
---
>         IF (any(ozrefs1 < 0) .or. any(ozrefs2 < 0)) then
>            print *, 'TB clima contain -999'
286,287c211,212
<         first = .FALSE.
< ENDIF
---
>         first = .FALSE.
>  ENDIF
295a221,235
> ! ** interpolation for lat, mon** ! 
>   IF (the_day <= 15) THEN
>      monin(1) = the_month - 1
>      IF (monin(1) == 0) monin(1) = 12
>      monin(2) = the_month
>      monfrac(1) = (15.0 - the_day) / 30.0
>      monfrac(2) = 1.0 - monfrac(1)
>   ELSE 
>      monin(2) = the_month + 1
>      IF (monin(2) == 13) monin(2) = 1
>      monin(1) = the_month
>      monfrac(2) = (the_day - 15) / 30.0
>      monfrac(1) = 1.0 - monfrac(2)
>   ENDIF
>   nm = 2
297,299c237,245
< ! ** interpolation for lat, mon** ! 
<   CALL get_monfrac(nmon, the_month, the_day, nm, monfrac, monin)
<   CALL get_latfrac(nlat,latgrid, lat0,the_lat, nband, latfrac, latin)
---
>   IF (the_lat <= -85.0) THEN
>         nband = 1; latin(1) = 1; latfrac(1) = 1.0
>   ELSE IF (the_lat >= 85.0) THEN
>         nband = 1; latin(1) = nlat; latfrac(1) = 1.0
>   ELSE
>         nband = 2     ; frac = (the_lat + 85.0) / 10.0 + 1
>         latin(1) = INT(frac); latin(2) = latin(1) + 1
>         latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>   ENDIF
301,320c247,265
<  
<   ozref0 =0.0 ; std0 = 0.0 ; mzt = 0.0
<   DO i = 1, nband
<         DO j = 1, nm
<             ozref0 =  ozref0+ ozrefs(monin(j), latin(i), :) * monfrac(j) * latfrac(i)
<             std0   =  std0+ stds(monin(j), latin(i), :) * monfrac(j) * latfrac(i)
<             mzt    =  mzt+mtropz(monin(j), latin(i)) * monfrac(j) * latfrac(i)
<         ENDDO
<   ENDDO
< 
< !** convert tb reference into regular reference
< !   zs0 = [ -20, 60] is data grid
< !   tb  = reg - offset 
< !   reg = tb + offset 
< !   offset = (tropz - mzt)*(1-|reg(i)-tropz|/5)+mzt
< !   reg(i) = tb(i) +tropz+(mtz-tropz)|reg(i)-tropz|/5   
< !   convert PPB to DU [ here, just use constant shift ]
<   tb0(0:nlay-1)   = z0-0.5 ; tb0(nlay)= 60 
<   refz0(0:nlay)   = tb0(0:nlay)+trpz
<   zstar(0:nlay)   = 1.0/(10**((refz0)/16.0))
---
>   ozref0 =0.0 ; std0 = 0.0 ; mzt = 0.0
>   DO i = 1, nband
>         DO j = 1, nm
>             ozref0 =  ozref0+ ozrefs(monin(j), latin(i), :) * monfrac(j) * latfrac(i)
>             std0   =  std0+ stds(monin(j), latin(i), :) * monfrac(j) * latfrac(i)
>             mzt    =  mzt+mtropz(monin(j), latin(i)) * monfrac(j) * latfrac(i)
>         ENDDO
>   ENDDO
> 
> !** convert tb reference into regular reference
> !   zs0 = [ -20, 60] is data grid
> !   tb  = reg - offset 
> !   reg = tb + offset 
> !   offset = (tropz - mzt)*(1-|reg(i)-tropz|/5)+mzt
> !   reg(i) = tb(i) +tropz+(mtz-tropz)|reg(i)-tropz|/5   
> !   convert PPB to DU [ here, just use constant shift ]
>   tb0(0:nlay-1)   = z0-0.5 ; tb0(nlay)= 60 
>   refz0(0:nlay)   = tb0(0:nlay)+trpz
>   zstar(0:nlay)   = 1.0/(10**((refz0)/16.0))
322,328c267,272
< 
<   DO i = 1, nlay
<     gravity_correct = (6367. / (6367. + refz0(i)+0.5 ))**2.
<     ozref0(i) = ozref0(i)*( zstar(i-1)-zstar(i)) / ( 1.25 * gravity_correct)
<     cum0(i)   = cum0(i-1) + ozref0(i)
<     std0(i)   = std0(i)*( zstar(i-1)-zstar(i)) / ( 1.25 * gravity_correct)
<     cums0(i)   = cums0(i-1) + std0(i)
---
>   DO i = 1, nlay
>    gravity_correct = (6367. / (6367. + refz0(i)+0.5 ))**2.
>    ozref0(i) = ozref0(i)*( zstar(i-1)-zstar(i)) / ( 1.25 * gravity_correct)
>    cum0(i)   = cum0(i-1) + ozref0(i)
>    std0(i)   = std0(i)*( zstar(i-1)-zstar(i)) / ( 1.25 * gravity_correct)
>    cums0(i)   = cums0(i-1) + std0(i)
330,331c274,276
< 
< ! derive variable shifht from LLM grid algitude covering 0 to 60 km
---
> 
> ! Note: TB clima is derived with variable shifting 
> !     , however, a priori is vertically adjusted with constant shifing
333c278
<   tb(0:nref)     = refz(0:nref)- trpz
---
>   tb(0:nref) = refz(0:nref)- trpz
336c281
< !     IF ( abs(refz(i)-trpz ) <= 6. ) then 
---
> !     IF ( abs(refz(i)-trpz ) <= 6. ) then 
338c283
< !        offset(i) = (trpz-mzt)*(1-abs(refz(i)-trpz)/6.)+mzt
---
> !        offset(i) = (trpz-mzt)*(1-abs(refz(i)-trpz)/6.)+mzt
342c287
< !     ENDIF
---
> !     ENDIF
345,366c290,311
< !  tb(0:nref) = refz(0:nref)-offset(0:nref) 
< !ENDIF
< 
<   IF (tb(0) < tb0(0) .or. tb(nref) > tb0(nlay) ) then 
<       print * , 'check boundary condition in TB clim' 
<       print * , TB(0), tb0(0), tb(nref), tb0(nlay) ; stop
<   ENDIF
< 
<   CALL BSPLINE(tb0, cum0, nlay+1, tb, cum, nref+1, errstat)
<   CALL BSPLINE(tb0, cums0, nlay+1, tb, cums, nref+1, errstat)
<   IF (errstat < 0) THEN
<     WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat ; stop
<   ENDIF
< 
<   ozref(1:nref) = cum(1:nref)-cum(0:nref-1)
<   std(1:nref)   = cums(1:nref)-cums(0:nref-1)
<   IF (any(ozref(:) < 0)) then
<      ozref(:) = -999 ; std(:) = -999 ; print *, 'TB <0' ; return
<   endif
<   CALL REVERSE(STD(1:nref), nref)
< 
< RETURN
---
> !  tb(0:nref) = refz(0:nref)-offset(0:nref) 
> !ENDIF
> 
>   IF (tb(0) < tb0(0) .or. tb(nref) > tb0(nlay) ) then 
>       print * , 'check boundary condition in TB clim' 
>       print * , TB(0), tb0(0), tb(nref), tb0(nlay) ; stop
>   ENDIF
> 
>   CALL BSPLINE(tb0, cum0, nlay+1, tb, cum, nref+1, errstat)
>   CALL BSPLINE(tb0, cums0, nlay+1, tb, cums, nref+1, errstat)
>   IF (errstat < 0) THEN
>     WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat ; stop
>   ENDIF
> 
>   ozref(1:nref) = cum(1:nref)-cum(0:nref-1)
>   std(1:nref)   = cums(1:nref)-cums(0:nref-1)
>   IF (any(ozref(:) < 0)) then
>      ozref(:) = -999 ; std(:) = -999 ; print *, 'TB <0' ; return
>   endif
>   CALL REVERSE(STD(1:nref), nref)
> 
> RETURN
389d333
<   REAL (KIND=dp), parameter::  latgrid=10., lat0=-90
394c338
<   REAL (KIND=dp)                :: frac,fdum
---
>   REAL (KIND=dp)                :: frac,fdum,meg
413,414c357
<         apfname = TRIM(ADJUSTL(atmdbdir)) // 'tbclima/ABall.ns' ! jbak
<  !       apfname = '/home/jbak/OzoneFit/OZBOREAS-OMI/src/tbclim/ABall.ns' ! jbak
---
>         apfname = TRIM(ADJUSTL(atmdbdir)) // 'tbclima/ABall.ns' ! jbak
421c364,366
<            READ(atmos_unit, *) (zs0(k), ozrefs1(i, j, k),stds1(i, j, k), k=nlay, 1, -1)! ppb
---
>            DO k = nlay, 1, -1
>               READ(atmos_unit, *) zs0(k), ozrefs1(i, j, k),stds1(i, j, k)! ppb
>            ENDDO
425d369
< 
427,428c371
<         apfname = TRIM(ADJUSTL(atmdbdir)) // 'tbclima/AB14H.ns' ! jbak
<   !      apfname = '/home/jbak/OzoneFit/OZBOREAS-OMI/src/tbclim/AB14.5H.ns' ! jbak
---
>         apfname = TRIM(ADJUSTL(atmdbdir)) // 'tbclima/AB14H.ns' ! jbak
436c379,381
<            READ(atmos_unit, *) (zs0(k), ozrefs2(i, j, k),stds2(i, j, k), k= nlay,1,-1)! ppb
---
>            DO k = nlay, 1, -1
>               READ(atmos_unit, *) zs0(k), ozrefs2(i, j, k),stds2(i, j, k)! ppb
>            ENDDO
439,445c384,388
<         CLOSE(atmos_unit)
< 
<         DO j = 1, 6 ! filling mid/high with -/+25
<               ozrefs2(:, j, :)   =ozrefs2(:, 7, :) ! -25
<               stds2(:, j, :)     =stds2(:, 7, :)
<          ENDDO
<          
---
>         CLOSE(atmos_unit)
>         DO j = 1, 6 ! filling mid/high with -/+25
>               ozrefs2(:, j, :)   =ozrefs2(:, 7, :) ! -25
>               stds2(:, j, :)     =stds2(:, 7, :)
>              ENDDO
447c390
<               ozrefs2(1:5, j, :) =ozrefs2(1:5, 12, :) !25
---
>               ozrefs2(1:5, j, :) =ozrefs2(1:5, 12, :) !25
449,450c392,393
<               ozrefs2(:, j, :) =ozrefs2(:, 13, :) !35
<               stds2(:, j, :)   =stds2(:, 13, :)
---
>               ozrefs2(5:12, j, :) =ozrefs2(5:12, 13, :) !35
>               stds2(5:12, j, :)   =stds2(5:12, 13, :)
452,453c395,396
<         IF (any(ozrefs2 < 0) .or. any(stds2 < 0)) then
<            print *, 'AB clima contain -999'
---
>         IF (any(ozrefs2 < 0) .or. any(stds2 < 0)) then
>            print *, 'TB clima contain -999'
467a411,424
>   IF (the_day <= 15) THEN
>      monin(1) = the_month - 1
>      IF (monin(1) == 0) monin(1) = 12
>      monin(2) = the_month
>      monfrac(1) = (15.0 - the_day) / 30.0
>      monfrac(2) = 1.0 - monfrac(1)
>   ELSE 
>      monin(2) = the_month + 1
>      IF (monin(2) == 13) monin(2) = 1
>      monin(1) = the_month
>      monfrac(2) = (the_day - 15) / 30.0
>      monfrac(1) = 1.0 - monfrac(2)
>   ENDIF
>   nm = 2
469,470c426,435
<   CALL get_monfrac(nmon, the_month, the_day, nm, monfrac, monin)
<   CALL get_latfrac(nlat,latgrid, lat0,the_lat, nband, latfrac, latin)
---
> 
>   IF (the_lat <= -85.0) THEN
>         nband = 1; latin(1) = 1; latfrac(1) = 1.0
>   ELSE IF (the_lat >= 85.0) THEN
>         nband = 1; latin(1) = nlat; latfrac(1) = 1.0
>   ELSE
>         nband = 2     ; frac = (the_lat + 85.0) / 10.0 + 1
>         latin(1) = INT(frac); latin(2) = latin(1) + 1
>         latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>   ENDIF
474a440
>               ! print * , monin(j), latin(i)
480c446
< ! ** convert ppb into DU ** ! 
---
> ! ** convert ppm into DU ** ! 
482c448
<   zstar(0:nref) = 1.0/(10**((refz)/16.0))
---
>   zstar(0:nlay) = 1.0/(10**((refz)/16.0))
495a462,463
> SUBROUTINE get_gridfrac(nlon, nlat, longrid, latgrid, lon0, lat0, &
>      lon, lat, nblon, nblat, lonfrac, latfrac, lonin, latin)
497,501c465
< SUBROUTINE get_mcprof(ozref)
< 
<   USE OMSAO_precision_module 
<   USE OMSAO_variables_module, ONLY: atmdbdir, the_month, the_day, the_lat
<   USE ozprof_data_module,     ONLY: atmos_unit,which_clima
---
>   USE OMSAO_precision_module
504d467
<   INTEGER, PARAMETER                           :: nref = 60
508c471,475
<   REAL (KIND=dp), DIMENSION(nref), INTENT(OUT) :: ozref
---
>   INTEGER, INTENT(IN)                       :: nlon, nlat
>   REAL (KIND=dp), INTENT(IN)                :: lon0, lat0, lat, lon, longrid, latgrid
>   INTEGER, INTENT(OUT)                      :: nblon, nblat
>   INTEGER, DIMENSION(2), INTENT(OUT)        :: latin, lonin
>   REAL (KIND=dp), DIMENSION(2), INTENT(OUT) :: latfrac, lonfrac
512,566c479,489
<   ! ======================
<   INTEGER, PARAMETER :: nlat=18, nmon=12
< 
<   CHARACTER (LEN=130)                                :: ozprof_fname
<   CHARACTER (LEN=200)                                :: line
< 
<   REAL (KIND=dp)                                           :: frac
<   REAL (KIND=dp), DIMENSION(2)                             :: latfrac, monfrac
<   INTEGER,        DIMENSION(2)                             :: latin, monin
<   INTEGER :: i, j, im,ib,nband, nm 
< 
<   ! saved variables
<   REAL (KIND=dp), SAVE, DIMENSION(nmon, nlat, nref)        :: ozrefs
<   LOGICAL,        SAVE                                     :: first = .TRUE.
< 
< !  IF (which_clima == 1) print *,'A-priori set to be LLM'
< 
< ! ** load oz profiles ** !
<   IF (first) THEN
<      ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'mpclima/llmclima_prof.dat'
<      OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
<      DO im = 1, nmon
<         READ (atmos_unit, *)
<         DO i = nref, 1, -1
<            READ (atmos_unit, *) ozrefs(im, :, i)
<         ENDDO
<      ENDDO
<      CLOSE (atmos_unit)     
<      first = .FALSE.
<   ENDIF
< 
< ! ** interpolation for lat, mon** ! 
<   IF (the_day <= 15) THEN
<      monin(1) = the_month - 1
<      IF (monin(1) == 0) monin(1) = 12
<      monin(2) = the_month
<      monfrac(1) = (15.0 - the_day) / 30.0
<      monfrac(2) = 1.0 - monfrac(1)
<   ELSE 
<      monin(2) = the_month + 1
<      IF (monin(2) == 13) monin(2) = 1
<      monin(1) = the_month
<      monfrac(2) = (the_day - 15) / 30.0
<      monfrac(1) = 1.0 - monfrac(2)
<   ENDIF
<   nm = 2
< 
<   IF (the_lat <= -85.0) THEN
<      nband = 1; latin(1) = 1; latfrac(1) = 1.0
<   ELSE IF (the_lat >= 85.0) THEN
<      nband = 1; latin(1) = nlat; latfrac(1) = 1.0
<   ELSE
<      nband = 2     ; frac = (the_lat + 85.0) / 10.0 + 1
<      latin(1) = INT(frac); latin(2) = latin(1) + 1
<      latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
---
>   ! ======================  
>   REAL (KIND=dp) :: frac, lat_offset, lon_offset
>   
>   lat_offset   = lat0 + latgrid / 2.0
>   lon_offset   = lon0 + longrid  / 2.0
>   
>   nblat = 2; frac = (lat - lat_offset) / latgrid + 1
>   latin(1) = INT(frac); latin(2) = latin(1) + 1
>   latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>   IF (latin(1) == 0)   THEN 
>      latin(1) = 1;    latfrac(1) = 1.0; nblat = 1
569,643c492,493
<   ozref = 0.0
<   DO im = 1, nm
<      DO ib = 1, nband
<         ozref = ozref + latfrac(ib) * monfrac(im) * ozrefs(monin(im), latin(ib), :) 
<      ENDDO
<   ENDDO
< 
<   RETURN
< END SUBROUTINE get_mcprof
< 
< !  DU table 
< !  lat [-85, 85]
< !  mon [1, 12]
< !  lat [0-1, 64-65, 66-90]
< SUBROUTINE get_mlprof(out, index_out)
< 
<   USE OMSAO_precision_module 
<   USE OMSAO_variables_module, ONLY: atmdbdir, the_month, the_day, the_lat
<   USE ozprof_data_module,     ONLY: atmos_unit,which_clima
<   IMPLICIT NONE
< 
<   INTEGER, PARAMETER                           :: nref = 60
<   ! ======================
<   ! Input/Output variables
<   ! ======================
< 
<   INTEGER, INTENT(IN) :: index_out
<   REAL (KIND=dp), DIMENSION(nref), INTENT(OUT) :: out
<   ! ======================
<   ! Local variables
<   ! ======================
<   INTEGER, PARAMETER :: nlat=18, nmon=12, nlay=66
<   REAL (KIND=dp), parameter :: latgrid=10, lat0=-90
< 
<   CHARACTER (LEN=130)                                      :: ozprof_fname
<   CHARACTER (LEN=200)                                      :: line
<   CHARACTER (LEN=10)                                       :: cdum
<   REAL (KIND=dp)                                           :: frac
<   REAL (KIND=dp), DIMENSION(2)                             :: latfrac, monfrac
<   INTEGER,        DIMENSION(2)                             :: latin, monin
<   INTEGER :: i, j, im,ib,nband, nm  
<   REAL (KIND=dp),DIMENSION(nlay)                            :: ozref0,std0, pres
<   REAL (KIND=dp),DIMENSION(nref)                            :: std, ozref
<   ! saved variables
<   REAL (KIND=dp), SAVE, DIMENSION(nmon, nlat, nlay)        :: ozrefs, stds
<   LOGICAL,        SAVE                                     :: first = .TRUE.
< ! ** load oz profiles ** !
<   IF (first) THEN
<       IF (which_clima == 12) print *,'A-priori set to be ML'
<      ! LOAD ozone DU table
<      ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'MLclima/ML_du_table.dat'
<      OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
< 
<      DO ib = 1, nlat
<         READ (atmos_unit, *) ;READ (atmos_unit, *)
<         READ (atmos_unit, *) ;READ (atmos_unit, *)
<         DO i =  1,nlay
<            READ (atmos_unit, '(a10, 12f7.3)') cdum, ozrefs(:, ib, i) ! bottom-top
<         ENDDO
<      ENDDO
<      CLOSE (atmos_unit)   
< 
<      ! LOAD STD ppmv table
<      ozprof_fname = TRIM(ADJUSTL(atmdbdir)) //'MLclima/ML_ppmv_stats.dat'
<      OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
<       READ (atmos_unit, *) ;READ (atmos_unit, *)
<      DO ib = 1, nlat
<         READ (atmos_unit, *) ;READ (atmos_unit, *)
<         READ (atmos_unit, *)
<         DO i =  nlay,1, -1
<            READ (atmos_unit, '(a4, 12f7.3)') cdum, stds(:, ib, i) ! top-bottom
<         ENDDO
<      ENDDO
<      CLOSE (atmos_unit)   
<      first = .FALSE.    
---
>   IF (latin(2) > nlat) THEN
>      latin(1) = nlat; latfrac(1) = 1.0; nblat = 1
645,662d494
< 
< ! ** interpolation for lat, mon** ! 
<    
<   CALL get_monfrac(nmon, the_month, the_day, nm, monfrac, monin)
<   CALL get_latfrac(nlat,latgrid, lat0,the_lat, nband, latfrac, latin)
< 
<   ozref0 = 0.0; std0=0.0 
<   DO im = 1, nm
<      DO ib = 1, nband
<         ozref0 = ozref0 + latfrac(ib) * monfrac(im) * ozrefs(monin(im), latin(ib), :) 
<         std0 = std0 + latfrac(ib) * monfrac(im) * stds(monin(im), latin(ib), :) 
<      ENDDO
<   ENDDO
<   ozref(:) = ozref0(1:nref)
< 
< ! convert ppmb to DU for std profile
<   pres(1) = 0.05  ! about 70 km
<   pres(2:nlay) = (/(1013.25*10.0**(-1.0*i/16.0), i = nlay-2, 0, -1)/)
664,669c496,501
<   DO i = nlay-nref, nlay-1
<     std(i-5)= (std0(i+1) + std0(i))*0.5 *(pres(i+1) - pres(i))/ 1.267
<   ENDDO
< 
<   IF ( index_out == 1 ) out(:) = ozref(:)
<   IF ( index_out == 2 ) out(:) = std(:)
---
>   ! Circular in longitude direction
>   nblon = 2; frac = (lon - lon_offset) / longrid + 1
>   lonin(1) = INT(frac); lonin(2) = lonin(1) + 1
>   lonfrac(1) = lonin(2) - frac; lonfrac(2) = 1.0 - lonfrac(1)
>   IF (lonin(1) == 0)   lonin(1) = nlon
>   IF (lonin(2) > nlon) lonin(2) = 1
671d502
< 
673c504,505
< END SUBROUTINE get_mlprof
---
>   
> END SUBROUTINE get_gridfrac
676c508,509
< SUBROUTINE get_tjprof(out,index_out)
---
> SUBROUTINE get_gridfrac1(nlon, nlat, nmon, longrid, latgrid, mongrid, lon0, lat0, mon0, &
>      lon, lat, mon, nblon, nblat, nbmon, lonfrac, latfrac, monfrac, lonin, latin, monin)
678,680c511
<   USE OMSAO_precision_module 
<   USE ozprof_data_module,     ONLY: atmos_unit,trpz
<   USE OMSAO_variables_module, ONLY: atmdbdir, the_month, the_day, the_lat, the_lon
---
>   USE OMSAO_precision_module
686,689c517,522
<   INTEGER, PARAMETER                             ::  nref = 60
<   INTEGER :: index_out
<   REAL (KIND=dp), DIMENSION(nref), INTENT(OUT)   ::  out
< 
---
>   INTEGER, INTENT(IN)                       :: nlon, nlat, nmon
>   REAL (KIND=dp), INTENT(IN)                :: lon0, lat0, mon0, lat, lon, mon, longrid, latgrid, mongrid
>   INTEGER, INTENT(OUT)                      :: nblon, nblat, nbmon
>   INTEGER, DIMENSION(2), INTENT(OUT)        :: latin, lonin, monin
>   REAL (KIND=dp), DIMENSION(2), INTENT(OUT) :: latfrac, lonfrac, monfrac
>   
692,774c525,548
<   ! ======================
<   CHARACTER (LEN=130)           :: apfname
< 
<   INTEGER, PARAMETER :: nlat=60, nlon=72, nmon=12, nlay=20
<   REAL (KIND=dp), PARAMETER         :: longrid = 5, latgrid = 3,lon0=-180.0, lat0=-90.0
<   REAL (KIND=dp), DIMENSION(nref)   :: ozref0,std0, ozref, std
<   REAL (KIND=dp), DIMENSION(0:nref) :: refz, zstar
<   REAL (KIND=dp)                    :: gravity_correct, weight
< 
<   INTEGER                       :: i, j, k,im, nblat, nblon,nbmon, errstat
<   REAL (KIND=dp), DIMENSION(2)  :: latfrac,lonfrac, monfrac
<   INTEGER, DIMENSION(2)         :: latin,lonin, monin
< 
<   REAL (kind=dp), DIMENSION(nref) :: llm, llmstd
<   LOGICAL, SAVE                 :: first = .TRUE.
<   REAL (KIND=dp), SAVE, DIMENSION(nmon, nlon, nlat, nlay) ::ozrefs
<   REAL (KIND=dp), SAVE, DIMENSION(nmon, nlon, nlat, nlay) ::stds
< 
<   ! ==============================
<   ! Name of this module/subroutine
<   ! ==============================
<   CHARACTER (LEN=17), PARAMETER :: modulename = 'get_tjprof'  
< 
<   IF (first) THEN
<      apfname = TRIM(ADJUSTL(atmdbdir)) // 'tjclima/' //'tjclima_sealevel_o3ppb_mn.dat'
<      OPEN (UNIT = atmos_unit, file = apfname, status = 'unknown')
<      DO im = 1, nmon 
<       READ (atmos_unit, '(72f8.3)') (((ozrefs(im, i, j,k), i=1, nlon), j=1, nlat), k=1,nlay)
<      ENDDO
<      CLOSE (atmos_unit)
<      apfname = TRIM(ADJUSTL(atmdbdir)) // 'tjclima/' //'tjclima_sealevel_o3ppb_sd.dat'
<      OPEN (UNIT = atmos_unit, file = apfname, status = 'unknown')
<      DO im = 1, nmon 
<       READ (atmos_unit, '(72f8.3)') (((stds(im, i, j,k), i=1, nlon), j=1, nlat), k=1,nlay)
<      ENDDO
<      CLOSE (atmos_unit)
<      first = .FALSE.
<   ENDIf
< 
<   CALL get_gridfrac(nlon, nlat, longrid, latgrid, lon0, lat0, &
<        the_lon, the_lat, nblon, nblat, lonfrac, latfrac, lonin, latin)
< 
<   CALL get_monfrac(nmon, the_month, the_day, nbmon, monfrac, monin)
< 
<   ozref0=0.0 ; std0 = 0.0
<   DO i = 1, nblon
<     DO j = 1, nblat
<       DO im = 1, nbmon
<           ozref0(1:nlay) =  ozref0(1:nlay)+ ozrefs(monin(im),lonin(i), latin(j), :) * monfrac(im) * latfrac(j)*lonfrac(i)
<           std0(1:nlay)   =  std0(1:nlay)+ stds(monin(im),lonin(i), latin(j), :) * monfrac(im) * latfrac(j)*lonfrac(i)
<       ENDDO
<     ENDDO
<   ENDDO
< 
< ! ** convert ppm into DU ** ! 
<   refz(0:nref) = (/(i*1.0, i= 0, nref )/)
<   zstar(0:nlay) = 1.0/(10**((refz(0:nlay))/16.0))
<   DO i = 1, nlay
<    gravity_correct = (6367. / (6367. + refz(i)+0.5 ))**2.
<    ozref0(i) = ozref0(i)*( zstar(i-1)-zstar(i)) / ( 1.25 * gravity_correct)
<   ENDDO
< 
<   std0(1:nlay) = ozref0(1:nlay)*std0(1:nlay)/100.
<   call get_mcprof(llm) 
<   call get_mpstd(llmstd) 
<   CALL REVERSE(llmstd(1:nref), nref)
< 
< ! merging above trpz
<   DO i = 1, nref 
<      IF (refz(i) <= trpz-2.5) then 
<          weight = 1.
<      else if (refz(i) > trpz+2.5) then 
<          weight = 0.
<      else 
<          weight = 1 - abs(refz(i) - trpz)/5.
<      endif         
<      if (ozref0(i) == 0.0) weight = 0.0
<      ozref(i) = ozref0(i)*weight + LLM(i)*(1-weight)
<      std0(i) = ozref(i)*0.1
<      std(i) = std0(i)*weight + LLMstd(i)*(1-weight)
<      !write(*, '(i2,5f8.2)') i,weight, ozref(i), ozref0(i), llm(i)
<   ENDDO
<   CALL REVERSE(std(1:nref), nref)
---
>   ! ======================  
>   REAL (KIND=dp) :: frac, lat_offset, lon_offset, mon_offset
>   
>   lat_offset   = lat0   + latgrid / 2.0
>   lon_offset   = lon0   + longrid / 2.0
>   mon_offset   = mon0   + mongrid / 2.0
>   
>   nblat = 2; frac = (lat - lat_offset) / latgrid + 1
>   latin(1) = INT(frac); latin(2) = latin(1) + 1
>   latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>   IF (latin(1) == 0)   THEN 
>      latin(1) = 1;    latfrac(1) = 1.0; nblat = 1
>   ENDIF
>   
>   IF (latin(2) > nlat) THEN
>      latin(1) = nlat; latfrac(1) = 1.0; nblat = 1
>   ENDIF
>   
>   ! Circular in longitude direction
>   nblon = 2; frac = (lon - lon_offset) / longrid + 1
>   lonin(1) = INT(frac); lonin(2) = lonin(1) + 1
>   lonfrac(1) = lonin(2) - frac; lonfrac(2) = 1.0 - lonfrac(1)
>   IF (lonin(1) == 0)   lonin(1) = nlon
>   IF (lonin(2) > nlon) lonin(2) = 1
776,777c550,556
<   IF ( index_out == 1 ) out(:) = ozref(:)
<   IF ( index_out == 2 ) out(:) = std(:)
---
>   ! Circular in year
>   nbmon = 2; frac = (mon - mon_offset) / mongrid + 1
>   monin(1) = INT(frac); monin(2) = monin(1) + 1
>   monfrac(1) = monin(2) - frac; monfrac(2) = 1.0 - monfrac(1)
>   IF (monin(1) == 0)   monin(1) = nmon
>   IF (monin(2) > nmon) monin(2) = 1
>   
779,780c558,559
< END SUBROUTINE get_tjprof
< 
---
>   
> END SUBROUTINE get_gridfrac1
959,1066d737
< 
< ! ===============================================================
< ! Obtain OMI daily CLD (O2) pressure (1 deg x1 deg) JBAK
< ! ===============================================================
< 
< 
< SUBROUTINE get_omicloud_daily (year, month, day, lon, lat, ctp)
<   USE OMSAO_precision_module 
<   USE OMSAO_variables_module,  ONLY: atmdbdir, raddate
<   USE ozprof_data_module,      ONLY: atmos_unit
<   USE OMSAO_errstat_module
<   IMPLICIT NONE
<   ! ======================
<   ! Input/Output variables
<   ! ======================
<   INTEGER, INTENT(IN)                          :: year, month, day
<   REAL (KIND=dp),INTENT(IN)                    :: lat, lon
<   REAL (KIND=dp),INTENT(OUT)                   :: ctp
< 
<   ! ======================
<   ! Local variables
<   ! ======================
<   REAL (KIND=dp), PARAMETER      :: lon0=-180.0, lat0=-90.0
< 
<   INTEGER, PARAMETER             :: nlat=180, nlon=360
<   REAL (KIND=dp), PARAMETER      :: longrid = 1.0, latgrid = 1.0
< 
<   INTEGER, PARAMETER             :: nlat2=90, nlon2=180
<   REAL (KIND=dp), PARAMETER      :: longrid2 = 2.0, latgrid2 = 2.0
< 
< 
<   INTEGER                        :: i,j, cc
<   INTEGER                        :: nblat, nblon, latin(2), lonin(2)
<   REAL (KIND=dp)                 :: latfrac(2), lonfrac(2)
<   CHARACTER (LEN=2)              :: monc, dayc
<   CHARACTER (LEN=4)              :: yrc
<   CHARACTER (LEN=130)            :: ctp_fname
<   LOGICAL                        :: file_exist
<   INTEGER, SAVE, DIMENSION(nlon, nlat) :: glbctp
<   INTEGER, SAVE, DIMENSION(nlon2, nlat2) :: glbctp2
<   LOGICAL, SAVE                  :: first = .TRUE.
< 
<   IF (first) THEN
<      ctp_fname =TRIM(ADJUSTL(atmdbdir)) // 'OMCLDO2/OMCLDO2_' //TRIM(ADJUSTL(raddate))// '_1.0x1.0.dat'
< 
<      ! Determine if file exists or not
<      INQUIRE (FILE= ctp_fname, EXIST= file_exist)
<      IF (.NOT. file_exist) THEN
<         print *, ctp_fname
<         WRITE(*, *) 'Warning: no cloud pressure file found, use monthly mean!!!'
<         STOP
<      ENDIF
<      
<      OPEN (UNIT = atmos_unit, file = ctp_fname, status = 'unknown')
<      READ (atmos_unit, '(360I5)') ((glbctp(i, j), i=1, nlon), j=1, nlat)
<      CLOSE (atmos_unit)
< 
<      ctp_fname =TRIM(ADJUSTL(atmdbdir)) // 'OMCLDO2/OMCLDO2_' // TRIM(ADJUSTL(raddate))// '_2.0x2.0.dat'
<      ! Determine if file exists or not
<      INQUIRE (FILE= ctp_fname, EXIST= file_exist)
<      IF (.NOT. file_exist) THEN
<         WRITE(*, *) 'Warning: no cloud pressure file found, use monthly mean!!!'
<         STOP
<      ENDIF
<      
<      OPEN (UNIT = atmos_unit, file = ctp_fname, status = 'unknown')
<      READ (atmos_unit, '(360I5)') ((glbctp2(i, j), i=1, nlon2), j=1, nlat2)
<      CLOSE (atmos_unit)
< 
<      first = .FALSE.
< 
<   ENDIF
< 
<   CALL get_gridfrac(nlon, nlat, longrid, latgrid, lon0, lat0, &
<        lon,lat, nblon, nblat, lonfrac, latfrac, lonin, latin)
< 
<   ctp = 0.0 
<   DO i = 1, nblon
<      DO j = 1, nblat 
<         IF (glbctp(lonin(i), latin(j) ) > 0 ) THEN 
<             ctp = ctp + glbctp(lonin(i), latin(j)) * lonfrac(i) * latfrac(j)
<         ELSE  
<         ctp = 0.0D0
<         return
<         ENDIF
<      ENDDO
<   ENDDO
< 
<   IF ( ctp == 0.0D0) THEN 
<        print * , '2x2 cloud'
<        CALL get_gridfrac(nlon2, nlat2, longrid2, latgrid2, lon0, lat0, &
<        lon,lat, nblon, nblat, lonfrac, latfrac, lonin, latin)
<        DO i = 1, nblon
<          DO j = 1, nblat 
<            IF (glbctp(lonin(i), latin(j) ) > 0 ) THEN 
<               ctp = ctp + glbctp2(lonin(i), latin(j)) * lonfrac(i) * latfrac(j)
<            ELSE  
<               ctp = 0.0D0
<            return
<            ENDIF
<          ENDDO
<        ENDDO
< 
<   ENDIF
< RETURN
< END SUBROUTINE get_omicloud_daily
< 
< 
1091c762,763
<   !INTEGER, PARAMETER             :: nlat=72, nlon=144 !REAL (KIND=dp), PARAMETER      :: longrid = 2.5, latgrid = 2.5, lon0=-180.0, lat0=-90.0
---
>   !INTEGER, PARAMETER             :: nlat=72, nlon=144
>   !REAL (KIND=dp), PARAMETER      :: longrid = 2.5, latgrid = 2.5, lon0=-180.0, lat0=-90.0
1106,1107c778,780
<      WRITE(monc, '(I2.2)') month          ! from 9 to '09' 
< 	 WRITE(dayc, '(I2.2)') day ; WRITE(yrc,  '(I4.4)') year
---
>      WRITE(monc, '(I2.2)') month          ! from 9 to '09' 
>      WRITE(dayc, '(I2.2)') day            ! from 9 to '09'     
>      WRITE(yrc,  '(I4.4)') year
1110,1111c783,784
<      !!spres_fname =TRIM(ADJUSTL(atmdbdir)) // 'fnl13.75LST/fnlsp/fnlsp_' // yrc // monc // dayc // '.dat'
<    
---
>      spres_fname =TRIM(ADJUSTL(atmdbdir)) // 'fnl13.75LST/fnlsp/fnlsp_' // yrc // monc // dayc // '.dat'
>     
1114d786
<    
1175c847
<      !!sfct_fname =TRIM(ADJUSTL(atmdbdir)) // 'fnl13.75LST/fnlst/fnlst_' // yrc // monc // dayc // '.dat'
---
>      sfct_fname =TRIM(ADJUSTL(atmdbdir)) // 'fnl13.75LST/fnlst/fnlst_' // yrc // monc // dayc // '.dat'
1183c855
<     
---
>      
1252c924
<         tpres_fname = '/data/gumbo/jbak/ATMOS/tpres/AIRS/airstp_'//yrc//monc//dayc//'.dat' 
---
>         tpres_fname = TRIM(ADJUSTL(atmdbdir)) // 'AIRS/airstp_'//yrc//monc//dayc//'.dat' 
1283d954
< 
1611,1612c1282
< !!     ncep_fname = TRIM(ADJUSTL(atmdbdir)) // 'fnl13.75LST/fnltemp/fnltemp_' // yrc // monc // dayc // '.dat'      
<       
---
>      ncep_fname = TRIM(ADJUSTL(atmdbdir)) // 'fnl13.75LST/fnltemp/fnltemp_' // yrc // monc // dayc // '.dat'      
1638a1309,1507
> SUBROUTINE get_mcprof(ozref)
>   
>   USE OMSAO_precision_module 
>   USE OMSAO_variables_module, ONLY: atmdbdir, the_month, the_day, the_lat
>   USE ozprof_data_module,     ONLY: atmos_unit,which_clima
>   IMPLICIT NONE
>   
>   INTEGER, PARAMETER                           :: nref = 60
>   ! ======================
>   ! Input/Output variables
>   ! ======================
>   REAL (KIND=dp), DIMENSION(nref), INTENT(OUT) :: ozref
>   
>   ! ======================
>   ! Local variables
>   ! ======================
>   INTEGER, PARAMETER :: nlat=18, nmon=12
>   
>   CHARACTER (LEN=130)                                :: ozprof_fname
>   CHARACTER (LEN=200)                                :: line
>   
>   REAL (KIND=dp)                                           :: frac
>   REAL (KIND=dp), DIMENSION(2)                             :: latfrac, monfrac
>   INTEGER,        DIMENSION(2)                             :: latin, monin
>   INTEGER :: i, j, im,ib,nband, nm 
>   
>   ! saved variables
>   REAL (KIND=dp), SAVE, DIMENSION(nmon, nlat, nref)        :: ozrefs
>   LOGICAL,        SAVE                                     :: first = .TRUE.
>   
>   !  IF (which_clima == 1) print *,'A-priori set to be LLM'
>   
>   ! ** load oz profiles ** !
>   IF (first) THEN
>      ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'mpclima/llmclima_prof.dat'
>      OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
>      DO im = 1, nmon
>         READ (atmos_unit, *)
>         DO i = nref, 1, -1
>            READ (atmos_unit, *) ozrefs(im, :, i)
>         ENDDO
>      ENDDO
>      CLOSE (atmos_unit)     
>      first = .FALSE.
>   ENDIF
>   
>   ! ** interpolation for lat, mon** ! 
>   IF (the_day <= 15) THEN
>      monin(1) = the_month - 1
>      IF (monin(1) == 0) monin(1) = 12
>      monin(2) = the_month
>      monfrac(1) = (15.0 - the_day) / 30.0
>      monfrac(2) = 1.0 - monfrac(1)
>   ELSE 
>      monin(2) = the_month + 1
>      IF (monin(2) == 13) monin(2) = 1
>      monin(1) = the_month
>      monfrac(2) = (the_day - 15) / 30.0
>      monfrac(1) = 1.0 - monfrac(2)
>   ENDIF
>   nm = 2
>   
>   IF (the_lat <= -85.0) THEN
>      nband = 1; latin(1) = 1; latfrac(1) = 1.0
>   ELSE IF (the_lat >= 85.0) THEN
>      nband = 1; latin(1) = nlat; latfrac(1) = 1.0
>   ELSE
>      nband = 2     ; frac = (the_lat + 85.0) / 10.0 + 1
>      latin(1) = INT(frac); latin(2) = latin(1) + 1
>      latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>   ENDIF
>   
>   ozref = 0.0
>   DO im = 1, nm
>      DO ib = 1, nband
>         ozref = ozref + latfrac(ib) * monfrac(im) * ozrefs(monin(im), latin(ib), :) 
>      ENDDO
>   ENDDO
>   
>   RETURN
> END SUBROUTINE get_mcprof
> 
> !  DU table 
> !  lat [-85, 85]
> !  mon [1, 12]
> !  lat [0-1, 64-65, 66-90]
> SUBROUTINE get_mlprof(out, index_out)
>   
>   USE OMSAO_precision_module 
>   USE OMSAO_variables_module, ONLY: atmdbdir, the_month, the_day, the_lat
>   USE ozprof_data_module,     ONLY: atmos_unit,which_clima
>   IMPLICIT NONE
> 
>   INTEGER, PARAMETER                           :: nref = 60
>   ! ======================
>   ! Input/Output variables
>   ! ======================
>   REAL (KIND=dp), DIMENSION(nref), INTENT(OUT) :: out
>   INTEGER, INTENT(IN) :: index_out
>   ! ======================
>   ! Local variables
>   ! ======================
>   INTEGER, PARAMETER :: nlat=18, nmon=12, nlay=66
>   
>   CHARACTER (LEN=130)                                      :: ozprof_fname
>   CHARACTER (LEN=200)                                      :: line
>   CHARACTER (LEN=10)                                       :: cdum
>   REAL (KIND=dp)                                           :: frac
>   REAL (KIND=dp), DIMENSION(2)                             :: latfrac, monfrac
>   INTEGER,        DIMENSION(2)                             :: latin, monin
>   INTEGER :: i, j, im,ib,nband, nm  
>   REAL (KIND=dp),DIMENSION(nlay)                            :: ozref0,std0, pres
>   REAL (KIND=dp),DIMENSION(nref)                            :: std, ozref
>   ! saved variables
>   REAL (KIND=dp), SAVE, DIMENSION(nmon, nlat, nlay)        :: ozrefs, stds
>   LOGICAL,        SAVE                                     :: first = .TRUE.
>   ! ** load oz profiles ** !
>   IF (first) THEN
>      IF (which_clima == 12) print *,'A-priori set to be ML 2012'
>      ! LOAD ozone DU table
>      ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'MLclima/ML_du_table.dat'
>      OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
>      
>      DO ib = 1, nlat
>         READ (atmos_unit, *) ;READ (atmos_unit, *)
>         READ (atmos_unit, *) ;READ (atmos_unit, *)
>         DO i =  1,nlay
>            READ (atmos_unit, '(a10, 12f7.3)') cdum, ozrefs(:, ib, i) ! bottom-top
>         ENDDO
>      ENDDO
>      CLOSE (atmos_unit)   
>      
>      ! LOAD STD ppmv table
>      ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'MLclima/ML_ppmv_stats.dat'
>      OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
>      READ (atmos_unit, *) ;READ (atmos_unit, *)
>      DO ib = 1, nlat
>         READ (atmos_unit, *) ;READ (atmos_unit, *)
>         READ (atmos_unit, *)
>         DO i =  nlay,1, -1
>            READ (atmos_unit, '(a4, 12f7.3)') cdum, stds(:, ib, i) ! top-bottom
>         ENDDO
>      ENDDO
>      CLOSE (atmos_unit)   
>      
>      first = .FALSE.
>      
>   ENDIF
>   
>   ! ** interpolation for lat, mon** ! 
>   IF (the_day <= 15) THEN
>      monin(1) = the_month - 1
>      IF (monin(1) == 0) monin(1) = 12
>      monin(2) = the_month
>      monfrac(1) = (15.0 - the_day) / 30.0
>      monfrac(2) = 1.0 - monfrac(1)
>   ELSE 
>      monin(2) = the_month + 1
>      IF (monin(2) == 13) monin(2) = 1
>      monin(1) = the_month
>      monfrac(2) = (the_day - 15) / 30.0
>      monfrac(1) = 1.0 - monfrac(2)
>   ENDIF
>   nm = 2
>   
>   IF (the_lat <= -85.0) THEN
>      nband = 1; latin(1) = 1; latfrac(1) = 1.0
>   ELSE IF (the_lat >= 85.0) THEN
>      nband = 1; latin(1) = nlat; latfrac(1) = 1.0
>   ELSE
>      nband = 2     ; frac = (the_lat + 85.0) / 10.0 + 1
>      latin(1) = INT(frac); latin(2) = latin(1) + 1
>      latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>   ENDIF
>   
>   ozref0 = 0.0; std0=0.0 
>   DO im = 1, nm
>      DO ib = 1, nband
>         ozref0 = ozref0 + latfrac(ib) * monfrac(im) * ozrefs(monin(im), latin(ib), :) 
>         std0 = std0 + latfrac(ib) * monfrac(im) * stds(monin(im), latin(ib), :) 
>      ENDDO
>   ENDDO
>   ozref(:) = ozref0(1:nref)
>   
>   ! convert ppmb to DU for std profile
>   pres(1) = 0.05  ! about 70 km
>   pres(2:nlay) = (/(1013.25*10.0**(-1.0*i/16.0), i = nlay-2, 0, -1)/)
>   
>   DO i = nlay-nref, nlay-1
>      std(i-5)= (std0(i+1) + std0(i))*0.5 *(pres(i+1) - pres(i))/ 1.267
>      ! write(* , '(2i3,3f10.3)') , i,i-5,std(i-5),  pres(i),pres(i+1)
>   ENDDO
>   
>   IF ( index_out == 1 ) out(:) = ozref(:)
>   IF ( index_out == 2 ) out(:) = std(:)
>   
>   
>   RETURN
> END SUBROUTINE get_mlprof
1678,1692c1547,1560
< 
< 
< ! ** load oz profiles ** !
< IF (which_clima == 5) print *,'A-priori set to be IUP with toz',toz     
< IF (first) THEN
< 
<     ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'iupclima/iupclima_o3du_mn.dat'
<     OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
<         
<     ! read loop        
<     DO i = 1, 6 
<          READ (atmos_unit, '(A)') ! read header
<     ENDDO
<         
<     DO im = 1, nmon
---
>   
>   ! ** load oz profiles ** !
>   IF (which_clima == 5) print *,'A-priori set to be IUP with toz',toz     
>   IF (first) THEN
>      
>      ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'iupclima/iupclima_o3du_mn.dat'
>      OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
>      
>      ! read loop        
>      DO i = 1, 6 
>         READ (atmos_unit, '(A)') ! read header
>      ENDDO
>      
>      DO im = 1, nmon
1696c1564
< 
---
>            
1698,1707c1566,1575
<            READ(atmos_unit, *) fdum, (temp(iprof),iprof = 1, maxprof ) ! du     
<            nprof = 1         
<            DO k = 1, maxprof             
<                   IF (tozindex(k) /= 0.0 ) then                   
<                   ozrefs(im,ib,nprof, il) = temp(k)                        
<                   nprof = nprof + 1
<                   ENDIF
<            ENDDO
<                   nprofs (im,ib) = nprof-1
<       
---
>               READ(atmos_unit, *) fdum, (temp(iprof),iprof = 1, maxprof ) ! du     
>               nprof = 1         
>               DO k = 1, maxprof             
>                  IF (tozindex(k) /= 0.0 ) then                   
>                     ozrefs(im,ib,nprof, il) = temp(k)                        
>                     nprof = nprof + 1
>                  ENDIF
>               ENDDO
>               nprofs (im,ib) = nprof-1
>               
1710,1723c1578,1615
<     ENDDO
<     CLOSE (atmos_unit)  
<        
< 
< first = .FALSE.
< ENDIF 
< 
< ! ** interpolation for lat, mon** ! 
< 
<   !!!!!! find latitude fraction  
<      IF (the_lat <= -75.0) THEN
<         nband = 1; latin(1) = 1; latfrac(1) = 1.0
<      ELSE IF (the_lat >= 75.0) THEN
<         nband = 1; latin(1) = nlat; latfrac(1) = 1.0
---
>      ENDDO
>      CLOSE (atmos_unit)  
>           
>      first = .FALSE.
>   ENDIF
>   
>   ! ** interpolation for lat, mon** ! 
>   
> !!!!!! find latitude fraction  
>   IF (the_lat <= -75.0) THEN
>      nband = 1; latin(1) = 1; latfrac(1) = 1.0
>   ELSE IF (the_lat >= 75.0) THEN
>      nband = 1; latin(1) = nlat; latfrac(1) = 1.0
>   ELSE
>      nband = 2     ; frac = (the_lat + 75.0) / 30.0 + 1
>      latin(1) = INT(frac); latin(2) = latin(1) + 1
>      latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
>   ENDIF
> !!!!!! find season
>   season = 1                                    ! Dec-May
>   IF (the_month > 5 .and. the_month < 12 ) season =2   ! July-Nov   
>   
> !!!!!! find total ozone fraction
>   iupozref(:) =0.   
>   
>   DO ib = 1, nband
>      
>      nprof = nprofs(season, latin(ib))
>      minoz = sum( ozrefs(season, latin(ib), 1, :))
>      maxoz = sum( ozrefs(season, latin(ib), nprof, :)) 
>      
>      IF (toz < minoz) THEN
>         WRITE(*,*), 'Warning: no a priori profile available!!!'
>         iupozref  = iupozref + ozrefs(season, latin(ib),1, :) * toz / minoz * latfrac(ib)
>      ELSE IF (toz > maxoz) THEN
>         
>         WRITE(*,*), 'Warning: no a priori profile available!!!'
>         iupozref =  iupozref + ozrefs(season, latin(ib), nprof, :) * toz / maxoz * latfrac(ib)
1725,1727c1617,1628
<         nband = 2     ; frac = (the_lat + 75.0) / 30.0 + 1
<         latin(1) = INT(frac); latin(2) = latin(1) + 1
<         latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
---
>         
>         profin = INT ((toz - minoz ) / 30.0) +1
>         
>         IF (profin == 0) THEN 
>            profin = 1
>         ELSE IF (profin == nprof) THEN
>            profin = profin -1
>         ENDIF
>         frac = 1.0 - (toz - (minoz + (profin-1) * 30.0)) / 30.0
>         
>         iupozref = iupozref + latfrac(ib) * (frac * ozrefs(season, latin(ib),profin, :) &
>              + (1.0 - frac) * ozrefs(season, latin(ib),profin+1, : ))
1729,1764c1630
<   !!!!!! find season
<    season = 1                                    ! Dec-May
<    IF (the_month > 5 .and. the_month < 12 ) season =2   ! July-Nov   
< 
<   !!!!!! find total ozone fraction
<    iupozref(:) =0.   
< 
<    DO ib = 1, nband
< 
<            nprof = nprofs(season, latin(ib))
<            minoz = sum( ozrefs(season, latin(ib), 1, :))
<            maxoz = sum( ozrefs(season, latin(ib), nprof, :)) 
<          
<            IF (toz < minoz) THEN
<               WRITE(*,*), 'Warning: no a priori profile available!!!'
<                iupozref  = iupozref + ozrefs(season, latin(ib),1, :) * toz / minoz * latfrac(ib)
<            ELSE IF (toz > maxoz) THEN
< 
<               WRITE(*,*), 'Warning: no a priori profile available!!!'
<                iupozref =  iupozref + ozrefs(season, latin(ib), nprof, :) * toz / maxoz * latfrac(ib)
<            ELSE
< 
<              profin = INT ((toz - minoz ) / 30.0) +1
<                 
<              IF (profin == 0) THEN 
<                  profin = 1
<              ELSE IF (profin == nprof) THEN
<                  profin = profin -1
<              ENDIF
<              frac = 1.0 - (toz - (minoz + (profin-1) * 30.0)) / 30.0
< 
<              iupozref = iupozref + latfrac(ib) * (frac * ozrefs(season, latin(ib),profin, :) &
<                    + (1.0 - frac) * ozrefs(season, latin(ib),profin+1, : ))
<            ENDIF
<    ENDDO
< 
---
>   ENDDO
1771c1637
<         weight(i) = (meg+5-refz(i))/5.
---
>      weight(i) = (meg+5-refz(i))/5.
1774c1640
<       ozref(i) = iupozref(i)*weight(i) + llmozref(i)*(1-weight(i)) 
---
>      ozref(i) = iupozref(i)*weight(i) + llmozref(i)*(1-weight(i)) 
1776c1642
< 
---
>   
1780,1781d1645
< 
< 
1787c1651
< 
---
>   
1820,1824c1684,1685
< 
< 
< 
< ! ** load oz profiles ** !
< 
---
>   ! ** load oz profiles ** !
>   
1826,1843c1687,1702
<   print * , 'EP+V8 profile '
<   ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'v8clima/tomsv8_ozone_clima.dat'
<   OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
<         
<         ! Read until the target month        
<          DO im = 1, nmon
<            DO i = 1, nlat 
<               READ(atmos_unit, *) 
<               nprof = 1
<               DO j = 1, maxprof
<                  READ (atmos_unit, '(A)') line;  READ (line, *) fdum
< 
<                  IF (fdum < 999.0) THEN
<                     READ (line, *) fdum, ozprofs(im, i, nprof, :)
<                     nprof = nprof + 1
<                  ENDIF
<               ENDDO
<               nprofs(im, i) = nprof - 1              
---
>      print * , 'EP+V8 profile '
>      ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'v8clima/tomsv8_ozone_clima.dat'
>      OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
>      
>      ! Read until the target month        
>      DO im = 1, nmon
>         DO i = 1, nlat 
>            READ(atmos_unit, *) 
>            nprof = 1
>            DO j = 1, maxprof
>               READ (atmos_unit, '(A)') line;  READ (line, *) fdum
>               
>               IF (fdum < 999.0) THEN
>                  READ (line, *) fdum, ozprofs(im, i, nprof, :)
>                  nprof = nprof + 1
>               ENDIF
1844a1704
>            nprofs(im, i) = nprof - 1              
1846,1847c1706
< 
<   CLOSE (atmos_unit)
---
>      ENDDO
1849c1708,1710
<   first = .FALSE.
---
>      CLOSE (atmos_unit)
>      
>      first = .FALSE.
1851,1852c1712,1713
< 
< ! ** interpolation for lat, mon** ! 
---
>   
>   ! ** interpolation for lat, mon** ! 
1867c1728
< 
---
>   
1878d1738
< 
1881,1902c1741,1757
<         DO ib = 1, nband   
<            nprof = nprofs(monin(im), latin(ib))
<            minoz = SUM(ozprofs(monin(im), latin(ib), 1, :))
<            maxoz = SUM(ozprofs(monin(im), latin(ib), nprof, :))
<                       
<            IF (toz < minoz) THEN
<               WRITE(*,*), 'Warning: no a priori profile available!!!'
<               oz  = oz + ozprofs(monin(im), latin(ib), 1, :) * toz / minoz * latfrac(ib)
<            ELSE IF (toz > maxoz) THEN
<               WRITE(*,*), 'Warning: no a priori profile available!!!'
<               oz = oz + ozprofs(monin(im), latin(ib), nprof, :) * toz / maxoz * latfrac(ib)
<            ELSE
<               profin = INT ((toz - minoz ) / 50.0)+1
<               IF (profin == 0) THEN 
<                  profin = 1
<               ELSE IF (profin == nprof) THEN
<                  profin = profin - 1
<               ENDIF
<               
<               frac = 1.0 - (toz - (minoz + (profin-1) * 50.0)) / 50.0
<               oz = oz + latfrac(ib) * monfrac(im) * (frac * ozprofs(monin(im), latin(ib), profin, :) &
<                    + (1.0 - frac) * ozprofs(monin(im), latin(ib), profin+1, :))           
---
>      DO ib = 1, nband   
>         nprof = nprofs(monin(im), latin(ib))
>         minoz = SUM(ozprofs(monin(im), latin(ib), 1, :))
>         maxoz = SUM(ozprofs(monin(im), latin(ib), nprof, :))
>         
>         IF (toz < minoz) THEN
>            WRITE(*,*), 'Warning: no a priori profile available!!!'
>            oz  = oz + ozprofs(monin(im), latin(ib), 1, :) * toz / minoz * latfrac(ib)
>         ELSE IF (toz > maxoz) THEN
>            WRITE(*,*), 'Warning: no a priori profile available!!!'
>            oz = oz + ozprofs(monin(im), latin(ib), nprof, :) * toz / maxoz * latfrac(ib)
>         ELSE
>            profin = INT ((toz - minoz ) / 50.0)+1
>            IF (profin == 0) THEN 
>               profin = 1
>            ELSE IF (profin == nprof) THEN
>               profin = profin - 1
1904c1759,1764
<         ENDDO
---
>            
>            frac = 1.0 - (toz - (minoz + (profin-1) * 50.0)) / 50.0
>            oz = oz + latfrac(ib) * monfrac(im) * (frac * ozprofs(monin(im), latin(ib), profin, :) &
>                 + (1.0 - frac) * ozprofs(monin(im), latin(ib), profin+1, :))           
>         ENDIF
>      ENDDO
1906c1766
< 
---
>   
1909a1770,1914
> ! ===============================================================
> ! Obtain TOMS V8 ozone profiles (12 month, 18 latitude bands,
> !   3-10 profiles with total ozone at a step of 50 DU
> ! ===============================================================
> !SUBROUTINE get_v8prof(month, day, lat, toz, which_clima, oz, ozref)
> !
> !  USE OMSAO_precision_module 
> !  USE OMSAO_variables_module, ONLY: atmdbdir
> !  USE ozprof_data_module,     ONLY: atmos_unit
> !  IMPLICIT NONE
> !
> !  INTEGER, PARAMETER                          :: nl = 11, nref = 60
> !  ! ======================
> !  ! Input/Output variables
> !  ! ======================
> !  INTEGER, INTENT(IN)                          :: month, day, which_clima
> !  REAL (KIND=dp),INTENT(IN)                    :: lat
> !  REAL (KIND=dp), INTENT(INOUT)                :: toz
> !  REAL (KIND=dp), DIMENSION(nl), INTENT(OUT)   :: oz
> !  REAL (KIND=dp), DIMENSION(nref), INTENT(OUT) :: ozref
> !  
> !  ! ======================
> !  ! Local variables
> !  ! ======================
> !  INTEGER, PARAMETER :: nlat=18, maxprof=10, nmon=12
> !  CHARACTER (LEN=3), DIMENSION(12)  :: months = (/'jan', 'feb','mar', 'apr', &
> !       'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'/)
> !  CHARACTER (LEN=130)                                :: ozprof_fname
> !  CHARACTER (LEN=200)                                :: line
> !
> !
> !  ! saved variables
> !  REAL (KIND=dp), SAVE, DIMENSION(nmon, nlat, maxprof, nl) :: ozprofs
> !  INTEGER,        SAVE, DIMENSION(nmon, nlat)              :: nprofs
> !  REAL (KIND=dp), SAVE, DIMENSION(nmon, nlat, nref)        :: ozrefs
> !  LOGICAL,        SAVE                                     :: first = .TRUE.
> !
> !  REAL (KIND=dp)                                           :: frac, fdum, maxoz, minoz
> !  REAL (KIND=dp), DIMENSION(2)                             :: latfrac, monfrac
> !  INTEGER,        DIMENSION(2)                             :: latin, monin
> !  INTEGER :: i, j, ib, profin, nprof, nband, nm, im
> !
> !  IF (first) THEN
> !     ! read the reference profile for climatology
> !     ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'mpclima/llmclima_prof.dat'
> !     OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
> !     DO im = 1, nmon
> !        READ (atmos_unit, *)
> !        DO i = nref, 1, -1
> !           READ (atmos_unit, *) ozrefs(im, :, i)
> !        ENDDO
> !     ENDDO
> !     CLOSE (atmos_unit)
> !     
> !     ! read the TOMS V8 profiles
> !     IF (which_clima == 1) THEN 
> !        ozprof_fname = TRIM(ADJUSTL(atmdbdir)) // 'v8clima/tomsv8_ozone_clima.dat'
> !        OPEN (UNIT = atmos_unit, file= ozprof_fname, status = 'unknown')
> !        
> !        ! Read until the target month        
> !        DO im = 1, nmon
> !           DO i = 1, nlat 
> !              READ(atmos_unit, *) 
> !              nprof = 1
> !              DO j = 1, maxprof
> !                 READ (atmos_unit, '(A)') line;  READ (line, *) fdum
> !
> !                 IF (fdum < 999.0) THEN
> !                    READ (line, *) fdum, ozprofs(im, i, nprof, :)
> !                    nprof = nprof + 1
> !                 ENDIF
> !              ENDDO
> !              nprofs(im, i) = nprof - 1              
> !           ENDDO
> !        ENDDO
> !        CLOSE (atmos_unit)
> !     ENDIF
> !     
> !     first = .FALSE.
> !  ENDIF
> !
> !  IF (day <= 15) THEN
> !     monin(1) = month - 1
> !     IF (monin(1) == 0) monin(1) = 12
> !     monin(2) = month
> !     monfrac(1) = (15.0 - day) / 30.0
> !     monfrac(2) = 1.0 - monfrac(1)
> !  ELSE 
> !     monin(2) = month + 1
> !     IF (monin(2) == 13) monin(2) = 1
> !     monin(1) = month
> !     monfrac(2) = (day - 15) / 30.0
> !     monfrac(1) = 1.0 - monfrac(2)
> !  ENDIF
> !  nm = 2
> !
> !  IF (lat <= -85.0) THEN
> !     nband = 1; latin(1) = 1; latfrac(1) = 1.0
> !  ELSE IF (lat >= 85.0) THEN
> !     nband = 1; latin(1) = nlat; latfrac(1) = 1.0
> !  ELSE
> !     nband = 2     ; frac = (lat + 85.0) / 10.0 + 1
> !     latin(1) = INT(frac); latin(2) = latin(1) + 1
> !     latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
> !  ENDIF
> !  
> !  ozref = 0.0
> !  DO im = 1, nm
> !     DO ib = 1, nband
> !        ozref = ozref + latfrac(ib) * monfrac(im) * ozrefs(monin(im), latin(ib), :) 
> !     ENDDO
> !  ENDDO
> !
> !  oz = 0.0
> !  IF (which_clima == 1) THEN
> !     DO im = 1, nm
> !        DO ib = 1, nband   
> !           nprof = nprofs(monin(im), latin(ib))
> !           minoz = SUM(ozprofs(monin(im), latin(ib), 1, :))
> !           maxoz = SUM(ozprofs(monin(im), latin(ib), nprof, :))
> !                      
> !           IF (toz < minoz) THEN
> !              WRITE(*,*), 'Warning: no a priori profile available!!!'
> !              oz  = oz + ozprofs(monin(im), latin(ib), 1, :) * toz / minoz * latfrac(ib)
> !           ELSE IF (toz > maxoz) THEN
> !              WRITE(*,*), 'Warning: no a priori profile available!!!'
> !              oz = oz + ozprofs(monin(im), latin(ib), nprof, :) * toz / maxoz * latfrac(ib)
> !           ELSE
> !              profin = INT ((toz - minoz ) / 50.0) + 1
> !              IF (profin == 0) THEN 
> !                 profin = 1
> !              ELSE IF (profin == nprof) THEN
> !                 profin = profin - 1
> !              ENDIF
> !              
> !              frac = 1.0 - (toz - (minoz + (profin-1) * 50.0)) / 50.0
> !              oz = oz + latfrac(ib) * monfrac(im) * (frac * ozprofs(monin(im), latin(ib), profin, :) &
> !                   + (1.0 - frac) * ozprofs(monin(im), latin(ib), profin+1, :))
> !           ENDIF
> !        ENDDO
> !     ENDDO
> !  ENDIF
> !
> !  RETURN
> !END SUBROUTINE get_v8prof
1937a1943
> 
2100d2105
< 
2236,2247c2241
<       surfalt_fname = TRIM(ADJUSTL(atmdbdir)) // 'terrain_height/tomsv7_terrain.dat'
<       
<       ! Determine if file exists or not
<       INQUIRE (FILE= surfalt_fname, EXIST= file_exist)
<       IF (.NOT. file_exist) THEN
<          STOP 'No Terrain Elevation datafile found!!!'
<       ENDIF
<       
<       OPEN (UNIT = atmos_unit, file = surfalt_fname, status = 'unknown')
<       DO i = 1, 4
<          READ(atmos_unit, *)
<       ENDDO
---
>      surfalt_fname = TRIM(ADJUSTL(atmdbdir)) // 'terrain_height/tomsv7_terrain.dat'
2249,2251c2243,2256
<       READ (atmos_unit, '(720I4)') ((glbz(i, j), i=1, nlon), j=1, nlat)
<       CLOSE (atmos_unit)
<       first = .FALSE.
---
>      ! Determine if file exists or not
>      INQUIRE (FILE= surfalt_fname, EXIST= file_exist)
>      IF (.NOT. file_exist) THEN
>         STOP 'No Terrain Elevation datafile found!!!'
>      ENDIF
>      
>      OPEN (UNIT = atmos_unit, file = surfalt_fname, status = 'unknown')
>      DO i = 1, 4
>         READ(atmos_unit, *)
>      ENDDO
>      
>      READ (atmos_unit, '(720I4)') ((glbz(i, j), i=1, nlon), j=1, nlat)
>      CLOSE (atmos_unit)
>      first = .FALSE.
2253c2258
< 
---
>   
2299,2316c2304,2321
<       !surfalt_fname = TRIM(ADJUSTL(atmdbdir)) // 'terrain_height/dem2.5x2.5.dat'
<       surfalt_fname = TRIM(ADJUSTL(atmdbdir)) // 'terrain_height/fnlsh1x1.dat'
<       
<       ! Determine if file exists or not
<       INQUIRE (FILE= surfalt_fname, EXIST= file_exist)
<       IF (.NOT. file_exist) THEN
<          STOP 'No Terrain Elevation datafile found!!!'
<       ENDIF
<       
<       OPEN (UNIT = atmos_unit, file = surfalt_fname, status = 'unknown')
<       DO i = 1, 4
<          READ(atmos_unit, *)
<       ENDDO
<       
<       !READ (atmos_unit, '(144I4)') ((glbz(i, j), i=1, nlon), j=1, nlat)
<       READ (atmos_unit, '(360I4)') ((glbz(i, j), i=1, nlon), j=1, nlat)
<       CLOSE (atmos_unit)
<       first = .FALSE.
---
>      !surfalt_fname = TRIM(ADJUSTL(atmdbdir)) // 'terrain_height/dem2.5x2.5.dat'
>      surfalt_fname = TRIM(ADJUSTL(atmdbdir)) // 'terrain_height/fnlsh1x1.dat'
>      
>      ! Determine if file exists or not
>      INQUIRE (FILE= surfalt_fname, EXIST= file_exist)
>      IF (.NOT. file_exist) THEN
>         STOP 'No Terrain Elevation datafile found!!!'
>      ENDIF
>      
>      OPEN (UNIT = atmos_unit, file = surfalt_fname, status = 'unknown')
>      DO i = 1, 4
>         READ(atmos_unit, *)
>      ENDDO
>      
>      !READ (atmos_unit, '(144I4)') ((glbz(i, j), i=1, nlon), j=1, nlat)
>      READ (atmos_unit, '(360I4)') ((glbz(i, j), i=1, nlon), j=1, nlat)
>      CLOSE (atmos_unit)
>      first = .FALSE.
2318c2323
< 
---
>   
2333c2338
< 
---
>   
2361,2376c2366,2381
<       surfalt_fname = TRIM(ADJUSTL(atmdbdir)) // 'terrain_height/dem0.1x0.1.dat'
<       
<       ! Determine if file exists or not
<       INQUIRE (FILE= surfalt_fname, EXIST= file_exist)
<       IF (.NOT. file_exist) THEN
<          STOP 'No Terrain Elevation datafile found!!!'
<       ENDIF
<       
<       OPEN (UNIT = atmos_unit, file = surfalt_fname, status = 'unknown')
<       DO i = 1, 4
<          READ(atmos_unit, *)
<       ENDDO
<       
<       READ (atmos_unit, '(3600I4)') ((glbz(i, j), i=1, nlon), j=1, nlat)
<       CLOSE (atmos_unit)
<       first = .FALSE.
---
>      surfalt_fname = TRIM(ADJUSTL(atmdbdir)) // 'terrain_height/dem0.1x0.1.dat'
>      
>      ! Determine if file exists or not
>      INQUIRE (FILE= surfalt_fname, EXIST= file_exist)
>      IF (.NOT. file_exist) THEN
>         STOP 'No Terrain Elevation datafile found!!!'
>      ENDIF
>      
>      OPEN (UNIT = atmos_unit, file = surfalt_fname, status = 'unknown')
>      DO i = 1, 4
>         READ(atmos_unit, *)
>      ENDDO
>      
>      READ (atmos_unit, '(3600I4)') ((glbz(i, j), i=1, nlon), j=1, nlat)
>      CLOSE (atmos_unit)
>      first = .FALSE.
2378c2383
< 
---
>   
3033,3038c3038,3041
<     1.0000,  0.9851, 0.9562, 0.9039, 0.8321, 0.7460, 0.6515, 0.5547, 0.4723, 0.4022, &
<     0.3425,  0.2917, 0.2484, 0.2114, 0.1798, 0.1528, 0.1299, 0.1104, 0.0939, 0.0798, &
<     0.0573,  0.0408, 0.0288, 0.0201, 0.0094, 0.0041, 0.0017, 0.0006, 0.0002, 0.0001, 0/)
< 
< 
< 
---
>        1.0000,  0.9851, 0.9562, 0.9039, 0.8321, 0.7460, 0.6515, 0.5547, 0.4723, 0.4022, &
>        0.3425,  0.2917, 0.2484, 0.2114, 0.1798, 0.1528, 0.1299, 0.1104, 0.0939, 0.0798, &
>        0.0573,  0.0408, 0.0288, 0.0201, 0.0094, 0.0041, 0.0017, 0.0006, 0.0002, 0.0001, 0/)
>   
3254c3257
<      IF (ratio(i) <= 50.0) THEN
---
>      IF (ABS(ratio(i)) <= 50.0) THEN
3261c3264
<      IF (ratio(i) <= 50.0) THEN
---
>      IF (ABS(ratio(i)) <= 50.0) THEN
3536c3539
< 
---
>   
3559c3562
<   REAL (KIND=dp), DIMENSION(0:nl), INTENT(IN)  :: ps
---
>   REAL (KIND=dp), DIMENSION(0:nl), INTENT(IN) :: ps
3578c3581
<   REAL (KIND=dp)                                            :: frac, tmp, fdum, maxoz, minoz
---
>   REAL (KIND=dp)                                            :: frac, fdum, maxoz, minoz
3580c3583
<   REAL (KIND=dp), DIMENSION(0:nl0)                          :: cum0,pv80g
---
>   REAL (KIND=dp), DIMENSION(0:nl0)                          :: cum0
3615c3618
<      
---
>      pv80(0:nl0) = LOG(pv80(0:nl0))
3674,3682d3676
<     
< 
<   ! Bondary layer correction  
<   IF (ps(nl) > p0 ) then !sfc
<       tmp = ( ps(nl) - p0)/(pv80(nl0)-pv80(nl0-1))
<       pv80(nl0) = ps(nl)
<   ENDIF
<   IF ( ps(0) < pv80(0) ) pv80(0) = ps(0)
< 
3688,3691c3682,3684
<   
<   pv80g(0:nl0) = LOG(pv80(0:nl0)) 
<   logps        = LOG(ps)
<      
---
>   logps = LOG(ps)
>   pv80(0) = logps(0)
> 
3693,3694c3686
<   
<   CALL BSPLINE(pv80g, cum0, nl0+1, logps, cum, nl+1, errstat)
---
>   CALL BSPLINE(pv80, cum0, nl0+1, logps, cum, nl+1, errstat)
3703c3695
<      IF (logps(i) >= pv80g(1)) EXIT
---
>      IF (logps(i) >= pv80(1)) EXIT
3710,3862c3702,3704
< 
< SUBROUTINE get_NISE_snowice
<   ! N: 90, S: -90, E: 180, W: -180
<   USE OMSAO_precision_module 
<   USE OMSAO_variables_module,  ONLY: atmdbdir, the_year, the_month, the_day, thedoy, & 
<                                      the_lat, the_lon
<   USE ozprof_data_module,      ONLY: atmos_unit
<   USE HDF5
<   USE OMSAO_errstat_module
< 
<   IMPLICIT NONE
<   CHARACTER (LEN=3)             :: cjday
<   CHARACTER (LEN=4)             :: cyear, cdate
<   INTEGER        :: error,i
<   INTEGER, PARAMETER :: rank=2, nx = 721, ny=721
<   INTEGER(HID_T) :: Fid       ! File identifier
<   INTEGER(HID_T) :: Data_id , data_type      ! Dataset identifier
<   INTEGER(HSIZE_T), DIMENSION(rank) :: data_dims =(/nx,ny/)
<   REAL (kind=dp) :: grid_x, grid_y, lat0
<   INTEGER :: nblat, latin(2), lat_id, lon_id
<   REAL (kind=dp) :: latfrac(2)
<   REAL (kind=4), DIMENSION (nx)   :: lons, lats
<   INTEGER, DIMENSION(nx,ny)       :: snow
<   CHARACTER (LEN=130)             :: fname
<   CHARACTER(maxchlen) ::  pathname,swathname, dataname
<   LOGICAL                         :: file_exist
<   LOGICAL,        SAVE            :: first = .TRUE.
<   INTEGER,        SAVE, DIMENSION(nx,ny)            :: snow_n, snow_s
<   CHARACTER (LEN=16), PARAMETER   :: modulename = 'get_NISE_snow'  
< 
<   WRITE(cyear,'(i4.4)')       the_year
<   WRITE(cdate,'(i2.2,i2.2)')  the_month, the_day
<   WRITE(cjday,'(i3.3)')       thedoy
< 
<   IF (first) THEN
<      ! read the TOMS V8 profiles
<      fname = TRIM(ADJUSTL(atmdbdir)) // 'NISE/'//cyear//'/'//cjday//'/NISE_SSMISF17_'//cyear//cdate//'.h5'        
< 
<      ! Determine if file exists or not
<      INQUIRE (FILE = TRIM(ADJUSTL(fname)), EXIST = file_exist)
<      IF (.NOT. file_exist) THEN
<         WRITE(*, *) 'GET_NISE_SNOW: snow file does not exist!!!'; STOP
<      ENDIF
< 
<    
<      CALL h5open_f(error) ; IF (error .ne. 0 ) STOP
<      CALL h5fopen_f(trim(adjustl(fname)),H5F_ACC_RDWR_F,fid,error) 
<      pathname='Northern Hemisphere/Data Fields/Extent'
<      Data_type=H5T_NATIVE_INTEGER   
<      CALL h5dopen_f(fid,trim(adjustl(pathname)), Data_id, error)
<      CALL h5dread_f(data_id,data_type,snow_N ,data_dims(1:rank), error)
<      CALL h5dclose_f(Data_id, error) ; IF (error .ne. 0 ) STOP
< 
<      pathname='Southern Hemisphere/Data Fields/Extent'
<      Data_type=H5T_NATIVE_INTEGER   
<      CALL h5dopen_f(fid,trim(adjustl(pathname)), Data_id, error)
<      CALL h5dread_f(data_id,data_type,snow_S ,data_dims(1:rank), error)
<      CALL h5dclose_f(Data_id, error) ; IF (error .ne. 0 ) STOP
< 
<      CALL h5fclose_f(fid, error) ;IF (error .ne. 0 ) STOP
<      CALL h5close_f(error)       ;IF (error .ne. 0 ) STOP
<      first = .FALSE.
<      lons(1:nx) = (/(i*360./721.-180, i=1, nx )/)
<      lats(1:nx) = (/(i*90./721., i=1, nx )/)
<   ENDIF
<   
<      grid_x = abs(lons(1) - lons(2))
<      grid_y = abs(lats(1) - lats(2))
<      lat0 = -180
<      call get_latfrac( nx, grid_x, lat0, the_lon,  nblat, latfrac, latin)
<      lon_id = latin(1)
<      if ( latfrac(1) < latfrac(2) ) lon_id = latin(2)
<     ! print * , the_lon, lons(lon_id)
< 
<      lat0 = 0
<      
<      IF (the_lat < 0 ) THEN
<      ENDIF
<      call get_latfrac( ny, grid_y, lat0, the_lat,  nblat, latfrac, latin)
< 
< 
< 
<   stop
< END SUBROUTINE get_NISE_snowice
< 
< 
< SUBROUTINE get_monfrac(nmon, mon, day, nbmon, monfrac, monin)
< 
<   USE OMSAO_precision_module
<   IMPLICIT NONE
< 
<   ! ======================
<   ! Input/Output variables
<   ! ======================
<   INTEGER, INTENT(IN)                       :: nmon, mon, day
<   INTEGER, INTENT(OUT)                      :: nbmon
<   INTEGER, DIMENSION(2), INTENT(OUT)        :: monin
<   REAL (KIND=dp), DIMENSION(2), INTENT(OUT) :: monfrac
< 
<   IF (day <= 15) THEN
<      monin(1) = mon - 1
<      IF (monin(1) == 0) monin(1) = 12
<      monin(2) = mon
<      monfrac(1) = (15.0 - day) / 30.0
<      monfrac(2) = 1.0 - monfrac(1)
<   ELSE 
<      monin(2) = mon + 1
<      IF (monin(2) == 13) monin(2) = 1
<      monin(1) = mon
<      monfrac(2) = (day - 15) / 30.0
<      monfrac(1) = 1.0 - monfrac(2)
<   ENDIF
<      nbmon=2
< END SUBROUTINE get_monfrac
< 
< SUBROUTINE get_latfrac( nlat, latgrid, lat0, lat,  nblat, latfrac, latin)
< 
<   USE OMSAO_precision_module
<   IMPLICIT NONE
< 
<   ! ======================
<   ! Input/Output variables
<   ! ======================
<   INTEGER, INTENT(IN)                       :: nlat
<   REAL (KIND=dp), INTENT(IN)                :: lat0, lat, latgrid
<   INTEGER, INTENT(OUT)                      :: nblat
<   INTEGER, DIMENSION(2), INTENT(OUT)        :: latin
<   REAL (KIND=dp), DIMENSION(2), INTENT(OUT) :: latfrac
<   
<   ! ======================
<   ! Local variables
<   ! ======================  
<   REAL (KIND=dp) :: frac, lat_offset
<   
<   lat_offset   = lat0 + latgrid / 2.0
<   nblat = 2; frac = (lat - lat_offset) / latgrid + 1
<   latin(1) = INT(frac); latin(2) = latin(1) + 1
<   latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
<  
<   IF (latin(1) == 0)   THEN 
<      latin(1) = 1;    latfrac(1) = 1.0; nblat = 1
<   ENDIF
<   
<   IF (latin(2) > nlat) THEN
<      latin(1) = nlat; latfrac(1) = 1.0; nblat = 1
<   ENDIF
< 
< 
< END SUBROUTINE get_latfrac
< 
< SUBROUTINE get_gridfrac(nlon, nlat, longrid, latgrid, lon0, lat0, &
<      lon, lat, nblon, nblat, lonfrac, latfrac, lonin, latin)
< 
---
> ! xliu, 11/04/2011
> ! Use a single US standard atmospheric water vapor profile
> SUBROUTINE GET_AFGLUS_H2O (ps, h2o, nz)
3869,3875c3711,3713
<   INTEGER, INTENT(IN)                       :: nlon, nlat
<   REAL (KIND=dp), INTENT(IN)                :: lon0, lat0, lat, lon, longrid, latgrid
<   INTEGER, INTENT(OUT)                      :: nblon, nblat
<   INTEGER, DIMENSION(2), INTENT(OUT)        :: latin, lonin
<   REAL (KIND=dp), DIMENSION(2), INTENT(OUT) :: latfrac, lonfrac
<   
<   ! ======================
---
>   INTEGER, INTENT(IN)                          :: nz
>   REAL (KIND=dp), DIMENSION(0:nz), INTENT(IN)  :: ps
>   REAL (KIND=dp), DIMENSION(nz),   INTENT(OUT) :: h2o
3877,3910c3715,3723
<   ! ======================  
<   REAL (KIND=dp) :: frac, lat_offset, lon_offset
<   
<   lat_offset   = lat0 + latgrid / 2.0
<   lon_offset   = lon0 + longrid  / 2.0
< 
< 
<   nblat = 2; frac = (lat - lat_offset) / latgrid + 1
< 
<   latin(1) = INT(frac); latin(2) = latin(1) + 1
<   latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
< 
< 
<   IF (latin(1) == 0)   THEN 
<      latin(1) = 1;    latfrac(1) = 1.0; nblat = 1
<   ENDIF
<   IF (latin(2) > nlat) THEN
<      latin(1) = nlat; latfrac(1) = 1.0; nblat = 1
<   ENDIF
<   
<   ! Circular in longitude direction
<   nblon = 2; frac = (lon - lon_offset) / longrid + 1
<   lonin(1) = INT(frac); lonin(2) = lonin(1) + 1
<   lonfrac(1) = lonin(2) - frac; lonfrac(2) = 1.0 - lonfrac(1)
<   IF (lonin(1) == 0)   lonin(1) = nlon
<   IF (lonin(2) > nlon) lonin(2) = 1
<   
<   RETURN
<   
< END SUBROUTINE get_gridfrac
< 
< 
< SUBROUTINE get_gridfrac1(nlon, nlat, nmon, longrid, latgrid, mongrid, lon0, lat0, mon0, &
<      lon, lat, mon, nblon, nblat, nbmon, lonfrac, latfrac, monfrac, lonin, latin, monin)
---
>   ! AFGL US standard atmosphere
>   INTEGER, PARAMETER              :: nz0 = 51
>   REAL (KIND=dp), DIMENSION(0:nz0), PARAMETER :: ps0 = (/ &
>        1.0130E+03,1.0000E+03,9.8500E+02,9.7000E+02,9.5500E+02,9.4000E+02,9.2000E+02,9.0000E+02,8.7500E+02,8.5000E+02, &
>        8.2500E+02,8.0000E+02,7.7000E+02,7.4000E+02,7.1000E+02,6.8000E+02,6.4000E+02,6.0000E+02,5.5000E+02,5.0000E+02, &
>        4.5000E+02,4.1110E+02,3.5650E+02,3.0800E+02,2.6500E+02,2.2700E+02,1.9400E+02,1.6580E+02,1.4170E+02,1.0350E+02, &
>        7.5650E+01,5.5290E+01,4.0470E+01,2.9720E+01,2.1867E+01,1.6186E+01,1.1970E+01,8.6499E+00,6.5195E+00,5.0669E+00, &
>        3.8613E+00,2.8710E+00,2.1972E+00,1.6958E+00,1.3141E+00,1.0242E+00,7.9780E-01,6.2130E-01,4.8300E-01,3.7330E-01, &
>        2.8670E-01,8.5000E-02/)
3912,3913c3725,3736
<   USE OMSAO_precision_module
<   IMPLICIT NONE
---
>   REAL (KIND=dp), DIMENSION(0:nz0), PARAMETER :: cumh2o0 = (/ &  ! cumulative profile in molecules cm^-2
>        0.0000000E+00, 2.1127570E+21, 4.4882070E+21, 6.7953580E+21, 9.0331740E+21, 1.1201484E+22, &
>        1.3983768E+22, 1.6641685E+22, 1.9791958E+22, 2.2755888E+22, 2.5536794E+22, 2.8133193E+22, &
>        3.0992833E+22, 3.3556958E+22, 3.5822291E+22, 3.7808143E+22, 4.0076334E+22, 4.1956598E+22, &
>        4.3810544E+22, 4.5194388E+22, 4.6207524E+22, 4.6776434E+22, 4.7328851E+22, 4.7603807E+22, &
>        4.7709864E+22, 4.7753148E+22, 4.7772574E+22, 4.7781574E+22, 4.7785887E+22, 4.7789937E+22, &
>        4.7792267E+22, 4.7793955E+22, 4.7795220E+22, 4.7796186E+22, 4.7796926E+22, 4.7797486E+22, &
>        4.7797906E+22, 4.7798216E+22, 4.7798445E+22, 4.7798616E+22, 4.7798748E+22, 4.7798845E+22, &
>        4.7798918E+22, 4.7798974E+22, 4.7799017E+22, 4.7799050E+22, 4.7799075E+22, 4.7799095E+22, &
>        4.7799111E+22, 4.7799123E+22, 4.7799133E+22, 4.7799154E+22/)
>   INTEGER                         :: errstat
>   REAL (KIND=dp), DIMENSION(0:nz) :: cumh2o
3915,3949c3738,3740
<   ! ======================
<   ! Input/Output variables
<   ! ======================
<   INTEGER, INTENT(IN)                       :: nlon, nlat, nmon
<   REAL (KIND=dp), INTENT(IN)                :: lon0, lat0, mon0, lat, lon, mon, longrid, latgrid, mongrid
<   INTEGER, INTENT(OUT)                      :: nblon, nblat, nbmon
<   INTEGER, DIMENSION(2), INTENT(OUT)        :: latin, lonin, monin
<   REAL (KIND=dp), DIMENSION(2), INTENT(OUT) :: latfrac, lonfrac, monfrac
<   
<   ! ======================
<   ! Local variables
<   ! ======================  
<   REAL (KIND=dp) :: frac, lat_offset, lon_offset, mon_offset
<   
<   lat_offset   = lat0   + latgrid / 2.0
<   lon_offset   = lon0   + longrid / 2.0
<   mon_offset   = mon0   + mongrid / 2.0
<   
<   nblat = 2; frac = (lat - lat_offset) / latgrid + 1
<   latin(1) = INT(frac); latin(2) = latin(1) + 1
<   latfrac(1) = latin(2) - frac; latfrac(2) = 1.0 - latfrac(1)
<   IF (latin(1) == 0)   THEN 
<      latin(1) = 1;    latfrac(1) = 1.0; nblat = 1
<   ENDIF
<   
<   IF (latin(2) > nlat) THEN
<      latin(1) = nlat; latfrac(1) = 1.0; nblat = 1
<   ENDIF
<   
<   ! Circular in longitude direction
<   nblon = 2; frac = (lon - lon_offset) / longrid + 1
<   lonin(1) = INT(frac); lonin(2) = lonin(1) + 1
<   lonfrac(1) = lonin(2) - frac; lonfrac(2) = 1.0 - lonfrac(1)
<   IF (lonin(1) == 0)   lonin(1) = nlon
<   IF (lonin(2) > nlon) lonin(2) = 1
---
>   h2o = 0.0
>   CALL INTERPOL(ps0, cumh2o0, nz0+1, ps(0:nz), cumh2o(0:nz), nz+1, errstat)
>   h2o(1:nz) = (cumh2o(1:nz) - cumh2o(0:nz-1))*3.0     ! 3 times
3951,3957d3741
<   ! Circular in year
<   nbmon = 2; frac = (mon - mon_offset) / mongrid + 1
<   monin(1) = INT(frac); monin(2) = monin(1) + 1
<   monfrac(1) = monin(2) - frac; monfrac(2) = 1.0 - monfrac(1)
<   IF (monin(1) == 0)   monin(1) = nmon
<   IF (monin(2) > nmon) monin(2) = 1
<   
3959,4096c3743
<   
< END SUBROUTINE get_gridfrac1
< 
< 
< SUBROUTINE get_mls_track (nl, pres, ozprof)
<   USE OMSAO_precision_module
<   USE OMSAO_parameters_module, ONLY : mflay, rearth
<   USE ozprof_data_module,      ONLY : caloz_fname, profunit
<   USe OMSAO_variables_module, ONLY: curr_x, curr_y
<   IMPLICIT NONE
< 
<   ! ===============
<   ! Input variables
<   ! ===============
<   INTEGER, INTENT (IN)                            :: nl
<   REAL (KIND=dp), DIMENSION(0:nl), INTENT (INOUT) :: pres
<   REAL (KIND=dp), DIMENSION(nl),   INTENT (INOUT) :: ozprof
< 
< 
<   ! ==================
<   ! Logical variables
<   ! ==================
< !  INTEGER :: i, nz, oztyp, sidx, eidx, nlay, errstat
<    INTEGER, PARAMETER :: nalt = 37, npix=36, nline=400
<    INTEGER ::i, ipix, iline, error, fidx, lidx, ntmp
< !  REAL (KIND=dp)                                  :: alt, gcorr
< !  REAL (KIND=dp), DIMENSION(0:mflay)              :: zs
< !  REAL (KIND=dp), DIMENSION(0:nl)                 :: cozprof
< !  REAL (KIND=dp), DIMENSION(0:mflay), SAVE          :: ps, ozs, cozs
<    REAL (KIND=dp), DIMENSION(0:nl)                   :: tmpoz  
<    REAL (KIND=dp), DIMENSION(0:nalt)                 :: cum
<    REAL (KIND=dp), DIMENSION(0:nalt), SAVE           :: mlspres
<    REAL (KIND=dp), DIMENSION(npix, nline,nalt), SAVE :: mlsdata
<   LOGICAL                                         :: first = .true.
< 
<   IF ( first ) THEN 
<      OPEN(profunit, FILE=TRIM(ADJUSTL(caloz_fname)), STATUS='old')
<      READ(profunit, *) 
<      READ(profunit, '(38f8.3)')  mlspres
<      READ(profunit, '(37f8.3)') ((mlsdata(ipix, iline,:), iline = 1, nline), ipix=19,19)
<      first = .false.
<   ENDIF
<   cum(:) = 0.0 
<   DO i = 1, nalt 
<      cum(i)  = cum(i-1) + mlsdata(curr_x, curr_y,i)
<   ENDDO
<  
<   fidx = MINVAL(MINLOC( pres(0:nl), MASK = (pres(0:nl) > mlspres(0))))-1
<   lidx = MINVAL(MAXLOC( pres(0:nl), MASK = (pres(0:nl) < mlspres(nalt)))) -1
< !  print *, mlspres(0), mlspres(nalt)
< !  print * ,fidx, lidx
< !  print *, pres(fidx-1),pres(fidx), pres(lidx), pres(lidx+1)
< 
<   CALL BSPLINE(mlspres(0:nalt), cum(0:nalt), nalt +1, pres(fidx:lidx),tmpoz(fidx:lidx), lidx-fidx+1, error)
< 
<    tmpoz(fidx+1:lidx) = tmpoz(fidx+1:lidx) -  tmpoz(fidx:lidx-1)
<   ! do i = fidx+1, lidx
<   !   write(*,'(i3, 3f8.3)') i,pres(i),ozprof(i),tmpoz(i)
<   ! enddo
<     ozprof(fidx+1:lidx ) = tmpoz(fidx+1:lidx)
<    
< 
< END SUBROUTINE get_mls_track
< 
< SUBROUTINE get_mls (nl, pres, ozprof)
<   USE OMSAO_precision_module
<   USE ozprof_data_module,      ONLY : caloz_fname, profunit
<   USe OMSAO_variables_module, ONLY: the_lon, the_lat, the_month, the_day
<   IMPLICIT NONE
< 
<   ! ===============
<   ! Input variables
<   ! ===============
<   INTEGER, INTENT (IN)                            :: nl
<   REAL (KIND=dp), DIMENSION(0:nl), INTENT (INOUT) :: pres
<   REAL (KIND=dp), DIMENSION(nl),   INTENT (INOUT) :: ozprof
< 
< 
<   ! ==================
<   ! Logical variables
<   ! ==================
< !  INTEGER :: i, nz, oztyp, sidx, eidx, nlay, errstat
<    INTEGER, PARAMETER :: nalt = 37, mlat=18*2, mlon=36
<    INTEGER ::i, j,ipix, iline, error, fidx, lidx, ntmp,nblat, nblon
<    REAL (kind=dp) , DIMENSION (2) :: latfrac , lonfrac
<    INTEGER , DIMENSION (2) :: latin, lonin
<    REAL (KIND=dp), DIMENSION(nalt) :: tmp
<    REAL (KIND=dp), DIMENSION(0:nl)                 :: tmpoz  
<    REAL (KIND=dp), DIMENSION(0:nalt)               :: cum
<    INTEGER , SAVE :: nlon, nlat
<    REAL (KIND=dp), SAVE :: latgrid, longrid, lat0, lon0
<    REAL (KIND=dp), DIMENSION(0:nalt), SAVE         :: mlspres
<    REAL (KIND=dp), DIMENSION(mlon,mlat,nalt), SAVE :: mlsdata
<   LOGICAL                                         :: first = .true.
< 
< 
<   IF ( first ) THEN 
<      OPEN(profunit, FILE=TRIM(ADJUSTL(caloz_fname)), STATUS='old')
<      READ(profunit, '(38f8.3)')  mlspres
<      READ(profunit,*)  nlon, nlat
<      READ(profunit, '(37f8.3)') ((mlsdata(ipix, iline,:), iline = 1, nlat), ipix=1,nlon)
<      first = .false.
<      latgrid = 180./nlat ; lat0 = -90
<      longrid = 360./nlon ; lon0 = -180
<   ENDIF
< 
<   call get_latfrac ( nlat, latgrid, lat0, the_lat,  nblat, latfrac, latin)
<   call get_latfrac ( nlon, longrid, lon0, the_lon,  nblon, lonfrac, lonin)
<   IF (nlon == 1 ) THEN 
<       nblon = 1; lonfrac=1.0 ; lonin = 1
<   ENDIF
<   tmp(:) = 0.0
<   DO i = 1, nblon
<     DO j = 1, nblat
<       tmp(:) = tmp(:) + mlsdata( lonin(i), latin(i),:)*lonfrac(i)*latfrac(j)       
<     ENDDO
<   ENDDO
< 
<   cum(:) = 0.0 
<   DO i = 1, nalt 
<      cum(i)  = cum(i-1) + tmp(i)
<    !  write(*,'(i3, 3f8.3)') i,mlspres(i), cum(i), tmp(i)
<   ENDDO
<  
<   fidx = MINVAL(MINLOC( pres(0:nl), MASK = (pres(0:nl) > mlspres(0))))-1
<   lidx = MINVAL(MAXLOC( pres(0:nl), MASK = (pres(0:nl) < mlspres(nalt)))) -1
< !  print *, mlspres(0), mlspres(nalt)
< !  print * ,fidx, lidx
< !  print *, pres(fidx-1),pres(fidx), pres(lidx), pres(lidx+1)
< 
<   CALL BSPLINE(mlspres(0:nalt), cum(0:nalt), nalt +1, pres(fidx:lidx),tmpoz(fidx:lidx), lidx-fidx+1, error)
< 
<   tmpoz(fidx+1:lidx) = tmpoz(fidx+1:lidx) -  tmpoz(fidx:lidx-1)
<   ! do i = fidx+1, lidx
<   !   write(*,'(i3, 3f8.3)') i,pres(i),ozprof(i),tmpoz(i)
<   ! enddo
<   ozprof(fidx+1:lidx ) = tmpoz(fidx+1:lidx)
< 
---
> END SUBROUTINE GET_AFGLUS_H2O
4098d3744
< END SUBROUTINE get_mls
============================
pseudo_model.f90
15c15
<   
---
> 
20,21c20,21
<        no2_t1_idx, hcho_idx, shift_offset, us1_idx, us2_idx, maxwfc, so2v_idx, o2o2_idx
< !      comm_idx, com1_idx, fsl_idx, rsl_idx, com2_idx, com3_idx
---
>        no2_t1_idx, hcho_idx, shift_offset, us1_idx, us2_idx, maxwfc, so2v_idx, o2o2_idx, &
>        comm_idx, com1_idx, fsl_idx, rsl_idx, com2_idx, com3_idx
28c28
<        fitvar_rad_apriori, actspec_rad, cmcspec
---
>        fitvar_rad_apriori, actspec_rad
42,43c42,47
<        use_effcrs, ncalcp, do_simu_rmring, nsaa_spike, the_ai,&
<        cmfind, cmind, ncm, cmwins
---
>        use_effcrs, ncalcp, do_simu_rmring, nsaa_spike, the_ai,do_alb_longwav, &
>        alb_swav, alb_ewav, pos_alb, toms_fwhm, which_cld, use_prefitalb,      &
>        pf2ba0, pf2ba1, pf2fc0, pf2fc1, do_sy_diagonal, merr_covar
>   USE cloud_data_module, ONLY : new_cfrac, new_alb, new_ps0, new_ctp, n_newalb, &
>        n_newwfc, use_retctp, use_retalb, avgwav_cld
> 
47c51
<   
---
> 
64c68,69
<        idx, albord, min_ssa_iter, swin, ewin, ig, nord, nostk, wfcord, ntmp
---
>        idx, albord, min_ssa_iter, swin, ewin, ig, nord, nostk, wfcord, ntmp,  &
>        albsidx, albeidx , m !, idx330 , albord1, cfsidx, cfeidx
73c78
<        simrad, simrad1, fitspec1, diff, temporwf, corr
---
>        simrad, simrad1, fitspec1, diff, temporwf
82a88,89
>   REAL (KIND=dp)                           :: so2adj, so2vadj, newso2, newbro, &
>        newhcho, newno2, broadj, hchoadj, no2adj
86c93,94
<        do_saodwf, do_cfracwf, do_ctpwf, do_codwf, negval, do_sprswf, do_so2zwf
---
>        do_saodwf, do_cfracwf, do_ctpwf, do_codwf, negval, do_sprswf, do_so2zwf,     &
>        so2negval, so2vnegval, hchonegval, bronegval, no2negval
88c96,104
<   REAL (KIND=dp), DIMENSION(ns) :: walb0s 
---
>   REAL (KIND=dp), DIMENSION(ns) :: walb0s, wfc0s 
>   CHARACTER(LEN=1)  :: ordchar
>   LOGICAL           :: no2alb0
> 
>   ! measurement error covariance Random + Systematic
>   REAL(KIND=dp), DIMENSION(ns, ns)  :: Sy, Sy_inv
>   REAL(KIND=dp), DIMENSION(ns, 1)   :: y1
>   REAL(KIND=dp), DIMENSION(1, 1)    :: chi
>   REAL(KIND=dp), ALLOCATABLE        :: y1tmp(:, :), Sy_invtmp(:, :)
115c131
<  
---
> 
117c133
<   
---
> 
127c143
<   
---
> 
153c169
<      
---
> 
158a175,227
> 
>   ! Disable fitting surface albedo when 0.999>=fc>=0.001
>   ! For safe, as we have set sa(i, i) = 0.0 in specfit_ozprof 
>   !IF ( do_alb_longwav .AND. nfwfc > 0) THEN
>   IF (nfwfc > 0) THEN
>      DO i = wfcidx + nwfc - 1, wfcidx, -1
>         IF (fitvar_rad_str(i)(4:4) == '0') EXIT
>      ENDDO
>      the_cfrac = fitvar_rad(i)   ! Use UV2/last channel cloud fraction
>      IF (the_cfrac <= 1.0E-3) THEN
>         the_cfrac = 0.0D0; do_cfracwf = .FALSE.
>         DO i = 1, nwfc
>            j = wfcidx - 1 + i
>            fitvar_rad(j) = 0.0D0;  fitvar_rad_apriori(j) = 0.0D0
>         ENDDO
>         DO i = wfcfidx, wfcfidx + nfwfc - 1
>            fitvar(i) = 0.0D0;  fitvarap(i) = 0.0D0
>         ENDDO
>      ELSE IF (the_cfrac >= 0.999) THEN
>         the_cfrac = 1.0D0; do_cfracwf = .FALSE.
>         DO i = 1, nwfc
>            j = wfcidx - 1 + i
>            IF (fitvar_rad_str(j)(4:4) == '0') THEN
>               fitvar_rad(j) = 1.0D0;  fitvar_rad_apriori(j) = 1.0D0
>            ELSE
>               fitvar_rad(j) = 0.0D0;  fitvar_rad_apriori(j) = 0.0D0
>            ENDIF
>         ENDDO
>         DO i = wfcfidx, wfcfidx + nfwfc - 1           
>            IF (fitvar_rad_str(mask_fitvar_rad(i))(4:4) == '0') THEN
>               fitvar(k) = 1.0D0;  fitvarap(k) = 1.0D0
>            ELSE
>               fitvar(k) = 0.0D0;  fitvarap(k) = 0.0D0
>            ENDIF
>         ENDDO
>      ELSE
>         do_albwf = .FALSE.
>         DO i = 1, nalb
>            j = albidx - 1 + i
>            IF (fitvar_rad_str(j)(4:4) /= '0') THEN
>               fitvar_rad(j) = 0.0D0;  fitvar_rad_apriori(j) = 0.0D0
>            ENDIF
>         ENDDO
>         IF (nfalb > 0) THEN
>            DO i = albfidx, albfidx + nfalb - 1
>               IF (fitvar_rad_str(mask_fitvar_rad(i))(4:4) /= '0') THEN
>                  fitvar(i) = 0.0D0;  fitvarap(i) = 0.0D0
>               ENDIF
>            ENDDO
>         ENDIF
>      ENDIF
>   ENDIF
> 
163c232
<    
---
> 
180,193c249,299
<  DO k = 1, ngas
<     i = fgasidxs(k)
<     IF (i > 0) THEN
<        j = mask_fitvar_rad(i)
<        tracegas(k, 4) = fitvar_rad(j) !/ refspec_norm(gasidxs(k)) ! trace gas column in molecules cm-2
<     ENDIF
<    
<  ENDDO
<  waves = fitwavs(1:ns)
<  
<  vary_sfcalb = .FALSE. !.TRUE.
<  n0alb = 0
<  
<  DO i = 1, nalb
---
>   so2negval = .FALSE.; so2vnegval = .FALSE.
>   hchonegval = .FALSE.; bronegval = .FALSE.
>   no2negval = .FALSE.
>   DO k = 1, ngas
>      i = fgasidxs(k)
>      IF (i > 0) THEN
>         j = mask_fitvar_rad(i)
>         tracegas(k, 4) = fitvar_rad(j) !/ refspec_norm(gasidxs(k)) ! trace gas column in molecules cm-2
>         IF (gasidxs(k) == so2_idx .AND. tracegas(k, 4) < 0.d0)  THEN
>            so2negval = .TRUE.
>            newso2 = 1.0E15 * refspec_norm(gasidxs(k))
>            so2adj = newso2 - tracegas(k, 4)
>            tracegas(k, 4) = newso2
>         ENDIF
> 
>         IF (gasidxs(k) == so2v_idx .AND. tracegas(k, 4) < 0.d0)  THEN
>            so2vnegval = .TRUE.
>            newso2 = 1.0E15 * refspec_norm(gasidxs(k))
>            so2vadj = newso2 - tracegas(k, 4)
>            tracegas(k, 4) = newso2
>         ENDIF
> 
>         IF (gasidxs(k) == no2_t1_idx .AND. tracegas(k, 4) < 0.d0)  THEN
>            no2negval = .TRUE.
>            newno2 = 1.0E15 * refspec_norm(gasidxs(k))
>            no2adj = newno2 - tracegas(k, 4)
>            tracegas(k, 4) = newno2
>         ENDIF
> 
>         IF (gasidxs(k) == hcho_idx .AND. tracegas(k, 4) < 0.d0)  THEN
>            hchonegval = .TRUE.
>            newhcho = 1.0E15 * refspec_norm(gasidxs(k))
>            hchoadj = newhcho- tracegas(k, 4)
>            tracegas(k, 4) = newhcho
>         ENDIF
> 
>         IF (gasidxs(k) == bro_idx .AND. tracegas(k, 4) < 0.d0)  THEN
>            bronegval = .TRUE.
>            newbro = 1.0E12 * refspec_norm(gasidxs(k))
>            broadj = newbro - tracegas(k, 4)
>            tracegas(k, 4) = newbro
>         ENDIF
> 
>      ENDIF
>   ENDDO
> 
>   waves = fitwavs(1:ns) 
>   vary_sfcalb = .true. !.TRUE. !.FALSE.
>   n0alb = 0
>   no2alb0 = .TRUE.! .FALSE.
>   DO i = 1, nalb
195c301
< !xliu, 02/08/2012, add albord and **albord
---
>      !xliu, 02/08/2012, add albord and **albord
197d302
< 
199c304
< !     IF (fitvar_rad_str(j)(4:4) == '0') THEN
---
>         !     IF (fitvar_rad_str(j)(4:4) == '0') THEN
201c306
<         
---
> 
208a314,337
> 
>         ! Borrow 1st order albedo from longer wavelength, assuming that for 312-355 nm the wavelenght dependent 
>         ! parameter are same for each sub window 312-330 and 330-350 nm, but deriving 0-order, independently.
>         IF (do_alb_longwav .AND. numwin == 3 .AND. fitvar_rad_str(j) == '2ba0' .AND. rmask_fitvar_rad(j) <= 0) THEN
>            DO k = i, nalb
>               m = albidx -1 + k
>               IF (fitvar_rad_str(m) == '3ba0'.AND. rmask_fitvar_rad(m) > 0) EXIT 
>            ENDDO
>            IF (k > nalb) THEN
>               WRITE(*, *)  modulename, ': ERROR 2ba0 is not filled'
>               errstat = pge_errstat_error; RETURN   
>            ENDIF
>            fidx=albfpix(i); lidx=alblpix(i)
>            albarr(n0alb)  = fitvar_rad(m)
>            IF(vary_sfcalb)  walb0s(fidx:lidx) =  albarr(n0alb)
> 
>            no2alb0 = .TRUE.
>            !ELSE IF (do_alb_longwav.AND. numwin == 2 .AND. which_cld == 5 .AND. use_retalb) THEN
>            !   fidx=albfpix(i); lidx=alblpix(i)
>            !   walb0s(fidx:lidx) = new_alb(1)
>         ELSE IF (use_prefitalb .AND. fitvar_rad_str(j) == '2ba0' .AND. rmask_fitvar_rad(j) <= 0) THEN
>            albarr(n0alb) = pf2ba0
>            IF(vary_sfcalb) walb0s(albpmin(n0alb):albpmax(n0alb)) = pf2ba0
>         ENDIF
213a343,377
> 
>            IF (do_alb_longwav .AND. numwin == 3 .AND. fitvar_rad_str(j)(1:3) == '2ba' &
>                 .AND. rmask_fitvar_rad(j) <= 0)  THEN
>               WRITE(ordchar, '(I1)') albord 
> 
>               DO k = i, nalb
>                  m = albidx -1 + k
>                  IF (fitvar_rad_str(m) == '3ba'//ordchar.AND. rmask_fitvar_rad(m) > 0) EXIT 
>               ENDDO
>               IF (k > nalb) THEN
>                  WRITE(*, *)  modulename, ': ERROR 2ba1 is not filled'
>                  errstat = pge_errstat_error; RETURN   
>               ENDIF
>               IF (no2alb0) THEN
>                  fidx = albfpix(k)
>                  lidx = alblpix(k)
>                  wavavg = SUM(waves(fidx:lidx)/(1.0+lidx-fidx))
>               ENDIF
>               fidx = albfpix(i)
>               lidx = alblpix(i)
>               walb0s(fidx:lidx) = walb0s(fidx:lidx) + fitvar_rad(m) * (waves(fidx:lidx) - wavavg)**albord
>            ELSE IF (do_alb_longwav.AND. numwin == 2 .AND. which_cld == 5 .AND. use_retalb) THEN
>               fidx = albfpix(i)
>               lidx = alblpix(i)
>               m = albord + 1
>               IF (m > n_newalb) THEN
>                  WRITE(*, *)  modulename, ': which_cld==5, alb variables not consist'
>               ENDIF
>               walb0s(fidx:lidx) = walb0s(fidx:lidx) + new_alb(m) * (waves(fidx:lidx) - avgwav_cld)**albord
>               !walb0s(fidx:lidx) = walb0s(fidx:lidx) + new_alb(m) * (waves(fidx:lidx) - wavavg)**albord
>            ELSE IF (use_prefitalb .AND. fitvar_rad_str(j)(1:3) == '2ba'  &
>                 .AND. rmask_fitvar_rad(j) <= 0)  THEN
>               fidx = albfpix(i); lidx = alblpix(i)
>               walb0s(fidx:lidx) = walb0s(fidx:lidx) + pf2ba1 * (waves(fidx:lidx) - wavavg)**albord
>            ENDIF
215c379
<      ENDIF        
---
>      ENDIF
217,218c381,382
<    
<   n0wfc = 0
---
> 
>   n0wfc = 0; !no2alb0 = .FALSE.
221,222c385,389
<      IF (fitvar_rad_str(j)(4:4) == '0') THEN
<         n0wfc = n0wfc + 1; wfcarr(n0wfc) = fitvar_rad(j)
---
> 
>      READ(fitvar_rad_str(j)(4:4), '(I1)') wfcord
>      IF (wfcord == 0) THEN
>         n0wfc = n0wfc + 1
>         wfcarr(n0wfc) = fitvar_rad(j)
224c391,457
<      ENDIF      
---
>         IF (vary_sfcalb) wfc0s(wfcpmin(n0wfc):wfcpmax(n0wfc)) = wfcarr(n0wfc)
> 
>         IF (do_alb_longwav .AND. numwin == 3 .AND. fitvar_rad_str(j) == '2fc0' &
>              .AND. rmask_fitvar_rad(j) <= 0 .AND. vary_sfcalb)  THEN
>            DO k = i, nwfc
>               m = wfcidx -1 + k
>               IF (fitvar_rad_str(m) == '3fc0'.AND. rmask_fitvar_rad(m) > 0) EXIT 
>            ENDDO
>            IF (k > nwfc) THEN
>               WRITE(*, *)  modulename, ': ERROR 2fc0 is not filled'
>               errstat = pge_errstat_error; RETURN   
>            ENDIF
>            fidx=wfcfpix(i); lidx=wfclpix(i)
>            wfcarr(n0wfc) = fitvar_rad(m)
>            IF (vary_sfcalb)  wfc0s(fidx:lidx) = fitvar_rad(m)      
>            no2alb0 = .TRUE.
>            !ELSE IF (do_alb_longwav.AND. numwin == 2 .AND. which_cld == 5 .AND. use_retalb) THEN
>            !   fidx=wfcfpix(i); lidx=wfclpix(i)
>            !   wfc0s(fidx:lidx) = new_cfrac(1)
>         ELSE IF (use_prefitalb .AND. fitvar_rad_str(j) == '2fc0' &
>              .AND. rmask_fitvar_rad(j) <= 0 .AND. vary_sfcalb) THEN
>            wfcarr(n0wfc) = pf2fc0
>            fidx=wfcfpix(i); lidx=wfclpix(i)
>            IF (vary_sfcalb) wfc0s(wfcpmin(n0wfc):wfcpmax(n0wfc)) =  pf2fc0
>         ENDIF
>      ELSE
>         IF (vary_sfcalb) THEN
>            fidx = wfcfpix(i); lidx = wfclpix(i)   
>            wavavg = SUM(waves(fidx:lidx)/(1.0+lidx-fidx))
>            wfc0s(fidx:lidx) =  wfc0s(fidx:lidx) + fitvar_rad(j) * (waves(fidx:lidx) - wavavg)**wfcord
> 
>            IF (do_alb_longwav .AND. numwin == 3 .AND. fitvar_rad_str(j)(1:3) == '2fc' &
>                 .AND. rmask_fitvar_rad(j) <= 0)  THEN
>               WRITE(ordchar, '(I1)') wfcord 
> 
>               DO k = i, nwfc
>                  m = wfcidx -1 + k
>                  IF (fitvar_rad_str(m) == '3fc'//ordchar.AND. rmask_fitvar_rad(m) >= 0) EXIT 
>               ENDDO
>               IF (k > nwfc) THEN
>                  WRITE(*, *)  modulename, ': ERROR 2fc1 is not filled'
>                  errstat = pge_errstat_error; RETURN   
>               ENDIF
>               IF (no2alb0) THEN
>                  fidx = wfcfpix(k)
>                  lidx = wfclpix(k)
>                  wavavg = SUM(waves(fidx:lidx)/(1.0+lidx-fidx))
>               ENDIF
>               fidx = wfcfpix(i)
>               lidx = wfclpix(i)
>               wfc0s(fidx:lidx) = wfc0s(fidx:lidx) + fitvar_rad(m) * (waves(fidx:lidx) - wavavg)**wfcord
>            ELSE IF (do_alb_longwav .AND. numwin == 2 .AND. which_cld == 5 .AND. use_retalb) THEN
>               fidx = wfcfpix(i)
>               lidx = wfclpix(i)
>               m = wfcord + 1
>               IF (m > n_newwfc) THEN
>                  WRITE(*, *)  modulename, ': which_cld==5, cfrac variables not consist'
>               ENDIF
>               wfc0s(fidx:lidx) = wfc0s(fidx:lidx) + new_cfrac(m) * (waves(fidx:lidx) - avgwav_cld)**wfcord
>            ELSE IF (use_prefitalb .AND. fitvar_rad_str(j)(1:3) == '2fc'  &
>                 .AND. rmask_fitvar_rad(j) <= 0)  THEN
>               fidx = wfcfpix(i)
>               lidx = wfclpix(i)
>               wfc0s(fidx:lidx) = wfc0s(fidx:lidx) + pf2fc1 * (waves(fidx:lidx) - wavavg)**wfcord
>            ENDIF
>         ENDIF
>      ENDIF
226c459
<   
---
> 
234,266c467,501
<      
<  !Iraddaince/radiance shift is done when interpolating solar reference to wavelength grid, not here
<  !IF (nsh > 0) THEN
<  !   IF (do_subfit) THEN
<  !      fidx = 1
<  !      DO j = 1, numwin
<  !         lidx = fidx + nradpix(j) - 1
<  !         delpos(fidx:lidx) =  waves(fidx:lidx) - (waves(fidx) + waves(lidx)) / 2.0
<  !         IF (shfind(j, 1) > 0)  waves(fidx:lidx) = waves(fidx:lidx) + fitvar_rad(shind(j, 1)) 
<  !
<  !         DO i = 2, nsh            
<  !            IF (shfind(j, i) > 0)  waves(fidx:lidx) = waves(fidx:lidx) + &
<  !                 fitvar_rad(shind(j, i)) * (delpos(fidx:lidx) ** (i-1))
<  !         ENDDO
<  !         fidx = lidx + 1
<  !      ENDDO
<  !   ELSE
<  !      IF (shwins(1, 1) == 1) THEN
<  !         fidx = 1
<  !      ELSE
<  !         fidx = SUM(nradpix(1: shwins(1, 1)-1)) + 1
<  !      ENDIF
<  !      lidx = SUM(nradpix(1: shwins(1, 2)))
<  !      delpos(fidx:lidx) =  waves(fidx:lidx) - (waves(fidx) + waves(lidx)) / 2.0
<  !      IF (shfind(1, 1) > 0) waves(fidx:lidx)  = waves(fidx:lidx) + fitvar_rad(shind(1, 1))
<  !
<  !      DO i = 2, nsh  
<  !         IF (shfind(1, i) > 0) THEN
<  !            waves(fidx:lidx)  = waves(fidx:lidx) + fitvar_rad(shind(1, i)) * (delpos(fidx:lidx) ** (i-1))
<  !         ENDIF
<  !      ENDDO
<  !   ENDIF
<  !ENDIF
---
> 
>   waves = fitwavs(1:ns)
> 
>   !Iraddaince/radiance shift is done when interpolating solar reference to wavelength grid, not here
>   !IF (nsh > 0) THEN
>   !   IF (do_subfit) THEN
>   !      fidx = 1
>   !      DO j = 1, numwin
>   !         lidx = fidx + nradpix(j) - 1
>   !         delpos(fidx:lidx) =  waves(fidx:lidx) - (waves(fidx) + waves(lidx)) / 2.0
>   !         IF (shfind(j, 1) > 0)  waves(fidx:lidx) = waves(fidx:lidx) + fitvar_rad(shind(j, 1)) 
>   !
>   !         DO i = 2, nsh            
>   !            IF (shfind(j, i) > 0)  waves(fidx:lidx) = waves(fidx:lidx) + &
>   !                 fitvar_rad(shind(j, i)) * (delpos(fidx:lidx) ** (i-1))
>   !         ENDDO
>   !         fidx = lidx + 1
>   !      ENDDO
>   !   ELSE
>   !      IF (shwins(1, 1) == 1) THEN
>   !         fidx = 1
>   !      ELSE
>   !         fidx = SUM(nradpix(1: shwins(1, 1)-1)) + 1
>   !      ENDIF
>   !      lidx = SUM(nradpix(1: shwins(1, 2)))
>   !      delpos(fidx:lidx) =  waves(fidx:lidx) - (waves(fidx) + waves(lidx)) / 2.0
>   !      IF (shfind(1, 1) > 0) waves(fidx:lidx)  = waves(fidx:lidx) + fitvar_rad(shind(1, 1))
>   !
>   !      DO i = 2, nsh  
>   !         IF (shfind(1, i) > 0) THEN
>   !            waves(fidx:lidx)  = waves(fidx:lidx) + fitvar_rad(shind(1, i)) * (delpos(fidx:lidx) ** (i-1))
>   !         ENDIF
>   !      ENDDO
>   !   ENDIF
>   !ENDIF
271,272c506
< 
<   IF (use_effcrs) THEN ! F
---
>   IF (use_effcrs) THEN
275,277c509,511
<           ns, waves, maxoth, o3shi, sza, vza, aza, nlay, ozprof, tprof, n0alb, &
<           albarr, albpmin, albpmax, vary_sfcalb, walb0s, n0wfc, wfcarr, wfcpmin, wfcpmax, nostk, &
<           albwf(1:ns, 1:nostk), ozwf(1:ns, 1:nlay, 1:nostk), tmpwf(1:ns, 1:nlay, 1:nostk),           &
---
>           ns, waves, maxoth, o3shi, sza, vza, aza, nlay, ozprof, tprof, n0alb, albarr, albpmin,  &
>           albpmax, vary_sfcalb, walb0s, n0wfc, wfcarr, wfcpmin, wfcpmax, wfc0s, nostk,           &
>           albwf(1:ns, 1:nostk), ozwf(1:ns, 1:nlay, 1:nostk), tmpwf(1:ns, 1:nlay, 1:nostk),       &
284,289c518
<        !      print * , 'o3shi', o3shi(:,1)
<        !      print * , 'albarr',albarr(1:2)
<        !      write(*,'(a10, 10e15.7)')  'walb0s',walb0s(201:210)
<        !      write(*,'(a10, 10e15.7)')  'albwf', albwf(201:210,1)
< 
<      ntmp = MAX(ncalcp, ns) ! 94, 218
---
>      ntmp = MAX(ncalcp, ns)
291,293c520,522
<           do_taodwf, do_twaewf, do_saodwf, do_cfracwf, do_ctpwf, do_codwf, do_sprswf,do_so2zwf, &
<           ns, waves, maxoth, o3shi, sza, vza, aza, nlay, ozprof, tprof, n0alb,  &
<           albarr, albpmin, albpmax, vary_sfcalb, walb0s, n0wfc, wfcarr, wfcpmin, wfcpmax, nostk, &
---
>           do_taodwf, do_twaewf, do_saodwf, do_cfracwf, do_ctpwf, do_codwf, do_sprswf,      &
>           do_so2zwf, ns, waves, maxoth, o3shi, sza, vza, aza, nlay, ozprof, tprof, n0alb,  &
>           albarr, albpmin, albpmax, vary_sfcalb, walb0s, n0wfc, wfcarr, wfcpmin, wfcpmax, wfc0s, nostk, &
298,299d526
<       
<         !     write(*,'(a10, 10e15.7)')  'albwf', albwf(201:210,1)
303,305d529
<   !print * , fsimrad(1:ns, 1)
<  !stop
< 
308d531
< 
316a540,576
> 
>   !!xliu (12/11/2014): correct radiances based on SO2 to deal with negative
>   !ozone values
>   DO k = 1, ngas
>      i = fgasidxs(k)
>      IF (i > 0) THEN
>         j = mask_fitvar_rad(i)
>         tracegas(k, 4) = fitvar_rad(j)
> 
>         IF ( gasidxs(k) == so2_idx .AND. so2negval) THEN
>            fsimrad(1:ns, 1) = fsimrad(1:ns, 1) * (1.0d0 + database(so2_idx,refidx(1:ns)) * so2adj)
>            tracegas(k, 4) = newso2 - so2adj; fitvar_rad(j) = tracegas(k, 4)
>         ENDIF
> 
>         IF ( gasidxs(k) == so2v_idx .AND. so2vnegval) THEN
>            fsimrad(1:ns, 1) = fsimrad(1:ns, 1) * (1.0d0 + database(so2v_idx,refidx(1:ns)) * so2vadj)
>            tracegas(k, 4) = newso2 - so2vadj; fitvar_rad(j) = tracegas(k, 4)
>         ENDIF
> 
>         IF ( gasidxs(k) == no2_t1_idx .AND. no2negval) THEN
>            fsimrad(1:ns, 1) = fsimrad(1:ns, 1) * ( 1.0d0 + database(no2_t1_idx,refidx(1:ns)) * no2adj )
>            tracegas(k, 4) = newno2 - no2adj; fitvar_rad(j) = tracegas(k, 4)
>         ENDIF
> 
>         IF ( gasidxs(k) == hcho_idx .AND. hchonegval) THEN
>            fsimrad(1:ns, 1) = fsimrad(1:ns, 1) * (1.0d0 + database(hcho_idx,refidx(1:ns)) * hchoadj)
>            tracegas(k, 4) = newhcho - hchoadj; fitvar_rad(j) = tracegas(k, 4)
>         ENDIF
> 
>         IF ( gasidxs(k) == bro_idx .AND. bronegval) THEN
>            fsimrad(1:ns, 1) = fsimrad(1:ns, 1) * ( 1.d0 + database(bro_idx,refidx(1:ns)) * broadj)
>            tracegas(k, 4) = newbro - broadj; fitvar_rad(j) = tracegas(k, 4)
>         ENDIF
>      ENDIF
>   ENDDO
> 
> 
329c589
<     
---
> 
333,334c593,594
<   ! WRITE(77, '(f12.5, 43d14.6)') fitwavs(i), simrad(i), ozwf(i, 1:nlay, 1), albwf(i, 1)!, taodwf(i, 1) !&
<   !        !, o3shiwf(i, 1) !* ozprof(1:nlay)
---
>   ! WRITE(77, '(f12.5, 43d14.6)') fitwavs(i), simrad(i), ozwf(i, 1:nlay, 1), albwf(i, 1) &!, taodwf(i, 1) !&
>   !        , o3shiwf(i, 1) !* ozprof(1:nlay)
338,342c598
< !!$
< !!$  do i = 1,ns
< !!$
< !!$  write(*,*)  i, so2zwf(i, 1)
< !!$  enddo
---
> 
356c612
<       
---
> 
366d621
<  
382d636
<       
385,387c639
<       
<      IF (.NOT. vary_sfcalb) simrad(fidx:lidx) = simrad(fidx:lidx) +  albothwf(fidx:lidx, albord) * fitvar_rad(j)         
<      
---
>      IF (.NOT. vary_sfcalb) simrad(fidx:lidx) = simrad(fidx:lidx) +  albothwf(fidx:lidx, albord) * fitvar_rad(j)        
389c641
<          
---
> 
394c646
<         
---
> 
397c649
<         
---
> 
401c653
<         simrad(fidx:lidx) = simrad(fidx:lidx) +  wfcothwf(fidx:lidx, wfcord) * fitvar_rad(j)        
---
>         IF (.NOT. vary_sfcalb) simrad(fidx:lidx) = simrad(fidx:lidx) +  wfcothwf(fidx:lidx, wfcord) * fitvar_rad(j)        
412c664
<     
---
> 
420,421d671
< 
< 
427,433c677,681
<  
< 
< 
<   IF (num_iter == 0) THEN
<      CALL UV1_SPIKE_DETECT(ns, fitspec, simrad, nsaa_spike) ! fitweights corrected
<   ENDIF
< 
---
>   ! commented out by zcai@2016m0630 
>   !IF (num_iter == 0) THEN
>   !   CALL UV1_SPIKE_DETECT(ns, fitspec, simrad, nsaa_spike)
>   !ENDIF
>   
438c686,695
<   chisq  = SUM((fitres / fitweights(1:ns))**2.0)
---
>   IF (.NOT.do_sy_diagonal) THEN 
>      Sy = merr_covar(1:ns, 1:ns) 
>      CALL sq_matrix_invert(Sy, ns, Sy_inv)
>      y1(1:ns, 1) = fitres
>      chi = MATMUL(MATMUL(TRANSPOSE(y1), sy_inv),y1)
>      chisq = chi(1, 1)
>   ELSE
>      chisq  = SUM((fitres / fitweights(1:ns))**2.0)
>   ENDIF
> 
441c698
<           / REAL(ns, KIND=dp))
---
>        / REAL(ns, KIND=dp))
447c704,715
<         allchisq(i) = SUM((fitres(fidx:lidx) / fitweights(fidx:lidx))**2.0)
---
>         IF (.NOT.do_sy_diagonal) THEN
>            j = lidx-fidx+1
>            ALLOCATE(y1tmp(j, 1), sy_invtmp(j, j)) 
>            y1tmp(:, 1)    = y1(fidx:lidx, 1)
>            sy_invtmp(:, :)= sy_inv(fidx:lidx, fidx:lidx)
>     
>            chi = MATMUL(MATMUL(TRANSPOSE(y1tmp),sy_invtmp),y1tmp)
>            allchisq(i) = chi(1, 1)
>            DEALLOCATE(y1tmp, sy_invtmp)
>         ELSE
>            allchisq(i) = SUM((fitres(fidx:lidx) / fitweights(fidx:lidx))**2.0)
>         ENDIF
460c728
<         
---
> 
471c739
<      
---
> 
478d745
< 
481,486d747
<   !DO i = 1, ns
<   !   WRITE(90, '(F8.3, 2D14.6)') fitwavs(i), EXP(fitspec(i)), EXP(simrad(i))
<   !ENDDO
<   !CLOSE (90)
<   !print *, sza, vza, aza
<   !STOP
493c754
<    
---
> 
501c762
<  
---
> 
504c765
<     
---
> 
512a774,783
> 
>         IF ( do_alb_longwav .AND. numwin == 2 .AND. .NOT. (which_cld == 5 .AND. use_retalb)) THEN
>            ! Find the index of alb_swav
>            albeidx = MINVAL(MINLOC(waves(fidx:lidx), mask=(waves(fidx:lidx) >=alb_ewav)))
>            albeidx = albeidx + fidx - 1
>            albsidx = MINVAL(MAXLOC(waves(fidx:lidx), mask=(waves(fidx:lidx) <=alb_swav)))
>            albsidx = albsidx + fidx - 1
>            IF (albsidx < fidx) albsidx = fidx
>            IF (albeidx > lidx) albeidx = lidx
>         ENDIF
513a785,787
>            !IF ( do_alb_longwav .AND. fitvar_rad_str(k) == '2ba0' ) THEN
>            !   dyda(albsidx:lidx, j) = albwf(albsidx:lidx, 1)
>            !ELSE 
515,516c789,801
<         ELSE 
<            dyda(fidx:lidx, j)=albothwf(fidx:lidx, albord)
---
>            !ENDIF
>            !dyda(albsidx:lidx, j) = albwf(albsidx:lidx, 1)
>         ELSE
>            IF (do_alb_longwav .AND. numwin == 2 .AND. .NOT. (which_cld == 5 .AND. use_retalb) &
>                 .AND. (fitvar_rad_str(k) == '2ba1' .OR. fitvar_rad_str(k) == '2ba2') .AND.     &
>                 albsidx > 0 .AND. albeidx > 0 .AND.  albsidx > fidx .AND. albeidx < lidx) THEN
>               WRITE(*, *) 'Using longer wavelength dyda only '
>               IF (albeidx > 0 .AND. albeidx < lidx) dyda(albeidx:lidx, j) = albothwf(albeidx:lidx, albord)
>               IF (albsidx > 0 .AND. albsidx > fidx) dyda(fidx:albsidx, j) = albothwf(fidx:albsidx, albord)
>            ELSE 
>               dyda(fidx:lidx, j)=albothwf(fidx:lidx, albord)
>            ENDIF
>            !dyda(albsidx:lidx, j) = albothwf(albsidx:lidx, albord)
518c803
<               
---
> 
522,525c807
<            the_ai = (dyda(lidx, j) - dyda(fidx, j)) * fitvar(j) * 100. / (waves(lidx)-waves(fidx)) * 20.          
<            IF ( radcalwrt .AND. do_simu) THEN !JBAK
<                the_ai = (dyda(lidx, j) - dyda(fidx, j)) / (waves(lidx)-waves(fidx)) * 20.
<            ENDIF
---
>            the_ai = (dyda(lidx, j) - dyda(fidx, j)) * fitvar(j) * 100. / (waves(lidx)-waves(fidx)) * 20.
527c809,810
<      ENDDO  
---
>      ENDDO
> 
535a819,828
>         IF ( do_alb_longwav .AND. numwin == 2 .AND. .NOT. (which_cld == 5 .AND. use_retalb)) THEN
>            ! Find the index of alb_swav
>            albeidx = MINVAL(MINLOC(waves(fidx:lidx), mask=(waves(fidx:lidx) >=alb_ewav)))
>            albeidx = albeidx + fidx - 1
>            albsidx = MINVAL(MAXLOC(waves(fidx:lidx), mask=(waves(fidx:lidx) <=alb_swav)))
>            albsidx = albsidx + fidx - 1
>            IF (albsidx < fidx) albsidx = fidx
>            IF (albeidx > lidx) albeidx = lidx
>         ENDIF
> 
536a830,832
>            !IF ( do_alb_longwav .AND. fitvar_rad_str(k) == '2fc0' ) THEN
>            !   dyda(fidx:lidx, j) = cfracwf(albsidx:lidx, 1)
>            !ELSE
537a834
>            !ENDIF
539c836,843
<            dyda(fidx:lidx, j) = wfcothwf(fidx:lidx, wfcord)
---
>            IF (do_alb_longwav .AND. numwin == 2  .AND. .NOT. (which_cld == 5 .AND. use_retalb) &
>                 .AND.  (fitvar_rad_str(k) == '2fc1' .OR. fitvar_rad_str(k) == '2fc2')) THEN
>               WRITE(*, *) 'Using longer wavelength dyda only '
>               IF (albeidx > 0 .AND. albeidx < lidx) dyda(albeidx:lidx, j) = wfcothwf(albeidx:lidx, albord)
>               IF (albsidx > 0 .AND. albsidx > fidx) dyda(fidx:albsidx, j) = wfcothwf(fidx:albsidx, albord)
>            ELSE 
>               dyda(fidx:lidx, j) = wfcothwf(fidx:lidx, wfcord)
>            ENDIF
541c845
<      ENDDO  
---
>      ENDDO
544a849,854
>      ! do not use longer waves for ozone, this make no sense 
>      !IF (do_alb_longwav .AND. waves(ns) > 330.0 ) THEN
>      !   lidx = MINVAL(MINLOC(waves(1:ns), mask=(waves(1:ns) >=330.0)))
>      !   IF (lidx > 0 .AND. lidx <= ns) dyda(lidx:ns, ozf_fidx:ozf_lidx) = 0.0D0
>      !ENDIF
> 
550c860
<          
---
> 
563d872
<     
567d875
<       
571d878
<      
575,578c882,885
<         IF (ridx == so2_idx .OR. ridx == hcho_idx .OR. ridx == no2_t1_idx .OR. &
<            ridx == bro_idx .OR. ridx == bro2_idx .OR. ridx == so2v_idx .OR. ridx == o2o2_idx) THEN
<         !IF (ridx /= us1_idx .AND. ridx /= us2_idx .AND. ridx /= comm_idx .AND. ridx /= com1_idx &
<         !     .AND. ridx /= com2_idx .AND. ridx /= com3_idx .AND. ridx /= fsl_idx .AND. ridx /= rsl_idx) THEN
---
>         !IF (ridx == so2_idx .OR. ridx == hcho_idx .OR. ridx == no2_t1_idx .OR. &
>         !   ridx == bro_idx .OR. ridx == bro2_idx .OR. ridx == so2v_idx .OR. ridx == o2o2_idx) THEN
>         IF (ridx /= us1_idx .AND. ridx /= us2_idx .AND. ridx /= comm_idx .AND. ridx /= com1_idx &
>              .AND. ridx /= com2_idx .AND. ridx /= com3_idx .AND. ridx /= fsl_idx .AND. ridx /= rsl_idx) THEN
581d887
<            
583,585c889,891
<         ! xliu, 11/01/2011, the following for undersampling is incorrect
<         !ELSE  IF (ridx == us1_idx .OR. ridx == us2_idx) THEN
<         !   dyda(:, i) = - EXP(fitspec(1:ns)) * database(ridx, refidx(1:ns))   
---
>            ! xliu, 11/01/2011, the following for undersampling is incorrect
>            !ELSE  IF (ridx == us1_idx .OR. ridx == us2_idx) THEN
>            !   dyda(:, i) = - EXP(fitspec(1:ns)) * database(ridx, refidx(1:ns))  
587d892
< 
589d893
<           
596d899
<            
601c904
<            ENDIF      
---
>            ENDIF
604c907
<         ENDIF 
---
>         ENDIF
608d910
<           
612c914
<      
---
> 
615d916
<   
617d917
<           
631c931
<            ENDIF      
---
>            ENDIF
643c943
<         
---
> 
656c956
<            IF (fit_atanring) CYCLE !F
---
>            IF (fit_atanring) CYCLE
666,671d965
<         ELSE IF (ig == 8 .and. ncm > 0) THEN  !JBAK this is just for OMPS
<             nord = ncm; tmpind = cmind; tmpfind = cmfind; tmpwins = cmwins
<             call get_cmc_spec (ns, fitwavs, corr)
<             cmcspec(1:ns) = corr(1:ns)
<             temporwf =  corr(1:ns)
<             if (.not. use_lograd) temporwf = temporwf * simrad
675c969
<         IF (nord > 0 .AND. ig >= 3 .AND. ig <= nothgrp .AND. ig /= 4 .and. ig /=8) THEN
---
>         IF (nord > 0 .AND. ig >= 3 .AND. ig <= nothgrp .AND. ig /= 4) THEN
686d979
<              
693d985
<             
701d992
< 
704,705d994
<              
<                 
711d999
<               
723d1010
<                         
745d1031
<                   
752d1037
<               
775c1060
<               
---
> 
785,793c1070,1089
<     !WRITE(92, *) ns, nf
<     !DO i = 1, ns
<     !   WRITE(92, '(f10.4, 80d14.6)') fitwavs(i), dyda(i, 1:nf)
<     !ENDDO
<     !errstat = pge_errstat_error; RETURN
<     !
<     !CLOSE(92)
<     !STOP
<      
---
>      !WRITE(92, *) ns, nf
>      !DO i = 1, ns
>      !   WRITE(92, '(f10.4, 80d14.6)') fitwavs(i), dyda(i, 1:nf)
>      !ENDDO
>      !errstat = pge_errstat_error; RETURN
>      !
>      !CLOSE(92)
>      !STOP
> 
>      ! Remove longer wavelengths wfs except for alb and cloud
>      !if ( do_alb_longwav) then 
>      ! idx330 = maxval(minloc(waves(1:ns), mask=(waves(1:ns)>=330.0)))
>      ! do i = 1, nf
>      !   !if ( (i < albfidx .or. i > albfidx + nfalb - 1) .and. i .ne. ecfrfind ) then  
>      !   if ( (i < albfidx .or. i > albfidx + nfalb - 1) )then 
>      !      dyda(idx330:ns,i) = 0.0d0 
>      !   endif
>      ! enddo 
>      !endif
> 
797c1093
<      
---
> 
800c1096
<      
---
> 
805c1101
<   
---
> 
808c1104
<   
---
> 
============================
pseudo_model.f90_0512
============================
raman.f90
39,60c39
<       SUBROUTINE raman (nulo, nuhi, nline, nz)
<                        !(refdir, nulo, nuhi, nline, nz, T, sca, cossza,&
<                        ! R, tran,rhos, ring)
<      
<       USE OMSAO_precision_module
<       USE OMSAO_parameters_module, ONLY : maxchlen, pi, o2mix, N2mix, CO2mix
<       USE OMSAO_variables_module,  ONLY : refdir=>refdbdir, sca=>the_sca_atm
<       USE ozprof_data_module,      ONLY : rhos=>frhos
<       USE ring_data_module,        ONLY : maxnu, cossza, ring, st, vt, T=>avgt
< 
<       IMPLICIT NONE
< 
< ! ========================
< ! Input/output variables
< ! ========================
< !      CHARACTER (LEN=maxchlen), INTENT(IN)                 :: refdir
<       INTEGER, INTENT (IN)                                 :: nulo, nuhi, nline, nz
< !      REAL (KIND=dp), DIMENSION(nulo:nuhi, nz), INTENT(IN) :: R, tran
< !      REAL (KIND=dp), DIMENSION(nline),        INTENT(OUT) :: ring
< !      REAL (KIND=dp), DIMENSION(nz),         INTENT(INOUT) :: rhos
< !      REAL (KIND=dp), INTENT(IN)                           :: sca, cossza, T
< 
---
> SUBROUTINE raman(refdir, nulo, nuhi, nline, nz, T, sca, cossza, R, tran, rhos, ring)
62c41,43
<      REAL (KIND=dp), DIMENSION(maxnu, nz) :: R, tran
---
>   USE OMSAO_precision_module
>   USE OMSAO_parameters_module, ONLY : maxchlen, pi, o2mix, N2mix, CO2mix
>   IMPLICIT NONE
63a45,53
>   ! ========================
>   ! Input/output variables
>   ! ========================
>   CHARACTER (LEN=maxchlen), INTENT(IN)                 :: refdir
>   INTEGER, INTENT (IN)                                 :: nulo, nuhi, nline, nz
>   REAL (KIND=dp), DIMENSION(nulo:nuhi, nz), INTENT(IN) :: R, tran
>   REAL (KIND=dp), DIMENSION(nline),        INTENT(OUT) :: ring
>   REAL (KIND=dp), DIMENSION(nz),         INTENT(INOUT) :: rhos
>   REAL (KIND=dp), INTENT(IN)                           :: sca, cossza, T
65,69c55,59
< ! ========================
< ! Local variables
< ! ========================
<      REAL (KIND=dp), PARAMETER :: c1=1.438769, NL=2.686763D19
<      INTEGER,        PARAMETER :: N2Jmax=28, O2maxJ=53, O2max=94, maxpos=218, pixelno=6521 
---
>   ! ========================
>   ! Local variables
>   ! ========================
>   REAL (KIND=dp), PARAMETER :: c1=1.438769, NL=2.686763D19
>   INTEGER,        PARAMETER :: N2Jmax=28, O2maxJ=53, O2max=94, maxpos=218, pixelno=6521 
71,75c61,65
<      INTEGER        :: nu, iz, j, k, fidx, lidx
<      REAL (KIND=dp) :: ZN2, ZO2, temp, temp1, temp2, phasefnc, pi3, avgt
<      REAL (KIND=dp), DIMENSION (nz)                         :: tempz
<      REAL (KIND=dp), DIMENSION (nulo:nuhi)                  :: gammaN2, gammaO2
<      REAL (KIND=dp), DIMENSION(nulo+maxpos:nuhi-maxpos)     :: RaylP, nr, Raylro, N2so, O2so, I_tot, &
---
>   INTEGER        :: nu, iz, j, k, fidx, lidx
>   REAL (KIND=dp) :: ZN2, ZO2, temp, temp1, temp2, phasefnc, pi3, avgt
>   REAL (KIND=dp), DIMENSION (nz)                         :: tempz
>   REAL (KIND=dp), DIMENSION (nulo:nuhi)                  :: gammaN2, gammaO2
>   REAL (KIND=dp), DIMENSION(nulo+maxpos:nuhi-maxpos)     :: RaylP, nr, Raylro, N2so, O2so, I_tot, &
77,82c67,72
<      REAL (KIND=dp), DIMENSION(nulo+maxpos:nuhi-maxpos, nz) :: I, N2sumin, O2sumin, diff
<      REAL (KIND=dp), DIMENSION(0:N2Jmax)                    :: N2pop
<      REAL (KIND=dp), DIMENSION(0:2*N2Jmax-3)                :: N2csec
<      REAL (KIND=dp), DIMENSION(0:O2maxJ)                    :: O2popz
<      REAL (KIND=dp), DIMENSION(0:2*O2max-7)                 :: O2csec, O2pop
<      CHARACTER (len=maxchlen) :: N2En, N2pos, O2En, O2pos, O2EnfZ, O2J, O2JfZ, O2PT, N2PT 
---
>   REAL (KIND=dp), DIMENSION(nulo+maxpos:nuhi-maxpos, nz) :: I, N2sumin, O2sumin, diff
>   REAL (KIND=dp), DIMENSION(0:N2Jmax)                    :: N2pop
>   REAL (KIND=dp), DIMENSION(0:2*N2Jmax-3)                :: N2csec
>   REAL (KIND=dp), DIMENSION(0:O2maxJ)                    :: O2popz
>   REAL (KIND=dp), DIMENSION(0:2*O2max-7)                 :: O2csec, O2pop
>   CHARACTER (len=maxchlen) :: N2En, N2pos, O2En, O2pos, O2EnfZ, O2J, O2JfZ, O2PT, N2PT 
84,93c74,81
<     LOGICAL,                                 SAVE :: first = .TRUE.
<     REAL (KIND=dp), DIMENSION(0:N2Jmax),     SAVE :: N2E
<     REAL (KIND=dp), DIMENSION(0:2*N2Jmax-3), SAVE :: N2b
<     REAL (KIND=dp), DIMENSION(0:O2maxJ),     SAVE :: O2EnZ
<     REAL (KIND=dp), DIMENSION(0:2*O2max-7),  SAVE :: O2E,  O2b
<     INTEGER, DIMENSION (0:O2maxJ),           SAVE :: O2JZ
<     INTEGER, DIMENSION (0:2*O2max-7),        SAVE :: O2J2, O2shift
<     INTEGER, DIMENSION (0:2*N2Jmax-3),       SAVE :: N2shift  
<     REAL (kind=dp), Dimension(nz) :: tmpn2, tmpo2, tmpdiff,dum1, dum2 , dum   ! jbak   
<     REAL (kind=dp) :: dum_I_toc ,dum_R_toc, dum_ring, dum_one
---
>   LOGICAL,                                 SAVE :: first = .TRUE.
>   REAL (KIND=dp), DIMENSION(0:N2Jmax),     SAVE :: N2E
>   REAL (KIND=dp), DIMENSION(0:2*N2Jmax-3), SAVE :: N2b
>   REAL (KIND=dp), DIMENSION(0:O2maxJ),     SAVE :: O2EnZ
>   REAL (KIND=dp), DIMENSION(0:2*O2max-7),  SAVE :: O2E,  O2b
>   INTEGER, DIMENSION (0:O2maxJ),           SAVE :: O2JZ
>   INTEGER, DIMENSION (0:2*O2max-7),        SAVE :: O2J2, O2shift
>   INTEGER, DIMENSION (0:2*N2Jmax-3),       SAVE :: N2shift  
95,100c83
<     Do iz = 1, nz 
<      R(nulo:nuhi, iz)    = st(1:nline, iz)
<      Tran(nulo:nuhi, iz) = vt(1:nline, iz)
<     ENDDO
<      iz = 0 
< ! Real input parameters needed for each calculation
---
>   ! Real input parameters needed for each calculation
128c111
<      do k = 0, O2maxJ
---
>      DO k = 0, O2maxJ
147,151c130,134
<      ENDIF
<    
<     fidx = nulo + maxpos; lidx = nuhi - maxpos
< ! calculate dynamic optical parameters
<      DO nu = nulo, nuhi
---
>   ENDIF
> 
>   fidx = nulo + maxpos; lidx = nuhi - maxpos
>   ! calculate dynamic optical parameters
>   DO nu = nulo, nuhi
155,156c138
<      	
<      ENDDO
---
>   ENDDO
158,162c140,144
<      pi3 = pi ** 3
<      DO nu = fidx, lidx 
<         temp   = (nu / 1d4) ** 2
<         nr(nu) = 1d-4 * (0.7041 + 315.9 / (157.39 - temp ) )
<         nr(nu) = nr(nu) + 8.4127d-4 / (50.429 - temp )
---
>   pi3 = pi ** 3
>   DO nu = fidx, lidx 
>      temp   = (nu / 1d4) ** 2
>      nr(nu) = 1d-4 * (0.7041 + 315.9 / (157.39 - temp ) )
>      nr(nu) = nr(nu) + 8.4127d-4 / (50.429 - temp )
164,166c146,148
<         e(nu) = O2mix * (0.096 + 0.001385 * temp + 1.448d-4 * temp ** 2)
<         e(nu) = e(nu) + (N2mix * (0.034 + 0.000317 * temp) + CO2mix * 0.15 )
<         e(nu) = e(nu) * 4.5d0 !9.0d0 /2.0d0
---
>      e(nu) = O2mix * (0.096 + 0.001385 * temp + 1.448d-4 * temp ** 2)
>      e(nu) = e(nu) + (N2mix * (0.034 + 0.000317 * temp) + CO2mix * 0.15 )
>      e(nu) = e(nu) * 4.5d0 !9.0d0 /2.0d0
168,173c150,154
< ! code doesn't work below ~316 nm because nu**2 > maxint, use real         
<        Raylcsec(nu) = 32.0d0 * (REAL(nu))**4 * pi3 * (nr(nu))**2 * (1.0d0 + e(nu) / 4.5d0) / 3.d0 
<        Raylcsec(nu) = Raylcsec(nu) / NL / NL     
<        Raylro(nu)   = 6.0d0 * e(nu) / (45.d0 + 7.d0 * e(nu))  
<       
<      ENDDO
---
>      ! code doesn't work below ~316 nm because nu**2 > maxint, use real         
>      Raylcsec(nu) = 32.0d0 * (REAL(nu))**4 * pi3 * (nr(nu))**2 * (1.0d0 + e(nu) / 4.5d0) / 3.d0 
>      Raylcsec(nu) = Raylcsec(nu) / NL / NL     
>      Raylro(nu)   = 6.0d0 * e(nu) / (45.d0 + 7.d0 * e(nu))         
>   ENDDO
175,179c156,160
< ! calculate Rayleigh and Raman scattering phase functions
<       temp = COS(sca * pi / 180.d0) ** 2
<       phasefnc = (13.d0 + temp) * 3.d0 / 40.d0  
<       RaylP(fidx:lidx) = 1.d0 + Raylro(fidx:lidx) + (1.d0 - Raylro(fidx:lidx) ) * temp
<       RaylP(fidx:lidx) = 3.d0 / (4.d0 + 2.d0 * Raylro(fidx:lidx) ) * RaylP(fidx:lidx)        
---
>   ! calculate Rayleigh and Raman scattering phase functions
>   temp = COS(sca * pi / 180.d0) ** 2
>   phasefnc = (13.d0 + temp) * 3.d0 / 40.d0  
>   RaylP(fidx:lidx) = 1.d0 + Raylro(fidx:lidx) + (1.d0 - Raylro(fidx:lidx) ) * temp
>   RaylP(fidx:lidx) = 3.d0 / (4.d0 + 2.d0 * Raylro(fidx:lidx) ) * RaylP(fidx:lidx)        
181c162
<       temp = 256 * pi ** 5 / 27
---
>   temp = 256 * pi ** 5 / 27
183,203c164,167
< ! The following loop could be avoided by just using an effective temperature
< ! Will have small effect on the computed Ring effect spectrum (the effect on
< ! troospheric column ozone for one orbit is (0.014+/-0.06 DU)
< ! Use effective temperature, replace T(iz) with T
<       
< !DO iz = 1,nz	     
< !  calculate partitioning of N2  	
< !iz = 12
<       ZN2=0
<       DO j = 0, N2Jmax
<          IF ( ifix(10* (j / 2.0 - ifix( j / 2.0) ) ) == 5) THEN
<             N2pop(j) = 3 * ( 2 * j + 1.0d0) * EXP(-c1 * N2E(j) / T) 
<          ELSE
<             N2pop(j) = 6 * ( 2 * j + 1.0d0) * EXP(-c1 * N2E(j) / T)
<          ENDIF
<          ZN2= ZN2 + N2pop(j)  
<       ENDDO
< ! calculate static part of Anti-Stokes cross sections for N2
<        DO j = 0, N2Jmax - 2 
<              N2csec(j) = temp * N2pop(j + 2) * N2b(j) /  ZN2
<       ENDDO
---
>   ! The following loop could be avoided by just using an effective temperature
>   ! Will have small effect on the computed Ring effect spectrum (the effect on
>   ! troospheric column ozone for one orbit is (0.014+/-0.06 DU)
>   ! Use effective temperature, replace T(iz) with T
205,208c169,180
< ! calculate static part of Stokes cross sections for N2	
<       DO j = N2Jmax - 1, 2 * N2Jmax - 3 
<          N2csec(j) = temp * N2pop(j - N2Jmax + 1) * N2b(j) / ZN2
<       ENDDO
---
>   !DO iz = 1,nz	     
>   !  calculate partitioning of N2  	
>   !iz = 12
>   ZN2=0
>   DO j = 0, N2Jmax
>      IF ( ifix(10* (j / 2.0 - ifix( j / 2.0) ) ) == 5) THEN
>         N2pop(j) = 3 * ( 2 * j + 1.0d0) * EXP(-c1 * N2E(j) / T) 
>      ELSE
>         N2pop(j) = 6 * ( 2 * j + 1.0d0) * EXP(-c1 * N2E(j) / T)
>      ENDIF
>      ZN2= ZN2 + N2pop(j)  
>   ENDDO
210,215c182,197
< ! calculate state sum for O2 
<       ZO2 = 0
<       DO k = 0, O2maxJ
<         O2popz(k) = ( 2 * O2JZ(k) + 1 ) * EXP(- c1 * O2EnZ(k) / T )
<         ZO2 = ZO2 + O2popz(k)
<       ENDDO
---
>   ! calculate static part of Anti-Stokes cross sections for N2
>   DO j = 0, N2Jmax - 2 
>      N2csec(j) = temp * N2pop(j + 2) * N2b(j) /  ZN2
>   ENDDO
>   
>   ! calculate static part of Stokes cross sections for N2	
>   DO j = N2Jmax - 1, 2 * N2Jmax - 3 
>      N2csec(j) = temp * N2pop(j - N2Jmax + 1) * N2b(j) / ZN2
>   ENDDO
>   
>   ! calculate state sum for O2 
>   ZO2 = 0
>   DO k = 0, O2maxJ
>      O2popz(k) = ( 2 * O2JZ(k) + 1 ) * EXP(- c1 * O2EnZ(k) / T )
>      ZO2 = ZO2 + O2popz(k)
>   ENDDO
217,272c199,203
< ! O2 cross sections
<        DO k = 0, 2 * O2max-7
<         O2pop(k) = (2 * O2J2(k) + 1 ) * EXP(-c1 * O2E(k) / T )
<         O2csec(k)= temp * O2pop(k) * O2b(k) / ZO2
<       ENDDO
< 
< 
< ! set arrays to zero initially
<        N2so(fidx:lidx) = 0.0; N2sumin(fidx:lidx, 1:nz) = 0.0
<        O2so(fidx:lidx) = 0.0; O2sumin(fidx:lidx, 1:nz) = 0.0
< 
< ! calculate relative amounts of light shifted in/out of a given nu     
<      DO nu = fidx, lidx
<         temp1 = gammaN2(nu) * gammaN2(nu)
<         temp2 = (REAL(nu))**4
<         tmpn2(1:nz) = 0.d0  
<           DO j = 0, 2 * N2Jmax-3
<             N2so(nu) = N2so(nu) + N2csec(j) * (REAL(nu - N2shift(j)))**4 * temp1
<             tmpn2(1:nz) =  tmpn2(1:nz) + R(nu + N2shift(j), 1:nz) / R(nu, 1:nz)*N2csec(j) * gammaN2( nu + N2shift(j)) ** 2 * temp2                
<           ENDDO
<           N2sumin(nu, 1:nz) = tmpn2(1:nz)    
<        
<          temp1 = gammaO2(nu) * gammaO2(nu)
<          tmpo2(:) =  0.d0      
<          DO k = 0, 2 * O2max-7           
<           O2so(nu) = O2so(nu) + O2csec(k) * (REAL(nu - O2shift(k)))**4 * temp1
<           tmpo2(1:nz) =  tmpo2(1:nz) + R(nu + O2shift(k), 1:nz) / R(nu, 1:nz) * O2csec(k) &
<              * gammaO2(nu + O2shift(k)) ** 2 * temp2
<         ENDDO
<         O2sumin(nu, 1:nz) = tmpo2(1:nz)
< 
<         tmpdiff(1:nz) = N2mix * (tmpN2(1:nz) - N2so(nu)) + O2mix * (tmpO2(1:nz) - O2so(nu))
<         diff(nu, 1:nz) = tmpdiff(1:nz) 
<         I(nu, 1:nz) = R(nu, 1:nz)  * ( 1.0 + phasefnc * tmpdiff(1:nz) / (Raylcsec(nu) * RaylP(nu)))
<      
<       
<          tempz(1:nz) =  rhos(1:nz) *  tran(nu, 1:nz)   
<          dum1(1:nz) = R(nu, 1:nz)  * ( 1.0 + phasefnc * tmpdiff(1:nz) / (Raylcsec(nu) * RaylP(nu))) ! I(nu,1:nz)
<     !     dum1(1:nz)  =  I(nu, 1:nz)
<          dum2(1:nz) = R(nu, 1:nz)
<          I_tot(nu)  = sum(dum1(1:nz)*tempz(1:nz)) !  I_tot(nu) = sum(I*tempz)
<          R_tot(nu)  = sum(dum2(1:nz)*tempz(1:nz)) ! I_tot(nu) = sum(r*tempz)
<          ring(nu - nulo + 1) = I_tot(nu)/R_tot(nu)  - 1.0d0
<       
< !         print * ,nu, ring(nu - nulo + 1)
<          ! print * , nu, tempz(1), i_tot(nu), r_tot(nu), ring(nu)
<     
<     ENDDO
<  
<  
<        ring(1:maxpos) = 0.d0
<        ring(nline - maxpos + 1 : nline) = 0.d0
< 
<      
< 
<       RETURN
---
>   ! O2 cross sections
>   DO k = 0, 2 * O2max-7
>      O2pop(k) = (2 * O2J2(k) + 1 ) * EXP(-c1 * O2E(k) / T )
>      O2csec(k)= temp * O2pop(k) * O2b(k) / ZO2
>   ENDDO
274,356c205,211
<       END SUBROUTINE raman
< 
< 
< subroutine raman2 (nulo, nuhi, nline, nz) !(refdir, nulo, nuhi, nline, nz, T, sca, cossza,&
<                        ! R, tran,rhos, ring)   
<       USE OMSAO_precision_module
<       USE OMSAO_parameters_module, ONLY : maxchlen, pi, o2mix, N2mix, CO2mix
<       USE OMSAO_variables_module,  ONLY : refdir=>refdbdir, sca=>the_sca_atm
<       USE ozprof_data_module,      ONLY : rhos=>frhos
<       USE ring_data_module,        ONLY : maxnu, cossza, ring, r=>st, tran=>vt, T=>avgt
< 
<       IMPLICIT NONE
< 
< 
< ! ========================
< ! In/OUT variables
< ! ========================
<       INTEGER, INTENT (IN)                                 :: nulo, nuhi, nline, nz
< ! ========================
< ! Local variables
< ! ========================
<      REAL (KIND=dp), PARAMETER :: c1=1.438769, NL=2.686763D19
<      INTEGER,        PARAMETER :: N2Jmax=28, O2maxJ=53, O2max=94, maxpos=218, pixelno=6521 
<      
<      INTEGER        :: inu, nu, iz, j, k, fidx, lidx
<      REAL (KIND=dp) :: ZN2, ZO2, temp, temp1, temp2, phasefnc, pi3, avgt
<      REAL (KIND=dp), DIMENSION (nz)                         :: tempz
<      REAL (KIND=dp), DIMENSION (nline)                      :: gammaN2, gammaO2  ! (nulo:nuhi)
<     ! REAL (KIND=dp), DIMENSION(nline, nz)                   :: R, tran
<      REAL (KIND=dp), DIMENSION(1+maxpos:nline-maxpos)       :: RaylP, nr, Raylro, N2so, O2so, I_tot, &  !!!!!!!!!!!!!!!
<                                                                R_tot, e, Raylcsec                      !!!!!!!!!!!!
<      REAL (KIND=dp), DIMENSION(1+maxpos:nline-maxpos, nz) :: I, N2sumin, O2sumin, diff               !!!!!!!!!!!!!
<      REAL (KIND=dp), DIMENSION(0:N2Jmax)                    :: N2pop
<      REAL (KIND=dp), DIMENSION(0:2*N2Jmax-3)                :: N2csec
<      REAL (KIND=dp), DIMENSION(0:O2maxJ)                    :: O2popz
<      REAL (KIND=dp), DIMENSION(0:2*O2max-7)                 :: O2csec, O2pop
<      CHARACTER (len=maxchlen) :: N2En, N2pos, O2En, O2pos, O2EnfZ, O2J, O2JfZ, O2PT, N2PT 
< 
<     LOGICAL,                                 SAVE :: first = .TRUE.
<     REAL (KIND=dp), DIMENSION(0:N2Jmax),     SAVE :: N2E
<     REAL (KIND=dp), DIMENSION(0:2*N2Jmax-3), SAVE :: N2b
<     REAL (KIND=dp), DIMENSION(0:O2maxJ),     SAVE :: O2EnZ
<     REAL (KIND=dp), DIMENSION(0:2*O2max-7),  SAVE :: O2E,  O2b
<     INTEGER, DIMENSION (0:O2maxJ),           SAVE :: O2JZ
<     INTEGER, DIMENSION (0:2*O2max-7),        SAVE :: O2J2, O2shift
<     INTEGER, DIMENSION (0:2*N2Jmax-3),       SAVE :: N2shift  
<     REAL (kind=dp), Dimension(nz) :: tmpn2, tmpo2, tmpdiff,dum1, dum2 , dum   ! jbak   
<     REAL (kind=dp) :: dum_I_toc ,dum_R_toc, dum_ring, dum_one
< 
< 
< ! Real input parameters needed for each calculation
< 
<   IF (first) THEN
<      N2En   = TRIM(ADJUSTL(refdir)) // 'raman/N2En.txt'
<      N2pos  = TRIM(ADJUSTL(refdir)) // 'raman/N2pos.txt'     
<      O2En   = TRIM(ADJUSTL(refdir)) // 'raman/O2En.txt'
<      O2pos  = TRIM(ADJUSTL(refdir)) // 'raman/O2pos.txt'
<      O2EnfZ = TRIM(ADJUSTL(refdir)) // 'raman/O2EnfZ.txt'
<      O2J    = TRIM(ADJUSTL(refdir)) // 'raman/O2J.txt'
<      O2JfZ  = TRIM(ADJUSTL(refdir)) // 'raman/O2JfZ.txt'
<      O2PT   = TRIM(ADJUSTL(refdir)) // 'raman/O2PT.txt' 
<      N2PT   = TRIM(ADJUSTL(refdir)) // 'raman/N2PT.txt'
< 
<      ! Read in the line frequencies and strengths
<      OPEN (48, file = N2PT,  status='old');  OPEN (49, file = N2pos, status='old')
<      DO j = 0, 2 * N2Jmax - 3
<         READ (48, *) N2b(j);  READ (49, *) N2shift(j)
<      ENDDO
<      CLOSE(48); CLOSE(49) 
<      
<      ! calculate partitioning of N2 
<      OPEN(48, file = N2En, status = 'old')     	
<      DO j = 0, N2Jmax
<         READ (48, *) N2E(j)    
<      ENDDO
<      CLOSE(48)
<      
<      ! calculate state sum for O2 
<      OPEN(48, file = O2JfZ,  status='old');     OPEN(49, file = O2EnfZ, status='old') 
<      do k = 0, O2maxJ
<         READ (48,*) O2JZ(k);        READ (49,*) O2EnZ(k)
<      ENDDO
<      CLOSE(48);  CLOSE(49)
---
>   ! set arrays to zero initially
>   N2so(fidx:lidx) = 0.0; N2sumin(fidx:lidx, 1:nz) = 0.0
>   O2so(fidx:lidx) = 0.0; O2sumin(fidx:lidx, 1:nz) = 0.0
>   
>   ! calculate relative amounts of light shifted in/out of a given nu     
>   DO nu = fidx, lidx
>      temp1 = gammaN2(nu) * gammaN2(nu); temp2 = (REAL(nu))**4
358,361c213,216
<      ! O2 cross sections
<      OPEN(48, file = O2J,   status = 'old');   OPEN(49, file = O2En,  status = 'old')  
<      DO k = 0, 2 * O2max-7
<         READ(48, *) O2J2(k); READ(49, *) O2E(k)
---
>      DO j = 0, 2 * N2Jmax-3
>         N2so(nu) = N2so(nu) + N2csec(j) * (REAL(nu - N2shift(j)))**4 * temp1
>         N2sumin(nu, 1:nz) = N2sumin(nu, 1:nz) + R(nu + N2shift(j), 1:nz) / R(nu, 1:nz) * N2csec(j) * &
>              gammaN2( nu + N2shift(j)) ** 2 * temp2
363d217
<      CLOSE(48);  CLOSE(49)
365,383c219,223
<      OPEN(48, file = O2PT,  status = 'old');  OPEN(49, file = O2pos, status = 'old')  
<      DO k = 0, 2 * O2max-7
<         READ(48, *) O2b(k);  READ(49, *) O2shift(k)
<      ENDDO
<      CLOSE(48);  CLOSE(49)
< 
<      first = .FALSE.
<      ENDIF
<    
<     fidx = nulo + maxpos ; lidx = nuhi - maxpos
<     fidx = 1 + maxpos ; lidx = nline - maxpos
< 
<      ! calculate dynamic optical parameters
<      DO nu =  nulo, nuhi
<         inu = nu - nulo + 1
<         temp = (1d0 * nu) ** 2 
<         gammaN2(inu) = -6.01466E-25 + 2.38557E-14 / (1.86099E10 -temp)
<         gammaO2(inu) = 7.149E-26    + 4.59364E-15 / (4.82716E9 - temp)  
< 	
---
>      temp1 = gammaO2(nu) * gammaO2(nu)
>      DO k = 0, 2 * O2max-7           
>         O2so(nu) = O2so(nu) + O2csec(k) * (REAL(nu - O2shift(k)))**4 * temp1
>         O2sumin(nu, 1:nz) = O2sumin(nu, 1:nz) + R(nu + O2shift(k), 1:nz) / R(nu, 1:nz) * O2csec(k) &
>              * gammaO2(nu + O2shift(k)) ** 2 * temp2
385,391d224
< 	
<      pi3 = pi ** 3
<      DO nu =  nulo+maxpos, nuhi-maxpos ! fidx, lidx 
<         inu = nu - nulo + 1
<         temp    = (nu / 1d4) ** 2
<         nr(inu) = 1d-4 * (0.7041 + 315.9 / (157.39 - temp ) )
<         nr(inu) = nr(inu) + 8.4127d-4 / (50.429 - temp )
393,408c226,229
<         e(inu) = O2mix * (0.096 + 0.001385 * temp + 1.448d-4 * temp ** 2)
<         e(inu) = e(inu) + (N2mix * (0.034 + 0.000317 * temp) + CO2mix * 0.15 )
<         e(inu) = e(inu) * 4.5d0 !9.0d0 /2.0d0
< 
<         ! code doesn't work below ~316 nm because nu**2 > maxint, use real         
<         Raylcsec(inu) = 32.0d0 * (REAL(nu))**4 * pi3 * (nr(inu))**2 * (1.0d0 + e(inu) / 4.5d0) / 3.d0 
<         Raylcsec(inu) = Raylcsec(inu) / NL / NL     
<         Raylro(inu)   = 6.0d0 * e(inu) / (45.d0 + 7.d0 * e(inu))    
< 	
<      ENDDO
< 
<       ! calculate Rayleigh and Raman scattering phase functions
<       temp = COS(sca * pi / 180.d0) ** 2
<       phasefnc = (13.d0 + temp) * 3.d0 / 40.d0  
<       RaylP(fidx:lidx) = 1.d0 + Raylro(fidx:lidx) + (1.d0 - Raylro(fidx:lidx) ) * temp
<       RaylP(fidx:lidx) = 3.d0 / (4.d0 + 2.d0 * Raylro(fidx:lidx) ) * RaylP(fidx:lidx)        
---
>      diff(nu, 1:nz) = N2mix * (N2sumin(nu, 1:nz) - N2so(nu)) + O2mix * (O2sumin(nu, 1:nz) - O2so(nu))
>      I(nu, 1:nz) = R(nu, 1:nz) * ( 1.0 + phasefnc * diff(nu, 1:nz) / (Raylcsec(nu) * RaylP(nu)))
>   ENDDO
>   !ENDDO                     ! ends nz loop
410,439c231,236
<       temp = 256 * pi ** 5 / 27
< 
< ! The following loop could be avoided by just using an effective temperature
< ! Will have small effect on the computed Ring effect spectrum (the effect on
< ! troospheric column ozone for one orbit is (0.014+/-0.06 DU)
< ! Use effective temperature, replace T(iz) with T
< 
< 
< 
<       !DO iz = 1,nz	     
<      !  calculate partitioning of N2  	
<      !iz = 12
<       ZN2=0
<       DO j = 0, N2Jmax
<          IF ( ifix(10* (j / 2.0 - ifix( j / 2.0) ) ) == 5) THEN
<             N2pop(j) = 3 * ( 2 * j + 1.0d0) * EXP(-c1 * N2E(j) / T) 
<          ELSE
<             N2pop(j) = 6 * ( 2 * j + 1.0d0) * EXP(-c1 * N2E(j) / T)
<          ENDIF
<          ZN2= ZN2 + N2pop(j)  
<       ENDDO
<       ! calculate static part of Anti-Stokes cross sections for N2
<        DO j = 0, N2Jmax - 2 
<              N2csec(j) = temp * N2pop(j + 2) * N2b(j) /  ZN2
<       ENDDO
< 
< ! calculate static part of Stokes cross sections for N2	
<       DO j = N2Jmax - 1, 2 * N2Jmax - 3 
<          N2csec(j) = temp * N2pop(j - N2Jmax + 1) * N2b(j) / ZN2
<       ENDDO
---
>   DO nu = fidx, lidx
>      tempz =  rhos(1:nz) *  tran(nu, 1:nz) 
>      I_tot(nu) = SUM(I(nu, 1:nz) * tempz(1:nz)) 
>      R_tot(nu) = SUM(R(nu, 1:nz) * tempz(1:nz))
>      ring(nu - nulo + 1) = I_tot(nu) / R_tot(nu) - 1.0d0
>   ENDDO
441,459c238,239
< ! calculate state sum for O2 
<       ZO2 = 0
<       DO k = 0, O2maxJ
<         O2popz(k) = ( 2 * O2JZ(k) + 1 ) * EXP(- c1 * O2EnZ(k) / T )
<         ZO2 = ZO2 + O2popz(k)
<       ENDDO
<        
< ! O2 cross sections
<        DO k = 0, 2 * O2max-7
<         O2pop(k) = (2 * O2J2(k) + 1 ) * EXP(-c1 * O2E(k) / T )
<         O2csec(k)= temp * O2pop(k) * O2b(k) / ZO2
<       ENDDO
< 
< ! set arrays to zero initially
<  
<        N2so(fidx:lidx) = 0.0; N2sumin(fidx:lidx, 1:nz) = 0.0
<        O2so(fidx:lidx) = 0.0; O2sumin(fidx:lidx, 1:nz) = 0.0
< 
< 
---
>   ring(1:maxpos) = 0.d0
>   ring(nline - maxpos + 1 : nline) = 0.d0
461,481c241,243
< ! calculate relative amounts of light shifted in/out of a given nu     
<      DO nu =  nulo+maxpos, nuhi-maxpos ! fidx, lidx 
<         inu = nu - nulo + 1
<         temp1 = gammaN2(inu) * gammaN2(inu)
<         temp2 = (REAL(nu))**4
<          
<           DO j = 0, 2 * N2Jmax-3
<             N2so(inu) = N2so(inu) + N2csec(j) * (REAL(nu - N2shift(j)))**4 * temp1
<             N2sumin(inu, 1:nz) = N2sumin(inu, 1:nz) + R(inu + N2shift(j), 1:nz) / R(inu, 1:nz) * N2csec(j) * &
<                                  gammaN2( inu + N2shift(j)) ** 2 * temp2
<           ENDDO
<  
< 	  temp1 = gammaO2(inu) * gammaO2(inu)
<           DO k = 0, 2 * O2max-7           
<               O2so(inu) = O2so(inu) + O2csec(k) * (REAL(nu - O2shift(k)))**4 * temp1
<               O2sumin(inu, 1:nz) = O2sumin(inu, 1:nz) + R(inu + O2shift(k), 1:nz) / R(inu, 1:nz) * O2csec(k) &
<                                   * gammaO2(inu + O2shift(k)) ** 2 * temp2
<           ENDDO
<      
<          diff(inu, 1:nz) = N2mix * (N2sumin(inu, 1:nz) - N2so(inu)) + O2mix * (O2sumin(inu, 1:nz) - O2so(inu))
<          I(inu, 1:nz) = R(inu, 1:nz) * ( 1.0 + phasefnc * diff(inu, 1:nz) / (Raylcsec(inu) * RaylP(inu)))
---
>   RETURN
>   
> END SUBROUTINE raman
483,492d244
<     ENDDO
<  
<   DO nu = nulo+maxpos, nuhi-maxpos
<      inu = nu - nulo + 1
<      tempz =  rhos(1:nz) *  tran(inu, 1:nz) 
<      I_tot(inu) = SUM(I(inu, 1:nz) * tempz(1:nz)) 
<      R_tot(inu) = SUM(R(inu, 1:nz) * tempz(1:nz))
<      ring(inu) = I_tot(inu) / R_tot(inu) - 1.0d0
<   ENDDO
<      
494,497d245
<   ring(1:maxpos) = 0.d0
<   ring(nline - maxpos + 1 : nline) = 0.d0
<  
< end subroutine raman2
============================
raman.f90_xliu
============================
read_aerosol_prof.f90
============================
read_ozprof_input.f90
39,41c39,43
<        radc_lambnd, hres_samprate, thealbidx, thewfcidx, do_simu_rmring,        &
<        update_o3, update_sao3, which_tpres,ncm, cmwins, cmind, cmfind 
<        
---
>        radc_lambnd, hres_samprate, thealbidx, thewfcidx, do_simu_rmring, &
>        rtm_treatment, update_o3, update_sao3, which_tpres, insert_sfc_layer, &
>        do_alb_longwav, alb_swav, ring_LUT, alb_ewav, use_prefitalb 
> 
> 
48c50
<        rad_identifier,refspec_fname, outdir, numwin, refdbdir, scnwrt,        &
---
>        rad_identifier, refspec_fname, outdir, numwin, refdbdir, scnwrt,        &
50d51
<         
52a54
> 
82c84
<   ! ==ad_identifier============================
---
>   ! ==============================
106c108
<    
---
> 
112c114
<   
---
> 
145c147
<      ozwrtwf   = .FALSE.; ozwrtsnr   = .FALSE.;  ozwrtres = .TRUE.; ozwrtvar = .FALSE.   
---
>      ozwrtwf   = .FALSE.; ozwrtsnr   = .FALSE.;  ozwrtres = .TRUE.;! ozwrtvar = .FALSE.
151c153
<   READ (fit_ctrl_unit, *) ring_on_line, ring_convol, fit_atanring
---
>   READ (fit_ctrl_unit, *) ring_on_line, ring_convol, fit_atanring, ring_LUT
167,168c169,170
<  
<   IF (which_clima > 14 .OR. which_clima <= 0) THEN
---
> 
>   IF (which_clima > 12 .OR. which_clima <= 0) THEN
173c175
<   IF (which_aperr > 14 .OR. which_aperr <= 0 .or. which_aperr  ==7 .or. which_aperr ==8) THEN
---
>   IF (which_aperr > 12 .OR. which_aperr <= 0 .OR. which_aperr  == 7 .OR. which_aperr ==8) THEN
177,178c179,180
< 
<   IF (which_toz > 2 .OR. which_toz < 0) THEN
---
>   
>   IF (which_toz > 4 .OR. which_toz < 0 .OR. which_toz == 3) THEN
184,186c186,188
<      IF ( which_clima == 5 .or. which_clima == 6 .or. which_aperr == 5 ) THEN 
<      WRITE(*, *) modulename, ' Total ozone is needed to use this climatology!!!'
<      pge_error_status = pge_errstat_error; RETURN
---
>      IF ( which_clima == 5 .OR. which_clima == 6 .OR. which_aperr == 5 ) THEN 
>         WRITE(*, *) modulename, ' Total ozone is needed to use this climatology!!!'
>         pge_error_status = pge_errstat_error; RETURN
188,191c190,193
<      
<      IF ( update_o3 == .TRUE. .or. update_sao3 == .TRUE. ) THEN
<      WRITE(*, *) modulename, ' Total ozone is needed to update o3 or sao3 !!!'
<      pge_error_status = pge_errstat_error; RETURN 
---
> 
>      IF ( update_o3 == .TRUE. .OR. update_sao3 == .TRUE. ) THEN
>         WRITE(*, *) modulename, ' Total ozone is needed to update o3 or sao3 !!!'
>         pge_error_status = pge_errstat_error; RETURN 
193,203c195,204
<   ELSE IF ( which_toz /= 0 ) THEN 
<   ! toz might be need when doing radiometric calibration and we need total ozone to normalize the profile
<   !   IF ( (which_clima /= 5 .and. which_clima /= 6) .and. (which_aperr /= 5) ) THEN 
<   !         which_toz = 0
<   !        WRITE(*, *) modulename, ' which_toz is set to be 0 because clima is not IUP or V* !!!'      
<   !        IF ( update_o3 == .TRUE. .or. update_sao3 == .TRUE. ) THEN
<   !             update_o3 = .FALSE. ; update_sao3 = .FALSE.
<   !        WRITE(*, *) modulename, ' updateo3 is set to .FASE. because clima is not IUP or V* !!!'      
<   !        ENDIF
<   !   ENDIF     
<   ENDIF 
---
>      !ELSE IF ( which_toz /= 0 ) THEN 
>      !   IF ( (which_clima /= 5 .AND. which_clima /= 6) .AND. (which_aperr /= 5) ) THEN 
>      !      which_toz = 0
>      !      WRITE(*, *) modulename, ' which_toz is set to be 0 because clima is not IUP or V* !!!'      
>      !      IF ( update_o3 == .TRUE. .OR. update_sao3 == .TRUE. ) THEN
>      !         update_o3 = .FALSE. ; update_sao3 = .FALSE.
>      !         WRITE(*, *) modulename, ' updateo3 is set to .FASE. because clima is not IUP or V* !!!'      
>      !      ENDIF
>      !   ENDIF
>   ENDIF
205d205
<       
208d207
<   READ (fit_ctrl_unit, *) which_alb
209a209
>   READ (fit_ctrl_unit, *) which_alb
216c216
<   IF (which_cld > 4) THEN
---
>   IF (which_cld > 5) THEN
219a220,226
>   IF (which_cld == 5 .OR. which_toz == 4) THEN
>      CALL read_cldalb_input(errstat)
>      IF (errstat /= pge_errstat_ok) THEN
>         WRITE(*, *) modulename, ' Error in reading cldalb fit input!!!' 
>         pge_error_status = pge_errstat_error; RETURN
>      ENDIF
>   ENDIF
222,224c229,231
<   IF (which_tpres > 2) then
<     WRITE(*,*) modulename, 'No such tpres option !!!'
<     pge_error_status = pge_errstat_error; return
---
>   IF (which_tpres > 2) THEN
>      WRITE(*,*) modulename, 'No such tpres option !!!'
>      pge_error_status = pge_errstat_error; RETURN
226c233
<  
---
> 
228d234
<   IF( aerosol ) print *,'aerosol is considered !!!' 
261c267
<      
---
> 
288c294
<   
---
> 
320c326
<   ENDIF 
---
>   ENDIF
331c337,338
<   
---
>   READ (fit_ctrl_unit, *) insert_sfc_layer
> 
342c349
<   
---
> 
372,410c379,417
<     
< !  ozpfpars: DO i = 1, nlay
< !     READ (fit_ctrl_unit, *, IOSTAT=errstat) vartmp, lotmp, uptmp, vart
< !     IF ( errstat /= pge_errstat_ok ) THEN
< !        errstat = OMI_SMF_setmsg (omsao_e_read_fitctrl_file, &
< !             TRIM(ADJUSTL(fit_ctrl_file)), modulename, 0)
< !        WRITE(*, *) modulename, ' : Error in reading initial ozone variables!!!'
< !        pge_error_status = pge_errstat_error; RETURN
< !     END IF
< !     ! ---------------------------------------------------------
< !     ! Check for consitency of bounds and adjust where necessary
< !     ! ---------------------------------------------------------
< !     IF ( lotmp > vartmp .OR. uptmp < vartmp ) THEN
< !        lotmp = vartmp ; uptmp = vartmp
< !     END IF
< !     IF ( lotmp == uptmp .AND. lotmp /= vartmp ) THEN
< !        uptmp = vartmp ; lotmp = vartmp
< !     END IF
< !     
< !     fitvar_rad_init(idx + i) = vartmp
< !     WRITE(fitvar_rad_str(idx+i), '(A2, I2.2)') 'oz', i
< !     
< !     lo_radbnd(idx + i) = lotmp
< !     up_radbnd(idx + i) = uptmp  
< !     
< !     ! determine whether to vary temperature
< !     IF (vart .AND. lotmp < uptmp) THEN
< !        fitvar_rad_init(idx + i + maxlay) = 200.0  ! rechange after preparing atmos.
< !        lo_radbnd(idx + i + maxlay) = 0.
< !        up_radbnd(idx + i + maxlay) = 400.
< !        WRITE(fitvar_rad_str(idx+i+maxlay), '(A2, I2)') 'tmp', i
< !
< !     ELSE
< !        fitvar_rad_init(idx + i+ maxlay) = 0. 
< !        lo_radbnd(idx + i + maxlay) = 0.
< !        up_radbnd(idx + i + maxlay) = 0.
< !     END IF
< !
< !  END DO ozpfpars
---
> 
>   !  ozpfpars: DO i = 1, nlay
>   !     READ (fit_ctrl_unit, *, IOSTAT=errstat) vartmp, lotmp, uptmp, vart
>   !     IF ( errstat /= pge_errstat_ok ) THEN
>   !        errstat = OMI_SMF_setmsg (omsao_e_read_fitctrl_file, &
>   !             TRIM(ADJUSTL(fit_ctrl_file)), modulename, 0)
>   !        WRITE(*, *) modulename, ' : Error in reading initial ozone variables!!!'
>   !        pge_error_status = pge_errstat_error; RETURN
>   !     END IF
>   !     ! ---------------------------------------------------------
>   !     ! Check for consitency of bounds and adjust where necessary
>   !     ! ---------------------------------------------------------
>   !     IF ( lotmp > vartmp .OR. uptmp < vartmp ) THEN
>   !        lotmp = vartmp ; uptmp = vartmp
>   !     END IF
>   !     IF ( lotmp == uptmp .AND. lotmp /= vartmp ) THEN
>   !        uptmp = vartmp ; lotmp = vartmp
>   !     END IF
>   !     
>   !     fitvar_rad_init(idx + i) = vartmp
>   !     WRITE(fitvar_rad_str(idx+i), '(A2, I2.2)') 'oz', i
>   !     
>   !     lo_radbnd(idx + i) = lotmp
>   !     up_radbnd(idx + i) = uptmp  
>   !     
>   !     ! determine whether to vary temperature
>   !     IF (vart .AND. lotmp < uptmp) THEN
>   !        fitvar_rad_init(idx + i + maxlay) = 200.0  ! rechange after preparing atmos.
>   !        lo_radbnd(idx + i + maxlay) = 0.
>   !        up_radbnd(idx + i + maxlay) = 400.
>   !        WRITE(fitvar_rad_str(idx+i+maxlay), '(A2, I2)') 'tmp', i
>   !
>   !     ELSE
>   !        fitvar_rad_init(idx + i+ maxlay) = 0. 
>   !        lo_radbnd(idx + i + maxlay) = 0.
>   !        up_radbnd(idx + i + maxlay) = 0.
>   !     END IF
>   !
>   !  END DO ozpfpars
430c437
<   
---
> 
433c440
<   
---
> 
448c455
<   
---
> 
461a469,486
>   READ (fit_ctrl_unit, *) do_alb_longwav, alb_swav, alb_ewav
>   READ (fit_ctrl_unit, *) use_prefitalb
>   ! check the upper and lower range for albedo and cloud 
>   ! Use waves < alb_swav and waves > alb_ewav to retrieve albedo
>   ! We do some checking here
>   ! Make sure that:
>   ! (1) the start/end wavelength is within the fitting window.
>   ! (2) if alb_swav >= alb_ewav then use waves > alb_ewav only
>   ! (3) we have enough points for fitting, which depends on parameters.
>   !     for maximum 6 pars, we need a window of at least 5 nm (fwhm=0.45) width
>   IF (do_alb_longwav .AND. numwin == 2) THEN
>      IF (alb_ewav >= winlim(numwin, 2) .OR.alb_ewav <= winlim(numwin, 1) ) THEN
>           WRITE(*, *) modulename, ' : albswav is not within the fitting window. ', alb_swav
>      ENDIF
>      IF (alb_swav >= alb_ewav) alb_swav = 0.0D0
>   ENDIF
> 
> 
470,471c495,496
<   
<   idx = shift_offset + max_rs_idx + maxlay * 2 
---
> 
>   idx = shift_offset + max_rs_idx + maxlay * 2
478c503
< 		errstat = OMI_SMF_setmsg (omsao_e_read_fitctrl_file, &
---
>         errstat = OMI_SMF_setmsg (omsao_e_read_fitctrl_file, &
480,481c505,506
< 		WRITE(*, *) modulename, ' : Error in reading initial albedo variables!!!'
< 		pge_error_status = pge_errstat_error; RETURN
---
>         WRITE(*, *) modulename, ' : Error in reading initial albedo variables!!!'
>         pge_error_status = pge_errstat_error; RETURN
488c513
< 		lotmp = vartmp ; uptmp = vartmp
---
>         lotmp = vartmp ; uptmp = vartmp
491c516
< 		uptmp = vartmp ; lotmp = vartmp
---
>         uptmp = vartmp ; lotmp = vartmp
493c518
<     
---
> 
533,535c558,560
<   !ELSE IF (nwfc < 1) THEN
<   !   WRITE(*, *) modulename, ' : Need to specify at least 1 cloud fraction term!!!'
<   !   pge_error_status = pge_errstat_error; RETURN     
---
>      !ELSE IF (nwfc < 1) THEN
>      !   WRITE(*, *) modulename, ' : Need to specify at least 1 cloud fraction term!!!'
>      !   pge_error_status = pge_errstat_error; RETURN     
540c565
<   idx = idx + maxalb 
---
>   idx = idx + maxalb
547c572
< 		errstat = OMI_SMF_setmsg (omsao_e_read_fitctrl_file, &
---
>         errstat = OMI_SMF_setmsg (omsao_e_read_fitctrl_file, &
549,550c574,575
< 		WRITE(*, *) modulename, ' : Error in reading initial cloud fraction variables!!!'
< 		pge_error_status = pge_errstat_error; RETURN
---
>         WRITE(*, *) modulename, ' : Error in reading initial cloud fraction variables!!!'
>         pge_error_status = pge_errstat_error; RETURN
557c582
< 		lotmp = vartmp ; uptmp = vartmp
---
>         lotmp = vartmp ; uptmp = vartmp
560c585
< 		uptmp = vartmp ; lotmp = vartmp
---
>         uptmp = vartmp ; lotmp = vartmp
562c587
<     
---
> 
603,604c628
<   idx = wfcidx + maxwfc - 1
<    
---
>   idx = wfcidx + maxwfc - 1 
608c632
< 		errstat = OMI_SMF_setmsg (omsao_e_read_fitctrl_file, &
---
>         errstat = OMI_SMF_setmsg (omsao_e_read_fitctrl_file, &
610,611c634,635
< 		WRITE(*, *) modulename, ' : Error in reading initial albedo variables!!!'
< 		pge_error_status = pge_errstat_error; RETURN
---
>         WRITE(*, *) modulename, ' : Error in reading initial albedo variables!!!'
>         pge_error_status = pge_errstat_error; RETURN
618c642
< 		lotmp = vartmp ; uptmp = vartmp
---
>         lotmp = vartmp ; uptmp = vartmp
621c645
< 		uptmp = vartmp ; lotmp = vartmp
---
>         uptmp = vartmp ; lotmp = vartmp
660c684
<     
---
> 
669c693
<   
---
> 
681c705
<         rmask_fitvar_rad(i) = n_fitvar_rad 
---
>         rmask_fitvar_rad(i) = n_fitvar_rad  
712c736
<   END IF    
---
>   END IF
718c742
<    
---
> 
749c773
<               vartmp = 0.4
---
>               vartmp = 0.5
751c775
<               vartmp = 303.
---
>               vartmp = 300.
753c777
<               vartmp = 3.0
---
>               vartmp = 5.0
778c802
<         
---
> 
784c808
<                       
---
> 
793d816
< 
848,849d870
<      ELSE IF (i == 8) THEN  !JBAk
<         ncm = nord;cmwins = tmpwins; cmind = tmpind; cmfind = tmpfind
851,852c872
<         
<        ! print * , i, nord
---
> 
858c878,881
<   ! WRITE(*, '(7I5)') nos, nsl, nsh, nrn, ndc, nis, nir
---
>   !DO i = 1, n_fitvar_rad
>   !   print *, i, fitvar_rad_str(mask_fitvar_rad(i))
>   !ENDDO
>   !WRITE(*, '(7I5)') nos, nsl, nsh, nrn, ndc, nis, nir
860a884,885
>   rtm_treatment(1:max_rs_idx) = .FALSE.
>   rtm_treatment(gasidxs) = .TRUE.
869d893
<        
872c896
<      
---
> 
876,877c900,901
<      !WRITE(*, '(I5, A10, A20,e10.4)') i, fitvar_rad_str(mask_fitvar_rad(i)), & ! JBAK printing
<      !     fitvar_rad_unit(mask_fitvar_rad(i)), fitvar_rad_init(mask_fitvar_rad(i))
---
>      !WRITE(*, '(I5, A10, A20)') i, fitvar_rad_str(mask_fitvar_rad(i)), &
>      !     fitvar_rad_unit(mask_fitvar_rad(i))
896a921,922
> 
> 
============================
set_cldalb.f90
12c12
<      
---
> 
20c20,21
<        wfcmax, wfcmin, nwfc, nfwfc, wfcfpix, wfclpix, wfcfidx, wfcidx, the_snowice
---
>        wfcmax, wfcmin, nwfc, nfwfc, wfcfpix, wfclpix, wfcfidx, wfcidx, the_snowice,  &
>        do_alb_longwav
24c25
<   
---
> 
34c35
<   
---
> 
36c37
<   
---
> 
42c43
<   REAL (KIND=dp)               :: actp, cfrac_old, albedo, albedo_old
---
>   REAL (KIND=dp)               :: actp, cfrac_old, albedo
64,65c65
<  
<   
---
> 
67d66
<   albedo_old = albedo
69c68,70
<      noalb = .TRUE.  
---
>      !IF (cfrac > 0.0) THEN
>      noalb = .TRUE.
> 
71a73
> 
73c75
<   ELSE ! albedo is calculated
---
>   ELSE
77,80c79,80
<      !IF (pge_error_status == pge_errstat_error)  RETURN XLIU
<      IF (pge_error_status == pge_errstat_error)  THEN !JBAK
<          albedo = albedo_old
<      ENDIF
---
>      IF (pge_error_status == pge_errstat_error)  RETURN
> 
85a86
> 
90c91
<   ! CALL ADJ_ALBCFRAC(albedo, cfrac, pge_error_status)
---
>   !CALL ADJ_ALBCFRAC(albedo, cfrac, pge_error_status)
98,110c99,111
<    ! For simulation, if cfrac == 1.0, then need to adjust lambcld_refl.  However, this already partly corrects 
<    ! for calibration offset by deriving a lambcld_refl that matches the measured radiance at cloud wavelength
<    ! IF (.NOT. do_simu .OR. (cfrac == 1.0D0 .AND. radcalwrt) )
< 
<    IF (the_snowice == 101) THEN ! permanent ice
<       albedo = 0.90
<    ELSE IF (the_snowice == 103) THEN ! dray ice
<       albedo = 0.80
<    ELSE IF (the_snowice > 1 .AND. the_snowice <= 100) THEN ! see ice
<       albedo = MAX(albedo, 0.8 * the_snowice / 100.0)
<    ENDIF
<    cfrac_old = cfrac  ! save cloud fraction from other products
<    CALL ADJ_ALBCFRAC(albedo, cfrac, ctau, pge_error_status) 
---
>   ! For simulation, if cfrac == 1.0, then need to adjust lambcld_refl.  However, this already partly corrects 
>   ! for calibration offset by deriving a lambcld_refl that matches the measured radiance at cloud wavelength
>   ! IF (.NOT. do_simu .OR. (cfrac == 1.0D0 .AND. radcalwrt) ) 
>   IF (the_snowice == 101) THEN
>      albedo = 0.90
>   ELSE IF (the_snowice == 103) THEN
>      albedo = 0.80
>   ELSE IF (the_snowice > 1 .AND. the_snowice <= 100) THEN
>      albedo = MAX(albedo, 0.8 * the_snowice / 100.0)
>   ENDIF
>   cfrac_old = cfrac  ! save cloud fraction from other products
>   CALL ADJ_ALBCFRAC(albedo, cfrac, ctau, pge_error_status) 
>   salbedo = albedo   ! Surface albedo
112,115c113,115
<    salbedo = albedo   ! Surface albedo
<    ! xliu: 08/16/2008, when surface albedo increases, it is more difficult to differentiate clouds/surfaces
<    ! Assume a cloud fraction of 0 and increases a priori error for surface albedo and cloud fraction
<    IF (albedo > 0.6 .AND. cfrac >= 0.6 .AND. .NOT. do_simu) cfrac = 0.5
---
>   ! xliu: 08/16/2008, when surface albedo increases, it is more difficult to differentiate clouds/surfaces
>   ! Assume a cloud fraction of 0 and increases a priori error for surface albedo and cloud fraction
>   IF (albedo > 0.6 .AND. cfrac >= 0.6 .AND. .NOT. do_simu) cfrac = 0.5
117c117
<    IF (ecfrfind == 0 .AND. nwfc == 0) THEN ! Final cloud fraction is computed here  
---
>   IF (ecfrfind == 0 .AND. nwfc == 0) THEN ! Final cloud fraction is computed here  
125,126c125,131
<      IF ( cfrac == 0.0) cfrac = 0.01
<      IF ( cfrac == 1.0) cfrac = 0.99
---
>      IF (nfwfc <= 0) THEN
>         IF ( cfrac == 0.0) cfrac = 0.01
>         IF ( cfrac == 1.0) cfrac = 0.99
>      ELSE
>         IF (cfrac <= 1.0D-3) cfrac = 0.0D0
>         IF (cfrac >= 0.999) cfrac = 1.0D0
>      ENDIF
129c134
<      
---
> 
139c144
<  
---
> 
144a150
> 
151d156
<       
154c159
<         
---
> 
159c164
<         
---
> 
163c168
<      
---
> 
166c171
<   
---
> 
171c176
<  
---
> 
178,179c183,184
<           >= albmin(i) .AND. fitwavs(1:npoints) < albmax(i)))) 
<      IF (fitvar_rad_str(j)(4:4) == '0') then 
---
>           >= albmin(i) .AND. fitwavs(1:npoints) < albmax(i))))  
>      IF (fitvar_rad_str(j)(4:4) == '0') &
181d185
<      endif
182a187
> 
185d189
<        print *, fitwavs(albfpix(2)), fitwavs(alblpix(2)) 
190a195
> 
213c218
<      
---
> 
220a226
> 
222c228
<         
---
> 
227c233
<         
---
> 
231c237
<      
---
> 
234c240
<   
---
> 
239c245
<   
---
> 
245c251
<               >= wfcmin(i) .AND. fitwavs(1:npoints) < wfcmax(i)))) 
---
>              >= wfcmin(i) .AND. fitwavs(1:npoints) < wfcmax(i)))) 
251c257
<      
---
> 
261c267
<  
---
> 
263c269
<   
---
> 
322a329,386
> SUBROUTINE get_prefitalb(errstat)
> 
>   USE OMSAO_precision_module
>   USE ozprof_data_module,      ONLY: use_prefitalb, pf2ba0, pf2ba1, pf2fc0, pf2fc1
>   USE OMSAO_variables_module, ONLY : currline, currpix
>   USE OMSAO_omidata_module,   ONLY : offset_line, nxbin, nybin
>   USE OMSAO_errstat_module
>   
>   IMPLICIT NONE
> 
>   ! OUTPUT
>   INTEGER,   INTENT(OUT)  :: errstat
> 
> 
>   ! Local 
>   INTEGER, PARAMETER   :: funit = 89
>   INTEGER              :: i, npix, ll, xx, idx
>   real(KIND=dp), dimension(3)        :: temp3 
>   CHARACTER(LEN=256)   :: albfname, tmpchar, tmpchar1
> 
> 
>   errstat = 0
> 
>   albfname = '2alb.dat'
> 
>   OPEN ( UNIT=funit, FILE=TRIM(ADJUSTL(albfname)),FORM='FORMATTED',  &
>        STATUS='OLD', IOSTAT=errstat)
>   if (errstat /= pge_errstat_ok) then
>       WRITE(*, *) 'Error in opening prefit alb file'
>       errstat = pge_errstat_error; return
>   endif
> 
>   READ(funit, *) npix
>   if (npix <= 0) then
>      WRITE(*, *) 'Error: No albedo prefitted'
>      errstat = pge_errstat_error; return 
>   endif
>   READ(funit, *) ll, xx
>   READ(funit, *) idx, tmpchar1, temp3
>   pf2ba0 = temp3(1)
>   READ(funit, *) idx, tmpchar1, temp3
>   pf2ba1 = temp3(1)
>   READ(funit, *) idx, tmpchar1, temp3
>   pf2fc0 = temp3(1)
>   READ(funit, *) idx, tmpchar1, temp3
>   pf2fc1 = temp3(1)
>   CLOSE(funit)
> 
>   IF ( ll .NE. currline * nybin + offset_line + 1 .OR. &
>        xx .NE. (currpix -1) * nxbin + 1 ) THEN
>      WRITE(*, *) 'Error: current line and pix does not mach with 2alb.dat'
>      errstat = pge_errstat_error
>   ENDIF
> 
>   RETURN
> 
> END SUBROUTINE get_prefitalb
> 
============================
specfit_ozprof.f90
19c19
<   
---
> 
29c29
<        n_rad_wvl,mask_fitvar_rad,fitspec_rad, fitres_rad, use_meas_sig,        &
---
>        n_rad_wvl, mask_fitvar_rad,fitspec_rad, fitres_rad, use_meas_sig,        &
34,46c34,45
<        the_sza_atm, currline, refwvl, n_refwvl, reduce_resolution,curr_sol_spec,n_irrad_wvl,&
<        database, database_shiwf  
<   USE ozprof_data_module,        ONLY: ozprof_start_index, ozprof_end_index,    &
<        ozfit_start_index, ozfit_end_index, use_oe, covar, ozprof_std, ozprof_ap,& 
<        which_clima, ncovar, ozprof_apstd, ozprof_init, ozprof, start_layer,     &
<        end_layer, eff_alb, eff_alb_init, nlay, nlay_fit, nflay, ptr_order,      &
<        aerosol, cloud, ntp, nsfc, atmosprof, ndiv, ps0, pst, useasy, nup2p, nfalb, &
<        nalb, tf_fidx, tf_lidx,t_fidx,t_lidx, albidx, albfidx, nt_fit, pos_alb,  &
<        the_cfrac, the_cod, the_ctp, the_cld_flg, do_lambcld, which_cld,         &
<        ozprof_nstd, use_oe, maxawin, use_logstate, ozinfo, avg_kernel, contri,  &
<        num_iter, smooth_ozbc, colprof, actawin, aerwavs, do_tracewf, mgasprof,  &
<        fgasidxs, gasidxs, tracegas, ngas, nflay, do_subfit, osind,     &
<        rnind, dcind, isind, irind, slind, shind, nos, nsh, nsl, nrn, ndc, nir,  &
---
>        the_sza_atm, currline
>   USE ozprof_data_module,        ONLY: ozprof_start_index, ozprof_end_index,         &
>        ozfit_start_index, ozfit_end_index, use_oe, covar, ozprof_std, ozprof_ap,     & 
>        which_clima, ncovar, ozprof_apstd, ozprof_init, ozprof, start_layer,          &
>        end_layer, eff_alb, eff_alb_init, nlay, nlay_fit, nflay, ptr_order,           &
>        aerosol, cloud, ntp, nsfc, atmosprof, ndiv, ps0, pst, useasy, nup2p, nfalb,   &
>        nalb, tf_fidx, tf_lidx,t_fidx,t_lidx, albidx, albfidx, nt_fit, pos_alb,       &
>        the_cfrac, the_cod, the_ctp, the_cld_flg, do_lambcld, which_cld,              &
>        ozprof_nstd, use_oe, maxawin, use_logstate, ozinfo, avg_kernel, contri,       &
>        num_iter, smooth_ozbc, colprof, actawin, aerwavs, do_tracewf, mgasprof,       &
>        fgasidxs, gasidxs, tracegas, ngas, nflay, do_subfit, osind,                   &
>        rnind, dcind, isind, irind, slind, shind, nos, nsh, nsl, nrn, ndc, nir,       &
51,55c50,54
<        nwfc, nfwfc, eff_wfc, eff_wfc_init, so2zind, so2zfind, fit_atanring, &
<        use_large_so2_aperr, ozwrtcontri, ozwrtwf, weight_function, contri, &
<        trace_profwf, trace_contri, trace_prof, trace_avgk , sacldscl0,caloz_fname, cmind,&
<        salbedo
<   
---
>        nwfc, nfwfc, eff_wfc, eff_wfc_init, so2zind, so2zfind, fit_atanring,          &
>        use_large_so2_aperr, ozwrtcontri, ozwrtwf, weight_function, contri,           &
>        trace_profwf, trace_contri, trace_prof, trace_avgk, sacldscl0, merr_covar,    &
>        do_sy_diagonal, merr_corrlen, msyserr
> 
72,73c71,72
<   INTEGER  :: i, j, nump, errstat, k1, npoints, k, u1idx, u2idx, nsub, nord, is, fidx, lidx
<   REAL (KIND=dp) :: asum, ssum, chisq, tmpsa, aodscl, waerscl, ncepreso_z0, omi_z0
---
>   INTEGER  :: i, j, m, n, nump, errstat, k1, npoints, k, u1idx, u2idx, nsub, nord, is, fidx, lidx
>   REAL (KIND=dp) :: asum, ssum, chisq, tmpsa, aodscl, waerscl, salbedo, ncepreso_z0, omi_z0
86d84
<   REAL (kind=dp), DIMENSION(3)                            :: dfitcol_xa
90c88
<   
---
> 
93c91,101
<   INTEGER :: idx_jbak1, idx_jbak2
---
> 
>   !
>   REAL (KIND=dp), ALLOCATABLE :: tmpcovar(:, :)
> 
>   ! systematic noise
>   INTEGER, PARAMETER                :: nreg = 4
>   REAL (KIND=dp), DIMENSION(nreg) :: reg_noise =  &
>        (/0.004, 0.004, 0.002, 0.002/)
>   REAL (KIND=dp), DIMENSION(0:nreg) :: reg_waves = &
>        (/260.0, 300.0, 310.0, 350., 370./)
> 
98d105
<   
120a128
> 
126a135,201
> 
>   ! constract Sy, Sy = S_rnd + S_sys, S_rnd is diagonal, represented by measurements noise,
>   ! S_sys is square, symetric, represented by sig^2*exp(-(lambda1-lambda2)/h)  
>   do_sy_diagonal = .true.
>   msyserr = 0.002D0; merr_corrlen = 100.0D0
>   IF (.NOT.do_sy_diagonal) THEN
>      fidx = 1; i = fidx
>      DO j = 1, nreg
>         DO WHILE (i <= npoints )
>            IF (fitwavs(i) < reg_waves(j)) THEN
>               i = i + 1
>            ELSE
>               EXIT
>            ENDIF
>         ENDDO
>         lidx = i - 1
>         msyserr(fidx:lidx) = reg_noise(j)
>         fidx = lidx + 1
>      ENDDO
>      !msyserr = 0.01D0
> 
>      ALLOCATE(tmpcovar(npoints, npoints))
>      tmpcovar = 0.0D0
>      DO i = 1, npoints
>         tmpcovar(i, i) = fitweights(i)**2 + msyserr(i)**2
>      ENDDO
>      DO i = 1, npoints
>         DO j = 1, i-1
>            tmpcovar(i, j) = msyserr(i)*msyserr(j) * EXP(-(ABS(fitwavs(i)-fitwavs(j))/merr_corrlen))
>            !tmpcovar(i, j) =  sqrt(tmpcovar(i, i)* tmpcovar(j, j)) * &
>            !                 EXP(-ABS((fitwavs(i)-fitwavs(j))/merr_corrlen))
>            tmpcovar(j, i) = tmpcovar(i, j)
>         ENDDO
>      ENDDO
>      !do i = 1, npoints
>      !    write(78, '(500D16.7)') tmpcovar(i, 1:npoints)!;; pause
>      !enddo
> !!$     fidx = 1
> !!$     DO i = 1, numwin
> !!$        lidx = fidx + nradpix(i) - 1
> !!$        DO j = 1, nradpix(i)
> !!$           DO k = 1, j-1            
> !!$              m = fidx+j-1; n = fidx+k-1
> !!$              tmpcovar(m, n) = msyserr(m)*msyserr(n) * EXP(-(ABS(fitwavs(m)-fitwavs(n))/merr_corrlen))
> !!$              tmpcovar(n, m) = tmpcovar(m, n)
> !!$           ENDDO
> !!$        ENDDO
> !!$        fidx = lidx + 1
> !!$     ENDDO
>      !do i = 1, npoints
>      !    write(77, '(500D16.7)') tmpcovar(i, 1:npoints)!;; pause
>      !enddo
>      ! UV1 and UV2 does not correlate
>      merr_covar = 0.0D0
>      fidx = 1
>      DO i = 1, numwin
>         lidx = fidx + nradpix(i) - 1
>         merr_covar(fidx:lidx, fidx:lidx) = tmpcovar(fidx:lidx, fidx:lidx)
>         fidx = lidx + 1
>      ENDDO
> !!$     do i = 1, npoints
> !!$         write(79, '(500D16.7)') merr_covar(i, 1:npoints)!;; pause
> !!$     enddo 
>      merr_covar(1:npoints,1:npoints)=tmpcovar(1:npoints,1:npoints)
>      DEALLOCATE(tmpcovar) 
>   ENDIF
> 
142c217
<      
---
> 
152c227
<   
---
> 
162,164d236
<    
<   ! IF (which_atm eq 1 ) THEN   
<    
166,168d237
<   ! ELSE IF (which_atm eq 2 ) THEN 
<   !  CALL get_SPRES_UM ()
<   !  ENDIF
174,176c243,244
<  
<   ! Adjust surface pressure ! dpres (p_omi-p_ncep) = dz(z_omi - z_ncep)
<        
---
> 
>   ! Adjust surface pressure
178a247
> 
184c253
<       
---
> 
187,188c256,257
<   !ELSE IF (which_toz == 2) THEN
<   !   CALL GET_ZMTOZ(the_year, the_month, the_day, the_lat, toz)
---
>      !ELSE IF (which_toz == 2) THEN
>      !   CALL GET_ZMTOZ(the_year, the_month, the_day, the_lat, toz)
193,194c262,264
<   IF (scnwrt) WRITE(*, '(3(A,F8.2),A,f8.2)') ' spres =', ps0, ' tpres =', pst, ' toz = ', toz,' ctp = ',the_ctp
<  
---
>   IF (scnwrt) WRITE(*, '(3(A,F8.2))') ' spres =', ps0, ' tpres =', pst, ' toz = ', toz
> 
> 
216d285
<  
242c311
<   
---
> 
246c315
<    
---
> 
258d326
< 
263c331
<   
---
> 
274c342
<   
---
> 
286d353
<         
297c364
<         
---
> 
302d368
<           
304d369
<   
306c371
<  
---
> 
313d377
< 
317d380
<      fitvar_rad_init (cmind(i, 1:maxoth)) = 1.0D0  !JBAk
319d381
< 
321c383,386
<      IF (fitvar_rad_str(i)(4:4) /= '0') fitvar_rad_init(i) = 0.D0
---
>      IF (fitvar_rad_str(i)(4:4) /= '0') fitvar_rad_init(i) = 0.0D0
>   ENDDO
>   DO i = wfcidx, wfcidx + nwfc - 1
>      IF (fitvar_rad_str(i)(4:4) /= '0') fitvar_rad_init(i) = 0.0D0
322a388
> 
324c390
<  
---
> 
330c396
<              
---
> 
342c408
<     
---
> 
348c414
<    
---
> 
350a417,418
>      !CALL GET_APRIORI_COVAR0(the_month, the_day, the_lat, the_lon, atmosprof(1,0:nlay), &
>      !     atmosprof(2,0:nlay), atmosprof(3, 0:nlay), nlay, ntp, ozprof(1:nlay), sao3)
355c423
<      ENDIF     
---
>      ENDIF
360c428
<      sacldscl0 = sacldscl ! used in update_o3_sao3
---
>   sacldscl0 = sacldscl ! used in update_o3_sao3
372c440
<   
---
> 
391c459
<      ENDDO 
---
>      ENDDO
394c462
<      ENDDO 
---
>      ENDDO
406a475
> 
413c482
<          
---
> 
421d489
<                
423,424c491,492
<               IF (fit_atanring) THEN  !NO
<                  sa(i, i) = 0.5
---
>               IF (fit_atanring) THEN 
>                  sa(i, i) = 1.0
434d501
<          
437c504
<                  sa(i, i) = 4.
---
>                  sa(i, i) = 9.
441d507
<            
443c509
<               sa(i, i) = 5.0E-5    
---
>               sa(i, i) = 5.0E-5  
449c515
<               sa(i, i) = 1.0E-8 
---
>               sa(i, i) = 100.0 !1.0E-8
451c517
<               sa(i, i) = 1.0E-10
---
>               sa(i, i) = 2.0!1.0E-10
453c519
<               sa(i, i) = 0.1  
---
>               sa(i, i) = 0.1
455c521
<               sa(i, i) = 0.02 
---
>               sa(i, i) = 0.02
457,459c523
<               sa(i, i) = 1.0 
<            ELSE IF (j >= cmind(1,1) .AND. J <= cmind (numwin, maxoth)) THEN  !JBAK
<               sa(i,i)  = 1.0
---
>               sa(i, i) = 1.0
461c525
<               sa(i, i) = (fitvar_rad(j))**2.0 * 25.0              
---
>               sa(i, i) = (fitvar_rad(j))**2.0 * 25.0 
477,479c541
<                  IF (k > 0) then 
<               sa(k, k) = 5.0E-4 * (10.0 ** (-(i - 1) * 2.0)) 
<                  endif
---
>                  IF (k > 0) sa(k, k) = 5.0E-4 * (10.0 ** (-(i - 1) * 2.0)) 
483c545
<         
---
> 
493c555
<         ENDIF        
---
>         ENDIF
511d572
<      
521a583
>            IF (the_cfrac > 1.0D-3 .AND. the_cfrac < 0.999 .AND. nfwfc > 0) sa(i, i) = 0.0
528a591
>            IF (the_cfrac <= 1.0D-3 .OR. the_cfrac >= 0.999) sa(i, i) = 0.0
531c594
<      
---
> 
534c597
<    
---
> 
538,540c601,603
<            sa(j, j) = (fitvar_rad_apriori(mask_fitvar_rad(j)))**2.0
<            IF (gasidxs(i) == hcho_idx .OR. gasidxs(i) == no2_t1_idx ) sa(j, j) = sa(j, j) * 0.25  !50% error
<            IF (gasidxs(i) == o2o2_idx) sa(j, j) = sa(j, j) * 0.25       !50% error
---
>            sa(j, j) = (fitvar_rad_apriori(mask_fitvar_rad(j)))**2.0 
>            !IF (gasidxs(i) == hcho_idx .OR. gasidxs(i) == no2_t1_idx ) sa(j, j) = sa(j, j) * 0.25  !50% error
>            IF (gasidxs(i) == o2o2_idx) sa(j, j) = sa(j, j) * 0.04       !50% error
564c627
<      ENDIF    
---
>      ENDIF
573c636
<         
---
> 
575c638
<     
---
> 
578c641
<     
---
> 
586d648
<  
589,606d650
<   IF  ( reduce_resolution) then ! Jbak's modification to avoide errors in interpolating solar spectrum with the fitwavs
<       do i = 1, n_refwvl-1  
<     if ( refwvl(i) > refwvl(i+1)) then
<     
<      print *, refwvl(i), 'decrease', refwvl(i+1)
<  refwvl(i) = refwvl(i+1) - (refwvl(i+2)-refwvl(i+1)) 
<      endif
<    enddo 
<   ENDIF 
< 
< !  do k = 1, nf 
< !   print *, k, fitvar(k), fitvarap(k), fitvar_rad_str(mask_fitvar_rad(k))
< !  enddo 
<         
< !     write(*,'(a10,100f10.5)') 'fitwavs',fitwavs(1:5), fitwavs(npoints-5:npoints)
< !     write(*,'(a10,100f10.5)') 'refwvl', refwvl(1:5), refwvl(n_refwvl-5:n_refwvl) 
< !     write(*,'(a10,100f10.5)') 'curr_sol_spec',curr_sol_spec(1,1:5)
< 
612d655
< 
616d658
< 
619c661
<   
---
> 
627c669
<     
---
> 
640c682
<   
---
> 
645c687
<   
---
> 
652c694
<   
---
> 
653a696
>   
659c702
<   
---
> 
668c711
<   fitcol = 0.0  ;  dfitcol = 0.0 ; dfitcol_xa = 0.0
---
>   fitcol = 0.0  ;  dfitcol = 0.0
685c728
<             
---
> 
689d731
<           
691c733
< !           IF (is ==1) dfitcol_xa(1) =dfitcol_xa(1) + sao3(i,i)
---
> 
693d734
<                  
695,697c736
<                     covar_sav(k1+i, k1+j) / SQRT(covar_sav(k1+i, k1+i) * covar_sav(k1+j, k1+j))          
< !              if (is ==1) dfitcol_xa(1) = dfitcol_xa(1) + 2.0 * sqrt(sao3(i,i)) * sqrt(sao3(j,j)) * &
< !                    sao3(k1+i, k1+j) / SQRT(sao3(k1+i, k1+i) * sao3(k1+j, k1+j))          
---
>                    covar_sav(k1+i, k1+j) / SQRT(covar_sav(k1+i, k1+i) * covar_sav(k1+j, k1+j))
699d737
<             
701a740
> 
707,708d745
<               
< !           IF (is ==1) dfitcol_xa(2) =dfitcol_xa(2) + sao3(i,i)
712,714d748
<               
< !              if (is ==1) dfitcol_xa(2) = dfitcol_xa(2) + 2.0 * sqrt(sao3(i,i)) * sqrt(sao3(j,j)) * &
< !                    sao3(k1+i, k1+j) / SQRT(sao3(k1+i, k1+i) * sao3(k1+j, k1+j))          
723,724d756
< 
<   !         IF (is ==1) dfitcol_xa(3) =dfitcol_xa(3) + sao3(i,i)
729,730d760
<  !             if (is ==1) dfitcol_xa(3) = dfitcol_xa(3) + 2.0 * sqrt(sao3(i,i)) * sqrt(sao3(j,j)) * &
<  !                   sao3(k1+i, k1+j) / SQRT(sao3(k1+i, k1+i) * sao3(k1+j, k1+j))          
738d767
< !            print * , sqrt(dfitcol_xa(:))
755c784
<   
---
> 
759c788
<   
---
> 
774c803
<      
---
> 
785,798c814,827
<  ! trace gases
<  DO k = 1, ngas
<     i = fgasidxs(k)
<     IF (i > 0) THEN
<        j = mask_fitvar_rad(i)
<        tracegas(k, 1) = fitvar_rad_init(j)
<        tracegas(k, 2) = fitvar_rad_apriori(j)
<        tracegas(k, 3) = SQRT(sa(i, i))
<        tracegas(k, 4) = fitvar_rad(j)
<        tracegas(k, 5) = fitvar_rad_std(j) 
<        tracegas(k, 6) = fitvar_rad_nstd(j) 
<        tracegas(k, 1:6) = tracegas(k, 1:6) / refspec_norm(gasidxs(k))  
<        fitvar_rad(j) = tracegas(k, 4)
<        fitvar_rad_std(j) = tracegas(k, 5); fitvar_rad_nstd(j) = tracegas(k, 6)
---
>   ! trace gases
>   DO k = 1, ngas
>      i = fgasidxs(k)
>      IF (i > 0) THEN
>         j = mask_fitvar_rad(i)
>         tracegas(k, 1) = fitvar_rad_init(j)
>         tracegas(k, 2) = fitvar_rad_apriori(j)
>         tracegas(k, 3) = SQRT(sa(i, i))
>         tracegas(k, 4) = fitvar_rad(j)
>         tracegas(k, 5) = fitvar_rad_std(j) 
>         tracegas(k, 6) = fitvar_rad_nstd(j) 
>         tracegas(k, 1:6) = tracegas(k, 1:6) / refspec_norm(gasidxs(k))  
>         fitvar_rad(j) = tracegas(k, 4)
>         fitvar_rad_std(j) = tracegas(k, 5); fitvar_rad_nstd(j) = tracegas(k, 6)
800,810c829,839
<        ! xliu: 07/01/2010, 08/09/2010
<        ! Change weighting function and contribution function for trace gas variables 
<        ! wrt to the reported unit instead of normalized quantities
<        IF (ozwrtwf) THEN
<           weight_function(1:npoints, i) = weight_function(1:npoints, i) * refspec_norm(gasidxs(k)) 
<           trace_profwf(k, 1:npoints, 1:nlay) = trace_profwf(k, 1:npoints, 1:nlay) * refspec_norm(gasidxs(k))
<        ENDIF
<        IF (ozwrtcontri) THEN
<           contri(i, 1:npoints) = contri(i, 1:npoints) / refspec_norm(gasidxs(k))  
<           trace_contri(k, 1:npoints) = contri(i, 1:npoints)
<        ENDIF
---
>         ! xliu: 07/01/2010, 08/09/2010
>         ! Change weighting function and contribution function for trace gas variables 
>         ! wrt to the reported unit instead of normalized quantities
>         IF (ozwrtwf) THEN
>            weight_function(1:npoints, i) = weight_function(1:npoints, i) * refspec_norm(gasidxs(k)) 
>            trace_profwf(k, 1:npoints, 1:nlay) = trace_profwf(k, 1:npoints, 1:nlay) * refspec_norm(gasidxs(k))
>         ENDIF
>         IF (ozwrtcontri) THEN
>            contri(i, 1:npoints) = contri(i, 1:npoints) / refspec_norm(gasidxs(k))  
>            trace_contri(k, 1:npoints) = contri(i, 1:npoints)
>         ENDIF
812,818c841,847
<        ! Add trace gas profile (a priori profile/shape)
<        DO j = 1, nlay
<           fidx = nup2p(j - 1) + 1; lidx = nup2p(j)
<           trace_prof(k, j) = SUM(mgasprof(k, fidx:lidx))
<        ENDDO    
<     ENDIF
<  ENDDO
---
>         ! Add trace gas profile (a priori profile/shape)
>         DO j = 1, nlay
>            fidx = nup2p(j - 1) + 1; lidx = nup2p(j)
>            trace_prof(k, j) = SUM(mgasprof(k, fidx:lidx))
>         ENDDO
>      ENDIF
>   ENDDO
820,829c849,851
<  IF ( taodfind > 0) THEN
<     aodscl = fitvar_rad(taodind) / tropaod(actawin)
<     tropaod(1:actawin) = tropaod(1:actawin) * aodscl
<     
<     IF ( twaefind == 0 ) THEN  ! Single scattering albedo does not change
<        tropsca(1:actawin) = tropsca(1:actawin) * aodscl
<     ENDIF
<  ELSE
<     aodscl = 1.0
<  ENDIF
---
>   IF ( taodfind > 0) THEN
>      aodscl = fitvar_rad(taodind) / tropaod(actawin)
>      tropaod(1:actawin) = tropaod(1:actawin) * aodscl
831,835c853,858
< IF ( twaefind > 0 ) THEN
<     waerscl = fitvar_rad(twaeind) / tropwaer(actawin)   ! Scale single scattering albedo
<     tropwaer(1:actawin) = tropwaer(1:actawin) * waerscl
<     tropsca(1:actawin)  = tropsca(1:actawin) * waerscl * aodscl
<  ENDIF
---
>      IF ( twaefind == 0 ) THEN  ! Single scattering albedo does not change
>         tropsca(1:actawin) = tropsca(1:actawin) * aodscl
>      ENDIF
>   ELSE
>      aodscl = 1.0
>   ENDIF
837,841c860,864
<  IF ( saodfind > 0 ) THEN
<     aodscl = fitvar_rad(saodind) / strataod(actawin)
<     strataod(1:actawin) = strataod(1:actawin) * aodscl    
<     stratsca(1:actawin) = stratsca(1:actawin) * aodscl
<  ENDIF
---
>   IF ( twaefind > 0 ) THEN
>      waerscl = fitvar_rad(twaeind) / tropwaer(actawin)   ! Scale single scattering albedo
>      tropwaer(1:actawin) = tropwaer(1:actawin) * waerscl
>      tropsca(1:actawin)  = tropsca(1:actawin) * waerscl * aodscl
>   ENDIF
843,845c866,870
<  IF ( ecfrfind > 0) THEN
<     the_cfrac = fitvar_rad(ecfrind )
<  ENDIF
---
>   IF ( saodfind > 0 ) THEN
>      aodscl = fitvar_rad(saodind) / strataod(actawin)
>      strataod(1:actawin) = strataod(1:actawin) * aodscl    
>      stratsca(1:actawin) = stratsca(1:actawin) * aodscl
>   ENDIF
847,849c872,874
<  IF (sprsfind > 0) THEN
<     atmosprof(1, nsfc) = fitvar_rad(sprsind)
<  ENDIF
---
>   IF ( ecfrfind > 0) THEN
>      the_cfrac = fitvar_rad(ecfrind )
>   ENDIF
851c876,880
<  RETURN
---
>   IF (sprsfind > 0) THEN
>      atmosprof(1, nsfc) = fitvar_rad(sprsind)
>   ENDIF
> 
>   RETURN
============================
spectra_reflectance.f90
9d8
< 
17c16
<        com1_idx, no2_t1_idx, no2_t2_idx, &
---
>        com1_idx, no2_t1_idx, no2_t2_idx, com2_idx, com3_idx,  &
21,22c20
<        up_radbnd, database_shiwf, slwf, numwin, nradpix, refspec_norm, refidx, &
<         cmcspec
---
>        up_radbnd, database_shiwf, slwf, numwin, nradpix, refspec_norm, refidx
24c22
<        osfind, slind, slfind, shind, shfind, rnind, rnfind, dcind,      &
---
>        osind, osfind, slind, slfind, shind, shfind, rnind, rnfind, dcind,      &
27,28c25
<        cmfind, cmind, cmwins, ncm,&
<        fit_atanring
---
>        fit_atanring, rtm_treatment
30c27
<   
---
> 
42c39
<   
---
> 
52c49
<   REAL (KIND=dp), DIMENSION (ns)      :: del, sunspec_ss, locdbs, dfdsl, gshiwf, tempsum, temp
---
>   REAL (KIND=dp), DIMENSION (ns)      :: del, sunspec_ss, locdbs, dfdsl, gshiwf, tempsum
54c51
<   REAL (KIND=dp), DIMENSION (ns)      :: corrected_irrad, corr,corr0, corrected_rad,corrected_rad0
---
>   REAL (KIND=dp), DIMENSION (ns)      :: corrected_irrad, corr, corrected_rad
76d72
<                 
78c74
<   
---
> 
90c86
<         ENDIF       
---
>         ENDIF
94c90
<         
---
> 
101c97
<   
---
> 
105d100
< 
121c116
<      
---
> 
137c132
<                    fitvar_rad(slind(i, 1)) 
---
>                 fitvar_rad(slind(i, 1)) 
188c183
<         
---
> 
223c218
<  
---
> 
229c224
<                 + fitvar_rad(isind(1, 1)) * tempsum(fidx:lidx)
---
>              + fitvar_rad(isind(1, 1)) * tempsum(fidx:lidx)
237,274c232,269
< 
< !  ! Internal Scattering in Irradiance (use stray-light spectra)
< !  IF ( nis > 0 ) THEN
< !     IF (do_subfit) THEN
< !        fidx = 1
< !        DO i = 1, numwin
< !           lidx =  fidx + nradpix(i) - 1
< !           wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
< !           del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
< !
< !           IF (isfind(i, 1) > 0) sunspec_ss(fidx:lidx) = sunspec_ss(fidx:lidx) &
< !                + fitvar_rad(isind(i, 1)) * database(fsl_idx, refidx(fidx:lidx))
< !           DO j = 2, nis
< !              IF (isfind(i, j) > 0) sunspec_ss(fidx:lidx) = sunspec_ss(fidx:lidx) + &
< !                   fitvar_rad(isind(i, j)) * database(fsl_idx, refidx(fidx:lidx)) * del(fidx:lidx) ** (j-1) 
< !           ENDDO
< !           fidx = lidx + 1
< !        ENDDO
< !     ELSE
< !        IF (iswins(1, 1) == 1) THEN
< !           fidx = 1
< !        ELSE
< !           fidx = SUM(nradpix(1: iswins(1, 1)-1)) + 1 
< !        ENDIF
< !        lidx = SUM(nradpix(1: iswins(1, 2)))
< ! 
< !        wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
< !        del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
< !
< !        IF (isfind(1, 1) > 0) sunspec_ss(fidx:lidx) = sunspec_ss(fidx:lidx) &
< !                + fitvar_rad(isind(1, 1)) * database(fsl_idx, refidx(fidx:lidx))
< !        DO j = 2, nis
< !           IF (isfind(1, j) > 0) sunspec_ss(fidx:lidx) = sunspec_ss(fidx:lidx) + &
< !                fitvar_rad(isind(1, j)) * database(fsl_idx, refidx(fidx:lidx)) * del(fidx:lidx) ** (j-1)
< !        ENDDO
< !     ENDIF
< !  ENDIF
< !  corrected_irrad = sunspec_ss 
---
>  
>   !  ! Internal Scattering in Irradiance (use stray-light spectra)
>   !  IF ( nis > 0 ) THEN
>   !     IF (do_subfit) THEN
>   !        fidx = 1
>   !        DO i = 1, numwin
>   !           lidx =  fidx + nradpix(i) - 1
>   !           wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
>   !           del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
>   !
>   !           IF (isfind(i, 1) > 0) sunspec_ss(fidx:lidx) = sunspec_ss(fidx:lidx) &
>   !                + fitvar_rad(isind(i, 1)) * database(fsl_idx, refidx(fidx:lidx))
>   !           DO j = 2, nis
>   !              IF (isfind(i, j) > 0) sunspec_ss(fidx:lidx) = sunspec_ss(fidx:lidx) + &
>   !                   fitvar_rad(isind(i, j)) * database(fsl_idx, refidx(fidx:lidx)) * del(fidx:lidx) ** (j-1) 
>   !           ENDDO
>   !           fidx = lidx + 1
>   !        ENDDO
>   !     ELSE
>   !        IF (iswins(1, 1) == 1) THEN
>   !           fidx = 1
>   !        ELSE
>   !           fidx = SUM(nradpix(1: iswins(1, 1)-1)) + 1 
>   !        ENDIF
>   !        lidx = SUM(nradpix(1: iswins(1, 2)))
>   ! 
>   !        wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
>   !        del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
>   !
>   !        IF (isfind(1, 1) > 0) sunspec_ss(fidx:lidx) = sunspec_ss(fidx:lidx) &
>   !                + fitvar_rad(isind(1, 1)) * database(fsl_idx, refidx(fidx:lidx))
>   !        DO j = 2, nis
>   !           IF (isfind(1, j) > 0) sunspec_ss(fidx:lidx) = sunspec_ss(fidx:lidx) + &
>   !                fitvar_rad(isind(1, j)) * database(fsl_idx, refidx(fidx:lidx)) * del(fidx:lidx) ** (j-1)
>   !        ENDDO
>   !     ENDIF
>   !  ENDIF
>   !  corrected_irrad = sunspec_ss 
279,280c274,275
<      IF (fitvar_rad(i) == 0.0) CYCLE                !  no such parameter
<       
---
>      IF (fitvar_rad(i) == 0.0 .OR. rtm_treatment(j)) CYCLE  !  no such parameter
> 
296c291
<         
---
> 
316c311
<          !  print * ,'nir',i, fitvar_rad(irind(i, 1)),SUM(corrected_rad(fidx:lidx))        
---
> 
319,320d313
<             ! IF (irfind(i, 1) > 0)    print * , i , fitvar_rad(irind(i,1))
<            !IF (irfind(i, 1) > 0)   print * , tempsum(fidx:fidx+10)
324d316
<          
328d319
< 
349,350d339
< 
<   
353,392c342,425
< ! ! Internal Scattering in Radiance  (fit straylight spectrum)
< !  corrected_rad = currspec(1:ns)
< !  IF ( nir > 0 ) THEN
< !     IF (do_subfit) THEN
< !        fidx = 1
< !        DO i = 1, numwin
< !           lidx =  fidx + nradpix(i) - 1
< !     
< !           wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
< !           del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
< !     
< !           IF (irfind(i, 1) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) * &
< !                   (1.0 - fitvar_rad(irind(i, 1)) * database(rsl_idx, refidx(fidx:lidx)))
< !           DO j = 2, nir
< !              IF (irfind(i, j) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) *  &
< !                (1.0 - fitvar_rad(irind(i, j)) * database(rsl_idx, refidx(fidx:lidx)) * del(fidx:lidx) ** (j-1))  
< !           ENDDO
< !           fidx = lidx + 1
< !        ENDDO
< !     ELSE
< !        IF (irwins(1, 1) == 1) THEN
< !           fidx = 1
< !        ELSE
< !           fidx = SUM(nradpix(1: irwins(1, 1)-1)) + 1 
< !        ENDIF
< !        lidx = SUM(nradpix(1: irwins(1, 2))) 
< !        wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
< !        del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
< !        
< !        IF (irfind(1, 1) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) * &
< !                  (1.0 - fitvar_rad(irind(1, 1)) * database(rsl_idx, refidx(fidx:lidx)))
< !        
< !        DO j = 2, nir
< !           IF (irfind(1, j) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) * &
< !                (1.0 - fitvar_rad(irind(1, j)) * database(rsl_idx, refidx(fidx:lidx)) * del(fidx:lidx) ** (j-1))
< !        ENDDO
< !     ENDIF
< !  ENDIF
< !  fitspec = corrected_rad / corrected_irrad * div_rad / div_sun  
<   
---
> !!$ ! Internal Scattering in Radiance  (fit straylight spectrum)
> !!$  corrected_rad = currspec(1:ns)
> !!$  IF ( nir > 0 ) THEN
> !!$     IF (do_subfit) THEN
> !!$        fidx = 1
> !!$        DO i = 1, numwin
> !!$           lidx =  fidx + nradpix(i) - 1
> !!$     
> !!$           wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
> !!$           del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
> !!$     
> !!$           IF (irfind(i, 1) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) * &
> !!$                   (1.0 - fitvar_rad(irind(i, 1)) * database(rsl_idx, refidx(fidx:lidx)))
> !!$           DO j = 2, nir
> !!$              IF (irfind(i, j) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) *  &
> !!$                (1.0 - fitvar_rad(irind(i, j)) * database(rsl_idx, refidx(fidx:lidx)) * del(fidx:lidx) ** (j-1))  
> !!$           ENDDO
> !!$           fidx = lidx + 1
> !!$        ENDDO
> !!$     ELSE
> !!$        IF (irwins(1, 1) == 1) THEN
> !!$           fidx = 1
> !!$        ELSE
> !!$           fidx = SUM(nradpix(1: irwins(1, 1)-1)) + 1 
> !!$        ENDIF
> !!$       lidx = SUM(nradpix(1: irwins(1, 2))) 
> !!$        wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
> !!$        del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
> !!$        
> !!$        IF (irfind(1, 1) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) * &
> !!$                  (1.0 - fitvar_rad(irind(1, 1)) * database(rsl_idx, refidx(fidx:lidx)))
> !!$        
> !!$        DO j = 2, nir
> !!$           IF (irfind(1, j) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) * &
> !!$                (1.0 - fitvar_rad(irind(1, j)) * database(rsl_idx, refidx(fidx:lidx)) * del(fidx:lidx) ** (j-1))
> !!$        ENDDO
> !!$     ENDIF
> !!$  ENDIF
> !!$  fitspec = corrected_rad / corrected_irrad * div_rad / div_sun  
>  
>      ! zcai@20160815  test it later 
> !!$  ! Internal Scattering in Radiance  (use radiance response spectrum)
> !!$  corrected_rad = currspec(1:ns)
> !!$  IF ( nir > 0 ) THEN
> !!$     IF (do_subfit) THEN
> !!$        fidx = 1
> !!$        DO i = 1, numwin
> !!$           lidx =  fidx + nradpix(i) - 1
> !!$
> !!$           wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
> !!$           del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
> !!$           IF (irfind(i, 1) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) - &
> !!$                fitvar_rad(irind(i, 1)) / div_rad / database(rsl_idx, refidx(fidx:lidx))!
> !!$           DO j = 2, nir
> !!$              IF (irfind(i, j) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) -  &
> !!$                   fitvar_rad(irind(i, j)) * del(fidx:lidx) ** (j-1 ) / div_rad            &
> !!$                   / database(rsl_idx, refidx(fidx:lidx))
> !!$           ENDDO
> !!$           fidx = lidx + 1
> !!$        ENDDO
> !!$     ELSE
> !!$        IF (irwins(1, 1) == 1) THEN
> !!$           fidx = 1
> !!$        ELSE
> !!$           fidx = SUM(nradpix(1: irwins(1, 1)-1)) + 1
> !!$        ENDIF
> !!$        lidx = SUM(nradpix(1: irwins(1, 2)))
> !!$        wavg = (fitwavs(fidx) + fitwavs(lidx)) * 0.5
> !!$        del(fidx:lidx) = fitwavs(fidx:lidx) - wavg
> !!$
> !!$        IF (irfind(1, 1) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) - &
> !!$             fitvar_rad(irind(1, 1)) / div_rad / database(rsl_idx, refidx(fidx:lidx))
> !!$        DO j = 2, nir
> !!$           IF (irfind(1, j) > 0) corrected_rad(fidx:lidx) = corrected_rad(fidx:lidx) -  &
> !!$                fitvar_rad(irind(1, j)) * del(fidx:lidx) ** (j-1)  / div_rad &
> !!$                / database(rsl_idx, refidx(fidx:lidx))
> !!$        ENDDO
> !!$     ENDIF
> !!$  ENDIF
> !!$  fitspec = corrected_rad / corrected_irrad * div_rad / div_sun
>  
> 
> 
> 
397,421c430,452
<   !DO j = no2_t1_idx, max_rs_idx
<   !   IF (j == comm_idx .OR. j == com1_idx) THEN
<   !      i = max_calfit_idx + (j-1) * mxs_idx + lbe_idx
<   !      
<   !      IF (fitvar_rad(i) == 0.0) CYCLE !no such parameter
<   !      
<   !      k = shift_offset + j
<   !      IF (fitvar_rad(k) == 0.0) THEN
<   !         locdbs(1:ns) = database(j, refidx(1:ns))
<   !      ELSE 
<   !         refpos_ss(1:n_refwvl) = refwvl(1:n_refwvl) + fitvar_rad(k)       
<   !         cal_shiwf = .FALSE.           
<   !         IF (lo_radbnd(k) < up_radbnd(k) .AND. do_shiwf) cal_shiwf = .TRUE.
<   !         CALL bspline2(refpos_ss(1:n_refwvl)-fitvar_rad(k), database(j,1:n_refwvl), n_refwvl, &
<   !              cal_shiwf, fitwavs(1:ns), locdbs(1:ns), gshiwf, ns, errstat)
<   !         database_shiwf(j, refidx(1:ns)) = gshiwf
<   !         IF (errstat < 0) THEN
<   !            WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat
<   !            errstat = pge_errstat_error; RETURN
<   !         ENDIF
<   !      END IF
<   !      
<   !      fitspec(1:ns) = fitspec(1:ns) * EXP( fitvar_rad(i) * locdbs(1:ns))
<   !   ENDIF
<   !END DO
---
>   DO j = no2_t1_idx, max_rs_idx
>      i = max_calfit_idx + (j-1) * mxs_idx + lbe_idx
> 
>      IF (fitvar_rad(i) == 0.0 .OR. rtm_treatment(j)) CYCLE   !  no such parameter
> 
>      k = shift_offset + j
>      IF (fitvar_rad(k) == 0.0) THEN
>         locdbs(1:ns) = database(j, refidx(1:ns))
>      ELSE 
>         refpos_ss(1:n_refwvl) = refwvl(1:n_refwvl) + fitvar_rad(k)       
>         cal_shiwf = .FALSE.           
>         IF (lo_radbnd(k) < up_radbnd(k) .AND. do_shiwf) cal_shiwf = .TRUE.
>         CALL bspline2(refpos_ss(1:n_refwvl)-fitvar_rad(k), database(j,1:n_refwvl), n_refwvl, &
>              cal_shiwf, fitwavs(1:ns), locdbs(1:ns), gshiwf, ns, errstat)
>         database_shiwf(j, refidx(1:ns)) = gshiwf
>         IF (errstat < 0) THEN
>            WRITE(*, *) modulename, ': BSPLINE error, errstat = ', errstat
>            errstat = pge_errstat_error; RETURN
>         ENDIF
>      END IF
> 
>      fitspec(1:ns) = fitspec(1:ns) * EXP( fitvar_rad(i) * locdbs(1:ns))
>   END DO
424,425c455
<    
<   IF (.NOT. fit_atanring) THEN ! here
---
>   IF (.NOT. fit_atanring) THEN
428c458
<         
---
> 
433c463
<               
---
> 
435c465
<               
---
> 
437c467
<           
---
> 
445d474
< 
453c482
<            
---
> 
455c484
<            
---
> 
457c486
<            
---
> 
463d491
<         
465c493,494
<          !print * ,database(ring_idx, refidx(1:ns))
---
>      ELSE
>         fitspec = fitspec * EXP(database(ring_idx, refidx(1:ns)) * (-1.0))
468,490c497,500
<      ! Fitting Ring effect using y = -[a0 * [atan((x-a1)/a2) + 1.54223] + 1]
<      corr = atan( (fitwavs - fitvar_rad(rnind(1, 2))) / fitvar_rad(rnind(1, 3)) )
<      corr = -(fitvar_rad(rnind(1, 1)) * (corr - corr(1)) + 1.0)
<      fitspec = fitspec * EXP(database(ring_idx, refidx(1:ns)) * corr)     
<   ENDIF
< 
<   IF (ncm > 0 ) THEN  !JBAk
<     fidx = 1
<     corr = 0.0
<     corr0 = cmcspec(1:ns)*fitspec
<     DO i = 1, numwin
<       lidx = fidx + nradpix(i) -1
<       del(fidx:lidx) = fitwavs(fidx:lidx) - ( (fitwavs(fidx)+fitwavs(lidx))*0.5)
<       IF ( cmfind(i,1) > 0 ) corr(fidx:lidx) = corr0(fidx:lidx)*fitvar_rad(cmind(i,1))
<       DO j = 2, ncm
<           WRITE(*,*) 'Neec to check for this'
<           stop
<           if (cmfind(i,j) > 0 ) corr(fidx:lidx) = corr(fidx:lidx) + fitvar_rad(cmind(i,j))*del(fidx:lidx)**(j-1)
<       ENDDO
< !      print * , fitvar_rad(cmind(i,1))
<     ENDDO
<       fitspec (1:ns) = fitspec(1:ns) - corr(1:ns)
< !     print * , fitvar_rad(cmind(1,1))
---
>      ! Fitting Ring effect using atan or tanh: y = -[a0 * [atan((x-a1)/a2) - y(1)] + 1.0]
>      corr = tanh( (fitwavs - fitvar_rad(rnind(1, 2))) / fitvar_rad(rnind(1, 3)) )
>      corr = -(fitvar_rad(rnind(1, 1)) * (corr-corr(1)) + 1.0)
>      fitspec = fitspec * EXP(database(ring_idx, refidx(1:ns)) * corr)
497,499c507,508
<       
<      IF (fitvar_rad(i) == 0.0) CYCLE ! no such parameter
<      
---
>      IF (fitvar_rad(i) == 0.0 .OR. rtm_treatment(j)) CYCLE   !  no such parameter
> 
505c514
<        
---
> 
516,517c525,526
<      
<      IF (j == comm_idx .OR. j == com1_idx) THEN ! locdbs is rel % diff. btw. measured and simulated
---
> 
>      IF (j == comm_idx .OR. j == com1_idx .OR. j == com2_idx .OR. j == com3_idx) THEN ! locdbs is rel % diff. btw. measured and simulated
524d532
< 
